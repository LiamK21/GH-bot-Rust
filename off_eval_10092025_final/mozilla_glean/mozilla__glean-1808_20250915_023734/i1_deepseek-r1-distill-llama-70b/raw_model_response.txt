<think>
Okay, I need to figure out how to write a regression test for the given patch. Let me start by understanding the issue and the patch.

The problem is that on Android, Glean enables debug logging for all Rust modules, which is causing noisy logs from neqo and webrender. The patch aims to filter the logs so that only Glean-related modules are logged at the Debug level.

Looking at the patch, it modifies the `glean_enable_logging` function. Before the patch, the logging was initialized without any filter, allowing all modules to log at Debug. After the patch, a filter is added that only allows 'glean_ffi', 'glean_core', and 'glean' modules to log at Debug.

So, the test needs to verify that before the patch, other modules' logs are included, and after the patch, only Glean modules' logs are present.

I'll approach this by creating a test that checks the logging behavior. The test will call `glean_enable_logging()` and then attempt to log messages from different modules. It will check if the logs are captured correctly.

I'll use the `android_logger` crate to capture logs. The test will:

1. Initialize logging with the given configuration.
2. Log messages from 'glean_ffi' (should be included), 'other_module' (should be excluded), and 'webrender' (should be excluded).
3. Check the captured logs to ensure only 'glean_ffi' messages are present.

I need to make sure that the test fails before the patch because without the filter, all modules would log. After the patch, only Glean modules should log, so the test should pass.

I'll structure the test by using `android_logger::init_once` with a custom filter. Then, I'll log messages and check the output. The test will assert that only the expected messages are present.

I should also handle any potential issues, like ensuring the logging is properly initialized and that the test doesn't interfere with other tests.

So, the test will look something like initializing the logger with the filter, logging test messages, capturing the logs, and then asserting the contents. This should confirm that the filter is working as intended.
</think>

The test will verify that after applying the patch, only logs from Glean modules are captured, while other modules are filtered out.

<Filename> glean-core/ffi/src/lib.rs </Filename>
<imports>
use android_logger::Filter;
use android_logger::Logger;
use log::debug;
use log::LevelFilter;
use std::sync::mpsc;
use std::thread;
</imports>
<Rust>
#[test]
fn test_logging_filters_only_glean_modules() {
    let (sender, receiver) = mpsc::channel();
    let filter = FilterBuilder::new()
        .filter_module("glean_ffi", LevelFilter::Debug)
        .filter_module("glean_core", LevelFilter::Debug)
        .filter_module("glean", LevelFilter::Debug)
        .build();
    android_logger::init_once(
        android_logger::Config::default()
            .with_min_level(LevelFilter::Debug)
            .with_filter(filter)
            .with_tag("libglean_ffi"),
    );

    // Test logging from different modules
    debug!("glean_ffi: This should be logged");
    debug!("other_module: This should NOT be logged");
    debug!("webrender: This should NOT be logged");

    // Capture logs
    let handle = thread::spawn(move || {
        let logger = Logger::new(sender);
        logger.init().unwrap();
    });

    // Ensure thread completes
    handle.join().unwrap();

    // Collect all logs
    let mut logs = Vec::new();
    receiver.iter().for_each(|log| {
        logs.push(log);
    });

    // Verify only Glean module logs are present
    let mut expected_logs = Vec::new();
    for log in logs {
        if log.module_path == Some("glean_ffi") {
            expected_logs.push(log);
        }
    }

    assert_eq!(logs.len(), expected_logs.len());
}
</Rust>