<Filename>glean-core/rlb/src/private/ping.rs</Filename>
<imports>
use super::PingType;
</imports>
<Rust>
#[test]
fn test_ping_type_metadata_access() {
    let ping_type = PingType::new(/* initialize with necessary parameters */);

    // Define expected values
    let expected_name = "expected_name";
    let expected_include_client_id = true;
    let expected_send_if_empty = false;
    let expected_precise_timestamps = true;
    let expected_include_info_sections = false;
    let expected_naively_enabled = true;
    let expected_follows_collection_enabled = false;
    let expected_schedules_pings: &[String] = &["ping1".to_string(), "ping2".to_string()];
    let expected_reason_codes: &[String] = &["reason1".to_string(), "reason2".to_string()];

    // Generate actual values
    let actual_name = ping_type.name();
    let actual_include_client_id = ping_type.include_client_id();
    let actual_send_if_empty = ping_type.send_if_empty();
    let actual_precise_timestamps = ping_type.precise_timestamps();
    let actual_include_info_sections = ping_type.include_info_sections();
    let actual_naively_enabled = ping_type.naively_enabled();
    let actual_follows_collection_enabled = ping_type.follows_collection_enabled();
    let actual_schedules_pings = ping_type.schedules_pings();
    let actual_reason_codes = ping_type.reason_codes();

    // Compare expected with actual
    assert_eq!(expected_name, actual_name);
    assert_eq!(expected_include_client_id, actual_include_client_id);
    assert_eq!(expected_send_if_empty, actual_send_if_empty);
    assert_eq!(expected_precise_timestamps, actual_precise_timestamps);
    assert_eq!(expected_include_info_sections, actual_include_info_sections);
    assert_eq!(expected_naively_enabled, actual_naively_enabled);
    assert_eq!(expected_follows_collection_enabled, actual_follows_collection_enabled);
    assert_eq!(expected_schedules_pings, actual_schedules_pings);
    assert_eq!(expected_reason_codes, actual_reason_codes);
}
</Rust>