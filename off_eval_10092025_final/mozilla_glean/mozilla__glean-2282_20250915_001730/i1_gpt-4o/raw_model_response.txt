<Filename>glean-core/src/lib.rs</Filename>
<imports>
use super::glean_set_metrics_disabled_config;
use crate::metrics::MetricsDisabledConfig;
use std::convert::TryFrom;
use crate::Glean;
use crate::metrics::StringMetric;
use crate::CommonMetricData;
</imports>
<Rust>
#[test]
fn test_glean_set_metrics_disabled_config() {
    let (glean, _t) = new_glean(None);
    let metric = StringMetric::new(CommonMetricData {
        category: "category".to_string(),
        name: "string_metric".to_string(),
        send_in_pings: vec!["baseline".to_string()],
        ..Default::default()
    });

    // Set the metric with a "TEST_VALUE" and ensure it was set
    metric.set_sync(&glean, "TEST_VALUE");
    assert_eq!(
        "TEST_VALUE",
        metric.get_value(&glean, "baseline").unwrap(),
        "Initial value must match"
    );

    // Set a configuration to disable the `category.string_metric`
    let metrics_disabled_config = json!(
        {
            "category.string_metric": true
        }
    )
    .to_string();
    glean_set_metrics_disabled_config(metrics_disabled_config);

    // Since the metric was disabled, setting a new value will be ignored
    metric.set_sync(&glean, "VALUE_AFTER_DISABLED");
    assert_eq!(
        "TEST_VALUE",
        metric.get_value(&glean, "baseline").unwrap(),
        "Shouldn't set when disabled"
    );

    // Set a new configuration where the metric is enabled
    let metrics_disabled_config = json!({}).to_string();
    glean_set_metrics_disabled_config(metrics_disabled_config);

    // Since the metric is now enabled, setting a new value should work
    metric.set_sync(&glean, "VALUE_AFTER_REENABLED");
    assert_eq!(
        "VALUE_AFTER_REENABLED",
        metric.get_value(&glean, "baseline").unwrap(),
        "Should set when re-enabled"
    );
}
</Rust>