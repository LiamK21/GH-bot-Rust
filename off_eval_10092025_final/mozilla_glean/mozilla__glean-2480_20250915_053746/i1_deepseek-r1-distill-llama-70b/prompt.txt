Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Make Server Knobs configurations merge-able by "feature-id"
In order to be able to share the Data Control Plane (Server Knobs) functionality between Nimbus features that wish to use it, at least in the short term until non-conflicting multi-feature rollouts and experiments capability is available in Nimbus, we need to be able to merge configurations from different features. This will allow each Nimbus feature to add a "glean" variable through which to pass metric configurations, and pass that configuration to Glean in a way that won't conflict with other feature's configurations.
</issue>

Patch:
<patch>
diff --git a/glean-core/src/core/mod.rs b/glean-core/src/core/mod.rs
--- a/glean-core/src/core/mod.rs
+++ b/glean-core/src/core/mod.rs
@@ -714,8 +714,10 @@ impl Glean {
     pub fn set_metrics_enabled_config(&self, cfg: MetricsEnabledConfig) {
         // Set the current MetricsEnabledConfig, keeping the lock until the epoch is
         // updated to prevent against reading a "new" config but an "old" epoch
-        let mut lock = self.remote_settings_metrics_config.lock().unwrap();
-        *lock = cfg;
+        let mut metric_config = self.remote_settings_metrics_config.lock().unwrap();
+
+        // Merge the exising configuration with the supplied one
+        metric_config.metrics_enabled.extend(cfg.metrics_enabled);
 
         // Update remote_settings epoch
         self.remote_settings_epoch.fetch_add(1, Ordering::SeqCst);

diff --git a/glean-core/src/lib_unit_tests.rs b/glean-core/src/lib_unit_tests.rs
--- a/glean-core/src/lib_unit_tests.rs
+++ b/glean-core/src/lib_unit_tests.rs
@@ -816,7 +816,7 @@ fn test_setting_log_pings() {
 }
 
 #[test]
-fn test_set_metrics_disabled() {
+fn test_set_remote_metric_configuration() {
     let (glean, _t) = new_glean(None);
     let metric = StringMetric::new(CommonMetricData {
         category: "category".to_string(),
@@ -882,13 +882,19 @@ fn test_set_metrics_disabled() {
         "Shouldn't set when disabled"
     );
 
-    // 4. Set a new configuration where the metrics are enabled
-    metrics_enabled_config = json!({}).to_string();
+    // 4. Set a new configuration where one metric is enabled
+    metrics_enabled_config = json!(
+        {
+            "category.string_metric": true,
+        }
+    )
+    .to_string();
     glean.set_metrics_enabled_config(
         MetricsEnabledConfig::try_from(metrics_enabled_config).unwrap(),
     );
 
-    // 5. Since the metrics are now enabled, setting a new value should work
+    // 5. Since the first metric is enabled, setting a new value should work
+    // on it but not the second metric
     metric.set_sync(&glean, "VALUE_AFTER_REENABLED");
     assert_eq!(
         "VALUE_AFTER_REENABLED",
@@ -899,7 +905,38 @@ fn test_set_metrics_disabled() {
         .get("label1")
         .set_sync(&glean, "VALUE_AFTER_REENABLED");
     assert_eq!(
-        "VALUE_AFTER_REENABLED",
+        "TEST_VALUE",
+        another_metric
+            .get("label1")
+            .get_value(&glean, "baseline")
+            .unwrap(),
+        "Should not set if metric config entry unchanged"
+    );
+
+    // 6. Set a new configuration where the second metric is enabled. This
+    // should be merged with the existing configuration and then both
+    // metrics should be enabled at that point.
+    metrics_enabled_config = json!(
+        {
+            "category.labeled_string_metric": true,
+        }
+    )
+    .to_string();
+    glean.set_metrics_enabled_config(
+        MetricsEnabledConfig::try_from(metrics_enabled_config).unwrap(),
+    );
+
+    // 7. Now both metrics are enabled, setting a new value should work for
+    // both metrics with the merged configurations
+    metric.set_sync(&glean, "FINAL VALUE");
+    assert_eq!(
+        "FINAL VALUE",
+        metric.get_value(&glean, "baseline").unwrap(),
+        "Should set when still enabled"
+    );
+    another_metric.get("label1").set_sync(&glean, "FINAL VALUE");
+    assert_eq!(
+        "FINAL VALUE",
         another_metric
             .get("label1")
             .get_value(&glean, "baseline")


</patch>

Function signatures
<Signatures>

</Signatures>

You are a software tester at glean and your are reviewing the above <patch> for the above <issue>
Identify whether a unit test is needed.
If there is no test needed, return <NO>.
If a test is needed, your task is:
1. Write exactly one rust test `#[test]fn test_...(){...}` block. Do NOT wrap the test inside a 'mod tests' block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. All 'use' declarations must be inside a <imports>...</imports> block.
 Use `use super::<function name> for the function under test.
.If multiple 'use' statements are needed, list each on a separate line.
5. To help you write the test, <Signatures> contains all modified function's:
- name
- parameters
- Return type (assume '()' if empty)
6. Return only the absolute filename as it is in the <patch> block, the use statements, and rust test (no comments or explanations).

Here is an example structure:
<Filename> ... </Filename>
<imports> ... </imports>
<Rust>
#[test]
fn test_<describe_behavior>() {
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
}</Rust>

