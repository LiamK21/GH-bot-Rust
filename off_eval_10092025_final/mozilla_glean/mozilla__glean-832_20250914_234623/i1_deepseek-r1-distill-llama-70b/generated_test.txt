#[test]
fn test_unrecoverable_upload_response_deletes_file() {
    let temp_dir = TempDir::new().unwrap();
    let (mut glean, dir) = {
        let mut glean = Glean::new(
            PathBuf::from(temp_dir.path()),
            None,
            Arc::new(AtomicBool::new(false)),
            None,
            None,
        )
        .unwrap();
        (glean, temp_dir)
    };

    // Register a ping for testing
    let ping_type = PingType::new("test", true, /* send_if_empty */ true, vec![]);
    glean.register_ping_type(&ping_type).unwrap();

    // Submit a ping
    glean.submit_ping(&ping_type, None).unwrap();

    // Create a new upload_manager
    let upload_manager = PingUploadManager::new(&dir.path()).unwrap();

    // Wait for processing of pending pings directory to finish.
    let mut upload_task = upload_manager.get_upload_task();
    while upload_task == PingUploadTask::Wait {
        std::thread::sleep(Duration::from_millis(10));
        upload_task = upload_manager.get_upload_task();
    }

    // Get the pending ping directory path
    let pending_pings_dir = dir.path().join("pending_pings");

    // Get the submitted PingRequest
    match upload_task {
        PingUploadTask::Upload(request) => {
            // Simulate the processing of a unrecoverable failure
            let uuid = request.uuid;
            upload_manager.process_ping_upload_response(&uuid, UploadResult::UnrecoverableFailure);
            // Verify file was deleted
            assert!(!pending_pings_dir.join(uuid).exists());
        }
        _ => panic!("Expected upload manager to return the next request!"),
    }

    // Verify that after request is returned, none are left
    assert_eq!(upload_manager.get_upload_task(), PingUploadTask::Done);
}