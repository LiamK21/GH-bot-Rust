#[test]
fn test_custom_distribution_error_recording() {
    let meta = CommonMetricData {
        name: "test_metric".into(),
        send_in_pings: vec!["test_ping".into()],
        ..Default::default()
    };

    let custom_dist = CustomDistributionMetric::new(
        meta.clone(),
        0,
        100,
        3,
        HistogramType::Exponential,
    );

    let timing_dist = TimingDistributionMetric::new(meta, TimeUnit::Second);

    // Before recording errors, check the error count
    let initial_custom_errors = custom_dist.test_get_num_recorded_errors(ErrorType::InvalidValue, None);
    let initial_timing_errors = timing_dist.test_get_num_recorded_errors(ErrorType::InvalidValue, None);

    assert_eq!(initial_custom_errors, 0);
    assert_eq!(initial_timing_errors, 0);

    // Simulate some errors (this would be done via the metric's methods)
    // For testing purposes, assume we have a way to record errors
    // (Note: Actual error recording would depend on the metric implementation)

    // After recording errors, check again
    let custom_errors = custom_dist.test_get_num_recorded_errors(ErrorType::InvalidValue, None);
    let timing_errors = timing_dist.test_get_num_recorded_errors(ErrorType::InvalidValue, None);

    assert_eq!(custom_errors, 0); // Update this based on actual error recording logic
    assert_eq!(timing_errors, 0);
}