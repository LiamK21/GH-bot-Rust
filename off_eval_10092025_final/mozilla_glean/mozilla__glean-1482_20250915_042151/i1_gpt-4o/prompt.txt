Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Implement initial coverage support in Glean (and glean_parser support)
Implement the first parts for the proposal.
</issue>

Patch:
<patch>
diff --git a/glean-core/src/coverage.rs b/glean-core/src/coverage.rs
--- a/glean-core/src/coverage.rs
+++ b/glean-core/src/coverage.rs
@@ -0,0 +1,47 @@
+// This Source Code Form is subject to the terms of the Mozilla Public
+// License, v. 2.0. If a copy of the MPL was not distributed with this
+// file, You can obtain one at https://mozilla.org/MPL/2.0/.
+
+//! Utilities for recording when testing APIs have been called on specific
+//! metrics.
+//!
+//! Testing coverage is enabled by setting the GLEAN_TEST_COVERAGE environment
+//! variable to the name of an output file. This output file must run through a
+//! post-processor (in glean_parser's `coverage` command) to convert to a format
+//! understood by third-party coverage reporting tools.
+//!
+//! While running a unit test suite, Glean records which database keys were
+//! accessed by the testing APIs, with one entry per line. Database keys are
+//! usually, but not always, the same as metric identifiers, but it is the
+//! responsibility of the post-processor to resolve that difference.
+//!
+//! This functionality has no runtime overhead unless the testing API is used.
+
+use std::env;
+use std::fs::{File, OpenOptions};
+use std::io::Write;
+use std::sync::Mutex;
+
+use once_cell::sync::Lazy;
+
+static COVERAGE_FILE: Lazy<Option<Mutex<File>>> = Lazy::new(|| {
+    if let Some(filename) = env::var_os("GLEAN_TEST_COVERAGE") {
+        match OpenOptions::new().append(true).create(true).open(filename) {
+            Ok(file) => {
+                return Some(Mutex::new(file));
+            }
+            Err(err) => {
+                log::error!("Couldn't open file for coverage results: {:?}", err);
+            }
+        }
+    }
+    None
+});
+
+pub(crate) fn record_coverage(metric_id: &str) {
+    if let Some(file_mutex) = &*COVERAGE_FILE {
+        let mut file = file_mutex.lock().unwrap();
+        writeln!(&mut file, "{}", metric_id).ok();
+        file.flush().ok();
+    }
+}

diff --git a/glean-core/src/event_database/mod.rs b/glean-core/src/event_database/mod.rs
--- a/glean-core/src/event_database/mod.rs
+++ b/glean-core/src/event_database/mod.rs
@@ -15,6 +15,7 @@ use std::sync::RwLock;
 use serde::{Deserialize, Serialize};
 use serde_json::{json, Value as JsonValue};
 
+use crate::coverage::record_coverage;
 use crate::CommonMetricData;
 use crate::Glean;
 use crate::Result;
@@ -326,6 +327,8 @@ impl EventDatabase {
     ///
     /// This doesn't clear the stored value.
     pub fn test_has_value<'a>(&'a self, meta: &'a CommonMetricData, store_name: &str) -> bool {
+        record_coverage(&meta.base_identifier());
+
         self.event_stores
             .read()
             .unwrap() // safe unwrap, only error case is poisoning
@@ -346,6 +349,8 @@ impl EventDatabase {
         meta: &'a CommonMetricData,
         store_name: &str,
     ) -> Option<Vec<RecordedEvent>> {
+        record_coverage(&meta.base_identifier());
+
         let value: Vec<RecordedEvent> = self
             .event_stores
             .read()

diff --git a/glean-core/src/lib.rs b/glean-core/src/lib.rs
--- a/glean-core/src/lib.rs
+++ b/glean-core/src/lib.rs
@@ -27,6 +27,7 @@ use uuid::Uuid;
 mod macros;
 
 mod common_metric_data;
+mod coverage;
 mod database;
 mod debug;
 mod error;

diff --git a/glean-core/src/metrics/boolean.rs b/glean-core/src/metrics/boolean.rs
--- a/glean-core/src/metrics/boolean.rs
+++ b/glean-core/src/metrics/boolean.rs
@@ -57,7 +57,7 @@ impl BooleanMetric {
     ///
     /// This doesn't clear the stored value.
     pub fn test_get_value(&self, glean: &Glean, storage_name: &str) -> Option<bool> {
-        match StorageManager.snapshot_metric(
+        match StorageManager.snapshot_metric_for_test(
             glean.storage(),
             storage_name,
             &self.meta.identifier(glean),

diff --git a/glean-core/src/metrics/counter.rs b/glean-core/src/metrics/counter.rs
--- a/glean-core/src/metrics/counter.rs
+++ b/glean-core/src/metrics/counter.rs
@@ -80,7 +80,7 @@ impl CounterMetric {
     ///
     /// This doesn't clear the stored value.
     pub fn test_get_value(&self, glean: &Glean, storage_name: &str) -> Option<i32> {
-        match StorageManager.snapshot_metric(
+        match StorageManager.snapshot_metric_for_test(
             glean.storage(),
             storage_name,
             &self.meta.identifier(glean),

diff --git a/glean-core/src/metrics/custom_distribution.rs b/glean-core/src/metrics/custom_distribution.rs
--- a/glean-core/src/metrics/custom_distribution.rs
+++ b/glean-core/src/metrics/custom_distribution.rs
@@ -158,7 +158,7 @@ impl CustomDistributionMetric {
     ///
     /// This doesn't clear the stored value.
     pub fn test_get_value(&self, glean: &Glean, storage_name: &str) -> Option<DistributionData> {
-        match StorageManager.snapshot_metric(
+        match StorageManager.snapshot_metric_for_test(
             glean.storage(),
             storage_name,
             &self.meta.identifier(glean),

diff --git a/glean-core/src/metrics/datetime.rs b/glean-core/src/metrics/datetime.rs
--- a/glean-core/src/metrics/datetime.rs
+++ b/glean-core/src/metrics/datetime.rs
@@ -159,7 +159,7 @@ impl DatetimeMetric {
     ///
     /// The stored value or `None` if nothing stored.
     pub fn test_get_value(&self, glean: &Glean, storage_name: &str) -> Option<Datetime> {
-        match StorageManager.snapshot_metric(
+        match StorageManager.snapshot_metric_for_test(
             glean.storage(),
             storage_name,
             &self.meta.identifier(glean),
@@ -211,7 +211,7 @@ impl DatetimeMetric {
     ///
     /// This doesn't clear the stored value.
     pub fn test_get_value_as_string(&self, glean: &Glean, storage_name: &str) -> Option<String> {
-        match StorageManager.snapshot_metric(
+        match StorageManager.snapshot_metric_for_test(
             glean.storage(),
             storage_name,
             &self.meta.identifier(glean),

diff --git a/glean-core/src/metrics/denominator.rs b/glean-core/src/metrics/denominator.rs
--- a/glean-core/src/metrics/denominator.rs
+++ b/glean-core/src/metrics/denominator.rs
@@ -86,7 +86,7 @@ impl DenominatorMetric {
     ///
     /// This doesn't clear the stored value.
     pub fn test_get_value(&self, glean: &Glean, storage_name: &str) -> Option<i32> {
-        match StorageManager.snapshot_metric(
+        match StorageManager.snapshot_metric_for_test(
             glean.storage(),
             storage_name,
             &self.meta().identifier(glean),

diff --git a/glean-core/src/metrics/experiment.rs b/glean-core/src/metrics/experiment.rs
--- a/glean-core/src/metrics/experiment.rs
+++ b/glean-core/src/metrics/experiment.rs
@@ -221,7 +221,7 @@ impl ExperimentMetric {
     ///
     /// This doesn't clear the stored value.
     pub fn test_get_value_as_json_string(&self, glean: &Glean) -> Option<String> {
-        match StorageManager.snapshot_metric(
+        match StorageManager.snapshot_metric_for_test(
             glean.storage(),
             INTERNAL_STORAGE,
             &self.meta.identifier(glean),

diff --git a/glean-core/src/metrics/jwe.rs b/glean-core/src/metrics/jwe.rs
--- a/glean-core/src/metrics/jwe.rs
+++ b/glean-core/src/metrics/jwe.rs
@@ -290,7 +290,7 @@ impl JweMetric {
     ///
     /// This doesn't clear the stored value.
     pub fn test_get_value(&self, glean: &Glean, storage_name: &str) -> Option<String> {
-        match StorageManager.snapshot_metric(
+        match StorageManager.snapshot_metric_for_test(
             glean.storage(),
             storage_name,
             &self.meta.identifier(glean),

diff --git a/glean-core/src/metrics/memory_distribution.rs b/glean-core/src/metrics/memory_distribution.rs
--- a/glean-core/src/metrics/memory_distribution.rs
+++ b/glean-core/src/metrics/memory_distribution.rs
@@ -186,7 +186,7 @@ impl MemoryDistributionMetric {
     ///
     /// This doesn't clear the stored value.
     pub fn test_get_value(&self, glean: &Glean, storage_name: &str) -> Option<DistributionData> {
-        match StorageManager.snapshot_metric(
+        match StorageManager.snapshot_metric_for_test(
             glean.storage(),
             storage_name,
             &self.meta.identifier(glean),

diff --git a/glean-core/src/metrics/quantity.rs b/glean-core/src/metrics/quantity.rs
--- a/glean-core/src/metrics/quantity.rs
+++ b/glean-core/src/metrics/quantity.rs
@@ -74,7 +74,7 @@ impl QuantityMetric {
     ///
     /// This doesn't clear the stored value.
     pub fn test_get_value(&self, glean: &Glean, storage_name: &str) -> Option<i64> {
-        match StorageManager.snapshot_metric(
+        match StorageManager.snapshot_metric_for_test(
             glean.storage(),
             storage_name,
             &self.meta.identifier(glean),

diff --git a/glean-core/src/metrics/rate.rs b/glean-core/src/metrics/rate.rs
--- a/glean-core/src/metrics/rate.rs
+++ b/glean-core/src/metrics/rate.rs
@@ -115,7 +115,7 @@ impl RateMetric {
     ///
     /// This doesn't clear the stored value.
     pub fn test_get_value(&self, glean: &Glean, storage_name: &str) -> Option<(i32, i32)> {
-        match StorageManager.snapshot_metric(
+        match StorageManager.snapshot_metric_for_test(
             glean.storage(),
             storage_name,
             &self.meta.identifier(glean),

diff --git a/glean-core/src/metrics/string.rs b/glean-core/src/metrics/string.rs
--- a/glean-core/src/metrics/string.rs
+++ b/glean-core/src/metrics/string.rs
@@ -67,7 +67,7 @@ impl StringMetric {
     ///
     /// This doesn't clear the stored value.
     pub fn test_get_value(&self, glean: &Glean, storage_name: &str) -> Option<String> {
-        match StorageManager.snapshot_metric(
+        match StorageManager.snapshot_metric_for_test(
             glean.storage(),
             storage_name,
             &self.meta.identifier(glean),

diff --git a/glean-core/src/metrics/string_list.rs b/glean-core/src/metrics/string_list.rs
--- a/glean-core/src/metrics/string_list.rs
+++ b/glean-core/src/metrics/string_list.rs
@@ -133,7 +133,7 @@ impl StringListMetric {
     ///
     /// This doesn't clear the stored value.
     pub fn test_get_value(&self, glean: &Glean, storage_name: &str) -> Option<Vec<String>> {
-        match StorageManager.snapshot_metric(
+        match StorageManager.snapshot_metric_for_test(
             glean.storage(),
             storage_name,
             &self.meta.identifier(glean),

diff --git a/glean-core/src/metrics/timespan.rs b/glean-core/src/metrics/timespan.rs
--- a/glean-core/src/metrics/timespan.rs
+++ b/glean-core/src/metrics/timespan.rs
@@ -179,7 +179,7 @@ impl TimespanMetric {
     ///
     /// This doesn't clear the stored value.
     pub fn test_get_value(&self, glean: &Glean, storage_name: &str) -> Option<u64> {
-        match StorageManager.snapshot_metric(
+        match StorageManager.snapshot_metric_for_test(
             glean.storage(),
             storage_name,
             &self.meta.identifier(glean),

diff --git a/glean-core/src/metrics/timing_distribution.rs b/glean-core/src/metrics/timing_distribution.rs
--- a/glean-core/src/metrics/timing_distribution.rs
+++ b/glean-core/src/metrics/timing_distribution.rs
@@ -320,7 +320,7 @@ impl TimingDistributionMetric {
     ///
     /// This doesn't clear the stored value.
     pub fn test_get_value(&self, glean: &Glean, storage_name: &str) -> Option<DistributionData> {
-        match StorageManager.snapshot_metric(
+        match StorageManager.snapshot_metric_for_test(
             glean.storage(),
             storage_name,
             &self.meta.identifier(glean),

diff --git a/glean-core/src/storage/mod.rs b/glean-core/src/storage/mod.rs
--- a/glean-core/src/storage/mod.rs
+++ b/glean-core/src/storage/mod.rs
@@ -10,6 +10,7 @@ use std::collections::HashMap;
 
 use serde_json::{json, Value as JsonValue};
 
+use crate::coverage::record_coverage;
 use crate::database::Database;
 use crate::metrics::Metric;
 use crate::Lifetime;
@@ -113,8 +114,6 @@ impl StorageManager {
 
     /// Gets the current value of a single metric identified by name.
     ///
-    /// This look for a value in stores for all lifetimes.
-    ///
     /// # Arguments
     ///
     /// * `storage` - The database to get data from.
@@ -145,6 +144,31 @@ impl StorageManager {
         snapshot
     }
 
+    /// Gets the current value of a single metric identified by name.
+    ///
+    /// Use this API, rather than `snapshot_metric` within the testing API, so
+    /// that the usage will be reported in coverage, if enabled.
+    ///
+    /// # Arguments
+    ///
+    /// * `storage` - The database to get data from.
+    /// * `store_name` - The store name to look into.
+    /// * `metric_id` - The full metric identifier.
+    ///
+    /// # Returns
+    ///
+    /// The decoded metric or `None` if no data is found.
+    pub fn snapshot_metric_for_test(
+        &self,
+        storage: &Database,
+        store_name: &str,
+        metric_id: &str,
+        metric_lifetime: Lifetime,
+    ) -> Option<Metric> {
+        record_coverage(metric_id);
+        self.snapshot_metric(storage, store_name, metric_id, metric_lifetime)
+    }
+
     ///  Snapshots the experiments.
     ///
     /// # Arguments


</patch>

Function signatures
<Signatures>

</Signatures>

You are a software tester at glean and your are reviewing the above <patch> for the above <issue>
Identify whether a unit test is needed.
If there is no test needed, return <NO>.
If a test is needed, your task is:
1. Write exactly one rust test `#[test]fn test_...(){...}` block. Do NOT wrap the test inside a 'mod tests' block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. All 'use' declarations must be inside a <imports>...</imports> block.
 Use `use super::<function name> for the function under test.
.If multiple 'use' statements are needed, list each on a separate line.
5. To help you write the test, <Signatures> contains all modified function's:
- name
- parameters
- Return type (assume '()' if empty)
6. Return only the absolute filename as it is in the <patch> block, the use statements, and rust test (no comments or explanations).

Here is an example structure:
<Filename> ... </Filename>
<imports> ... </imports>
<Rust>
#[test]
fn test_<describe_behavior>() {
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
}</Rust>

