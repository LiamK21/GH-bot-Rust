#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
async fn test_preinit_queue_respects_max_size() {
    let rt = Builder::new_multi_thread()
        .enable_all()
        .build()
        .unwrap();
    let _guard = rt.enter();

    let max_queue_size = 2;
    let dispatch = Dispatch::new(max_queue_size);
    let overflow_count = Arc::new(std::sync::atomic::AtomicUsize::new(0));

    // Send two tasks to fill the queue
    let task1 = async { /* task */ };
    let task2 = async { /* task */ };

    dispatch.send(task1).await.unwrap();
    dispatch.send(task2).await.unwrap();

    // Try to send a third task which should fail
    let result = dispatch.send(async { /* task */ }).await;
    assert_eq!(result, Err(DispatchError::QueueFull));

    // Verify overflow count is incremented
    assert_eq!(overflow_count.load(std::sync::atomic::Ordering::SeqCst), 1);
}