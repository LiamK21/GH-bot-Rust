#[test]
fn test_llvm_gcno_identification() {
    let tmp_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("test_data");
    let paths = vec![
        "test_data/llvm_gcno.gcno".to_string(),
        "test_data/non_llvm_gcno.gcno".to_string(),
    ];

    let mut file = File::create(&paths[0]).unwrap();
    file.write_all(b"ong*204").unwrap();  // LLVM magic bytes

    let mut file = File::create(&paths[1]).unwrap();
    file.write_all(b"not_magic").unwrap();  // Non-LLVM content

    let queue = Vec::new();
    let result = producer(&tmp_dir, &paths, &queue, false, true);

    let expected_gcno_stems = HashMap::from([
        GCNOStem {
            stem: "llvm_gcno".to_string(),
            llvm: true,
        },
        GCNOStem {
            stem: "non_llvm_gcno".to_string(),
            llvm: false,
        },
    ]);

    let actual_gcno_stems = result.unwrap()
        .into_iter()
        .find(|item| item.format == ItemFormat::GCNO)
        .unwrap()
        .item
        .buffers
        .unwrap()
        .stem;

    assert_eq!(expected_gcno_stems, actual_gcno_stems);
}