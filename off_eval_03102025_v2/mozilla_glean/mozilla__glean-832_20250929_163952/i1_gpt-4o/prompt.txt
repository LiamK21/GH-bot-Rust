Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Have process_ping_upload_request account for no-op upload attemps
The current `process_ping_upload_request` function inside the UploadManager in glean-core requires that we send ping uuid and request status code, but there might be no status in case it wasn't even possible to attempt a request. This function needs to properly deal with that.

This first came up in: https://github.com/mozilla/glean/pull/759#discussion_r388830213
</issue>

Patch:
<patch>
diff --git a/glean-core/ffi/src/lib.rs b/glean-core/ffi/src/lib.rs
--- a/glean-core/ffi/src/lib.rs
+++ b/glean-core/ffi/src/lib.rs
@@ -9,6 +9,7 @@ use std::panic::UnwindSafe;
 
 use ffi_support::{define_string_destructor, ConcurrentHandleMap, FfiStr, IntoFfi};
 
+pub use glean_core::upload::ffi_upload_result::*;
 use glean_core::Glean;
 
 mod macros;
@@ -349,7 +350,7 @@ pub extern "C" fn glean_get_upload_task() -> FfiPingUploadTask {
 // We need to pass the whole task instead of only the uuid,
 // so that we can free the strings properly on Drop.
 #[no_mangle]
-pub extern "C" fn glean_process_ping_upload_response(task: FfiPingUploadTask, status: u16) {
+pub extern "C" fn glean_process_ping_upload_response(task: FfiPingUploadTask, status: u32) {
     with_glean(|glean| {
         if let FfiPingUploadTask::Upload { uuid, .. } = task {
             assert!(!uuid.is_null());
@@ -358,7 +359,7 @@ pub extern "C" fn glean_process_ping_upload_response(task: FfiPingUploadTask, st
                     .to_str()
                     .map_err(|_| glean_core::Error::utf8_error())
             }?;
-            glean.process_ping_upload_response(uuid_str, status);
+            glean.process_ping_upload_response(uuid_str, status.into());
         };
         Ok(())
     });

diff --git a/glean-core/ffi/src/upload.rs b/glean-core/ffi/src/upload.rs
--- a/glean-core/ffi/src/upload.rs
+++ b/glean-core/ffi/src/upload.rs
@@ -6,6 +6,26 @@ use ffi_support::IntoFfi;
 use crate::glean_str_free;
 use glean_core::upload::PingUploadTask;
 
+/// Result values of attempted ping uploads encoded for FFI use.
+///
+/// These are defined in `glean-core/src/upload/result.rs`,
+/// but for cbindgen to also export them in header files we need to define them here as constants.
+///
+/// Tests below ensure they match.
+#[allow(dead_code)]
+mod upload_result {
+    /// A recoverable error.
+    pub const UPLOAD_RESULT_RECOVERABLE: u32 = 0x1;
+
+    /// An unrecoverable error.
+    pub const UPLOAD_RESULT_UNRECOVERABLE: u32 = 0x2;
+
+    /// A HTTP response code.
+    ///
+    /// The actual response code is encoded in the lower bits.
+    pub const UPLOAD_RESULT_HTTP_STATUS: u32 = 0x8000;
+}
+
 /// A FFI-compatible representation for the PingUploadTask
 ///
 /// The order of variants should be the same as in `glean-core/src/upload/mod.rs`
@@ -82,3 +102,24 @@ unsafe impl IntoFfi for FfiPingUploadTask {
         self
     }
 }
+
+#[cfg(test)]
+mod test {
+    use super::*;
+
+    #[test]
+    fn constants_match_with_glean_core() {
+        assert_eq!(
+            upload_result::UPLOAD_RESULT_RECOVERABLE,
+            glean_core::upload::ffi_upload_result::UPLOAD_RESULT_RECOVERABLE
+        );
+        assert_eq!(
+            upload_result::UPLOAD_RESULT_UNRECOVERABLE,
+            glean_core::upload::ffi_upload_result::UPLOAD_RESULT_UNRECOVERABLE
+        );
+        assert_eq!(
+            upload_result::UPLOAD_RESULT_HTTP_STATUS,
+            glean_core::upload::ffi_upload_result::UPLOAD_RESULT_HTTP_STATUS
+        );
+    }
+}

diff --git a/glean-core/src/lib.rs b/glean-core/src/lib.rs
--- a/glean-core/src/lib.rs
+++ b/glean-core/src/lib.rs
@@ -50,7 +50,7 @@ use crate::internal_pings::InternalPings;
 use crate::metrics::{Metric, MetricType, PingType};
 use crate::ping::PingMaker;
 use crate::storage::StorageManager;
-use crate::upload::{PingUploadManager, PingUploadTask};
+use crate::upload::{PingUploadManager, PingUploadTask, UploadResult};
 use crate::util::{local_now_with_offset, sanitize_application_id};
 
 const GLEAN_SCHEMA_VERSION: u32 = 1;
@@ -480,7 +480,7 @@ impl Glean {
     ///
     /// `uuid` - The UUID of the ping in question.
     /// `status` - The HTTP status of the response.
-    pub fn process_ping_upload_response(&self, uuid: &str, status: u16) {
+    pub fn process_ping_upload_response(&self, uuid: &str, status: UploadResult) {
         self.upload_manager
             .process_ping_upload_response(uuid, status);
     }

diff --git a/glean-core/src/upload/mod.rs b/glean-core/src/upload/mod.rs
--- a/glean-core/src/upload/mod.rs
+++ b/glean-core/src/upload/mod.rs
@@ -25,9 +25,11 @@ use serde_json::Value as JsonValue;
 
 use directory::PingDirectoryManager;
 use request::PingRequest;
+pub use result::{ffi_upload_result, UploadResult};
 
 mod directory;
 mod request;
+mod result;
 
 /// When asking for the next ping request to upload,
 /// the requester may receive one out of three possible tasks.
@@ -197,25 +199,28 @@ impl PingUploadManager {
     ///
     /// `uuid` - The UUID of the ping in question.
     /// `status` - The HTTP status of the response.
-    pub fn process_ping_upload_response(&self, uuid: &str, status: u16) {
+    pub fn process_ping_upload_response(&self, uuid: &str, status: UploadResult) {
+        use UploadResult::*;
         match status {
-            200..=299 => {
+            HttpStatus(status @ 200..=299) => {
                 log::info!("Ping {} successfully sent {}.", uuid, status);
                 self.directory_manager.delete_file(uuid);
             }
-            400..=499 => {
+
+            UnrecoverableFailure | HttpStatus(400..=499) => {
                 log::error!(
-                    "Server returned client error code {} while attempting to send ping {}.",
-                    status,
-                    uuid
+                    "Unrecoverable upload failure while attempting to send ping {}. Error was {:?}",
+                    uuid,
+                    status
                 );
                 self.directory_manager.delete_file(uuid);
             }
-            _ => {
+
+            RecoverableFailure | HttpStatus(_) => {
                 log::error!(
-                    "Server returned response code {} while attempting to send ping {}.",
-                    status,
-                    uuid
+                    "Recoverable upload failure while attempting to send ping {}, will retry. Error was {:?}",
+                    uuid,
+                    status
                 );
                 if let Some(request) = self.directory_manager.process_file(uuid) {
                     let mut queue = self
@@ -236,6 +241,7 @@ mod test {
 
     use serde_json::json;
 
+    use super::UploadResult::*;
     use super::*;
     use crate::metrics::PingType;
     use crate::{tests::new_glean, PENDING_PINGS_DIRECTORY};
@@ -433,7 +439,7 @@ mod test {
             PingUploadTask::Upload(request) => {
                 // Simulate the processing of a sucessfull request
                 let uuid = request.uuid;
-                upload_manager.process_ping_upload_response(&uuid, 200);
+                upload_manager.process_ping_upload_response(&uuid, HttpStatus(200));
                 // Verify file was deleted
                 assert!(!pending_pings_dir.join(uuid).exists());
             }
@@ -473,7 +479,7 @@ mod test {
             PingUploadTask::Upload(request) => {
                 // Simulate the processing of a client error
                 let uuid = request.uuid;
-                upload_manager.process_ping_upload_response(&uuid, 404);
+                upload_manager.process_ping_upload_response(&uuid, HttpStatus(404));
                 // Verify file was deleted
                 assert!(!pending_pings_dir.join(uuid).exists());
             }
@@ -510,7 +516,7 @@ mod test {
             PingUploadTask::Upload(request) => {
                 // Simulate the processing of a client error
                 let uuid = request.uuid;
-                upload_manager.process_ping_upload_response(&uuid, 500);
+                upload_manager.process_ping_upload_response(&uuid, HttpStatus(500));
                 // Verify this ping was indeed re-enqueued
                 match upload_manager.get_upload_task() {
                     PingUploadTask::Upload(request) => {
@@ -525,4 +531,44 @@ mod test {
         // Verify that after request is returned, none are left
         assert_eq!(upload_manager.get_upload_task(), PingUploadTask::Done);
     }
+
+    #[test]
+    fn test_processes_correctly_unrecoverable_upload_response() {
+        let (mut glean, dir) = new_glean(None);
+
+        // Register a ping for testing
+        let ping_type = PingType::new("test", true, /* send_if_empty */ true, vec![]);
+        glean.register_ping_type(&ping_type);
+
+        // Submit a ping
+        glean.submit_ping(&ping_type, None).unwrap();
+
+        // Create a new upload_manager
+        let upload_manager = PingUploadManager::new(&dir.path());
+
+        // Wait for processing of pending pings directory to finish.
+        let mut upload_task = upload_manager.get_upload_task();
+        while upload_task == PingUploadTask::Wait {
+            thread::sleep(Duration::from_millis(10));
+            upload_task = upload_manager.get_upload_task();
+        }
+
+        // Get the pending ping directory path
+        let pending_pings_dir = dir.path().join(PENDING_PINGS_DIRECTORY);
+
+        // Get the submitted PingRequest
+        match upload_task {
+            PingUploadTask::Upload(request) => {
+                // Simulate the processing of a client error
+                let uuid = request.uuid;
+                upload_manager.process_ping_upload_response(&uuid, UnrecoverableFailure);
+                // Verify file was deleted
+                assert!(!pending_pings_dir.join(uuid).exists());
+            }
+            _ => panic!("Expected upload manager to return the next request!"),
+        }
+
+        // Verify that after request is returned, none are left
+        assert_eq!(upload_manager.get_upload_task(), PingUploadTask::Done);
+    }
 }

diff --git a/glean-core/src/upload/result.rs b/glean-core/src/upload/result.rs
--- a/glean-core/src/upload/result.rs
+++ b/glean-core/src/upload/result.rs
@@ -0,0 +1,66 @@
+// This Source Code Form is subject to the terms of the Mozilla Public
+// License, v. 2.0. If a copy of the MPL was not distributed with this
+// file, You can obtain one at https://mozilla.org/MPL/2.0/.
+
+/// Result values of attempted ping uploads encoded for FFI use.
+///
+/// In a perfect world this would live in `glean-ffi`,
+/// but because we also want to convert from pure integer values to a proper Rust enum
+/// using Rust's `From` and `Into` trait, we need to have it in this crate
+/// (The coherence rules don't allow to implement an external trait for an external type).
+///
+/// Due to restrictions of cbindgen they are re-defined in `glean-core/ffi/src/upload.rs`.
+///
+/// NOTE:
+/// THEY MUST BE THE SAME ACROSS BOTH FILES!
+pub mod ffi_upload_result {
+    /// A recoverable error.
+    pub const UPLOAD_RESULT_RECOVERABLE: u32 = 0x1;
+
+    /// An unrecoverable error.
+    pub const UPLOAD_RESULT_UNRECOVERABLE: u32 = 0x2;
+
+    /// A HTTP response code.
+    ///
+    /// The actual response code is encoded in the lower bits.
+    pub const UPLOAD_RESULT_HTTP_STATUS: u32 = 0x8000;
+}
+use ffi_upload_result::*;
+
+/// The result of an attempted ping upload.
+#[derive(Debug)]
+pub enum UploadResult {
+    /// A recoverable failure.
+    ///
+    /// During upload something went wrong,
+    /// e.g. the network connection failed.
+    /// The upload should be retried at a later time.
+    RecoverableFailure,
+
+    /// An unrecoverable upload failure.
+    ///
+    /// A possible cause might be a malformed URL.
+    UnrecoverableFailure,
+
+    /// A HTTP response code.
+    ///
+    /// This can still indicate an error, depending on the status code.
+    HttpStatus(u32),
+}
+
+impl From<u32> for UploadResult {
+    fn from(status: u32) -> Self {
+        match status {
+            status if (status & UPLOAD_RESULT_HTTP_STATUS) == UPLOAD_RESULT_HTTP_STATUS => {
+                // Extract the status code from the lower bits.
+                let http_status = status & !UPLOAD_RESULT_HTTP_STATUS;
+                UploadResult::HttpStatus(http_status)
+            }
+            UPLOAD_RESULT_RECOVERABLE => UploadResult::RecoverableFailure,
+            UPLOAD_RESULT_UNRECOVERABLE => UploadResult::UnrecoverableFailure,
+
+            // Any unknown result code is treated as unrecoverable.
+            _ => UploadResult::UnrecoverableFailure,
+        }
+    }
+}


</patch>

Function signatures
<Signatures>
fn glean_get_upload_task() -> FfiPingUploadTask

fn glean_process_ping_upload_response(task: FfiPingUploadTask, status: u32) -> ()
</Signatures>

You are a software tester at glean and your are reviewing the above <patch> for the above <issue>
Identify whether a unit test is needed.
If there is no test needed or you believe you need additional testing resources beyond the Rust standard library (e.g., mocking libraries) to write a useful unit test, return <NO>.
If a test is needed, your task is:
1. Write exactly one rust test `#[test]fn test_...(){...}` block. Do NOT wrap the test inside a 'mod tests' block.
If the file you are adding the test already contains a test in the <patch>, ensure that the test name is unique.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. All 'use' declarations must be inside a <imports>...</imports> block. Additionally:
   - Do not use group imports.
  - Import only what is necessary for the test to run and make sure not to have colliding imports.
  - If the <patch> contains a 'mod tests' block with useful imports, do not add them to the <imports> block.
  - Use `use super::<function name> for the function under test.
.  - If multiple 'use' statements are needed, list each on a separate line.
5. To help you write the test, <Signatures> contains all modified function's:
  - name
  - parameters
  - Return type (assume '()' if empty)
6. Return only the absolute filename as it is in the <patch> block, the use statements, and rust test (no comments or explanations).

Here is an example structure:
<Filename> ... </Filename>
<imports> ... </imports>
<Rust>
#[test]
fn test_<describe_behavior>() {
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
}</Rust>

