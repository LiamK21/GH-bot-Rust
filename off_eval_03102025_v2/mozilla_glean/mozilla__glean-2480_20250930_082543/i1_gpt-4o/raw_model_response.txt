<Filename>glean-core/src/lib_unit_tests.rs</Filename>
<imports>
use super::Glean;
use super::MetricsEnabledConfig;
use super::StringMetric;
use super::CommonMetricData;
use serde_json::json;
</imports>
<Rust>
#[test]
fn test_merge_metrics_enabled_config() {
    let (glean, _t) = new_glean(None);
    let metric = StringMetric::new(CommonMetricData {
        category: "category".to_string(),
        name: "string_metric".to_string(),
        send_in_pings: vec!["baseline".to_string()],
        ..Default::default()
    });
    let another_metric = LabeledMetric::new(CommonMetricData {
        category: "category".to_string(),
        name: "labeled_string_metric".to_string(),
        send_in_pings: vec!["baseline".to_string()],
        ..Default::default()
    });

    let initial_config = json!({
        "category.string_metric": true,
    })
    .to_string();
    glean.set_metrics_enabled_config(
        MetricsEnabledConfig::try_from(initial_config).unwrap(),
    );

    metric.set_sync(&glean, "INITIAL VALUE");
    assert_eq!(
        "INITIAL VALUE",
        metric.get_value(&glean, "baseline").unwrap(),
        "Metric should be enabled initially"
    );

    another_metric.get("label1").set_sync(&glean, "INITIAL VALUE");
    assert_eq!(
        None,
        another_metric.get("label1").get_value(&glean, "baseline"),
        "Another metric should not be enabled initially"
    );

    let additional_config = json!({
        "category.labeled_string_metric": true,
    })
    .to_string();
    glean.set_metrics_enabled_config(
        MetricsEnabledConfig::try_from(additional_config).unwrap(),
    );

    another_metric.get("label1").set_sync(&glean, "FINAL VALUE");
    assert_eq!(
        "FINAL VALUE",
        another_metric.get("label1").get_value(&glean, "baseline").unwrap(),
        "Another metric should be enabled after merging"
    );
}
</Rust>