#[test]
fn test_merge_metrics_configurations() {
    let (glean, _t) = new_glean(None);
    let metric_a = StringMetric::new(CommonMetricData {
        category: "category_a".to_string(),
        name: "string_metric".to_string(),
        send_in_pings: vec![],
        lifetime: Lifetime::Application,
        type_: Type::String,
    });
    let metric_b = StringMetric::new(CommonMetricData {
        category: "category_b".to_string(),
        name: "string_metric".to_string(),
        send_in_pings: vec![],
        lifetime: Lifetime::Application,
        type_: Type::String,
    });

    // Initially, both metrics should be disabled
    assert!(metric_a.get_value(&glean, "baseline").is_err());
    assert!(metric_b.get_value(&glean, "baseline").is_err());

    // Set first configuration enabling metric_a
    let config_a = json!({
        "category_a.string_metric": true
    }).to_string();
    glean.set_metrics_enabled_config(
        MetricsEnabledConfig::try_from(config_a).unwrap(),
    );

    // Only metric_a should be enabled
    metric_a.set_sync(&glean, "VALUE_A");
    assert_eq!(
        "VALUE_A",
        metric_a.get_value(&glean, "baseline").unwrap(),
        "Metric A should be enabled"
    );
    assert!(metric_b.get_value(&glean, "baseline").is_err(),
        "Metric B should still be disabled");

    // Set second configuration enabling metric_b
    let config_b = json!({
        "category_b.string_metric": true
    }).to_string();
    glean.set_metrics_enabled_config(
        MetricsEnabledConfig::try_from(config_b).unwrap(),
    );

    // Both metrics should now be enabled
    metric_b.set_sync(&glean, "VALUE_B");
    assert_eq!(
        "VALUE_B",
        metric_b.get_value(&glean, "baseline").unwrap(),
        "Metric B should be enabled after second config"
    );
    metric_a.set_sync(&glean, "VALUE_A_UPDATED");
    assert_eq!(
        "VALUE_A_UPDATED",
        metric_a.get_value(&glean, "baseline").unwrap(),
        "Metric A should remain enabled"
    );
}