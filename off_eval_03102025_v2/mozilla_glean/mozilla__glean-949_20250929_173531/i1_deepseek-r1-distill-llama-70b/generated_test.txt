#[test]
fn test_label_validation() {
    // Test valid labels
    assert!(matches_label_regex("a"));
    assert!(matches_label_regex("a_"));
    assert!(matches_label_regex("a1"));
    assert!(matches_label_regex("a.1"));
    assert!(matches_label_regex("a.a"));
    assert!(matches_label_regex("a_a"));
    assert!(matches_label_regex("a-a"));
    assert!(matches_label_regex("a_a.1"));

    // Test invalid labels
    assert!(!matches_label_regex("1a"));  // Starts with number
    assert!(!matches_label_regex("_a"));  // Already allowed, but wait - original regex allows starting with _
    assert!(!matches_label_regex("$a"));  // Invalid character
    assert!(!matches_label_regex("a$"));   // Invalid character
    assert!(!matches_label_regex("a/"));   // Invalid character
    assert!(!matches_label_regex("a "));  // Space is invalid
    assert!(!matches_label_regex("a\n")); // Newline is invalid

    // Test maximum length
    let max_length = "a".repeat(MAX_LABEL_LENGTH);
    assert!(!matches_label_regex(&max_length));  // Should be 61 chars, which is over the limit

    // Test labels with multiple dots
    assert!(matches_label_regex("a.b.c"));
    assert!(!matches_label_regex("a..b"));  // Empty segment between dots

    // Test edge cases
    assert!(!matches_label_regex(""));       // Empty string
    assert!(!matches_label_regex("."));     // Single dot
    assert!(!matches_label_regex("-"));     // Single hyphen
    assert!(!matches_label_regex("_"));    // Single underscore (allowed by original regex?)
}