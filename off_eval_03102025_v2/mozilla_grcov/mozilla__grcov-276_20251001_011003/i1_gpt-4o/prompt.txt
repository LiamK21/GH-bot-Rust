Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Clean up code to handle cli options
Instead of handling them manually, we could use some package (e.g. clap).
</issue>

Patch:
<patch>
diff --git a/src/main.rs b/src/main.rs
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,3 +1,5 @@
+#[macro_use]
+extern crate clap;
 extern crate crossbeam;
 extern crate grcov;
 extern crate num_cpus;
@@ -5,6 +7,7 @@ extern crate rustc_hash;
 extern crate serde_json;
 extern crate tempfile;
 
+use clap::{App, Arg};
 use crossbeam::queue::MsQueue;
 use rustc_hash::FxHashMap;
 use serde_json::Value;
@@ -12,232 +15,175 @@ use std::alloc::System;
 use std::fs::{self, File};
 use std::path::PathBuf;
 use std::sync::{Arc, Mutex};
-use std::{env, process, thread};
+use std::{process, thread};
 
 #[global_allocator]
 static GLOBAL: System = System;
 
 use grcov::*;
 
-fn print_usage(program: &str) {
-    println!("Usage: {} DIRECTORY_OR_ZIP_FILE[...] [-o OUTPUT FILENAME] [-t OUTPUT_TYPE] [-s SOURCE_ROOT] [-p PREFIX_PATH] [--token COVERALLS_REPO_TOKEN] [--commit-sha COVERALLS_COMMIT_SHA] [--ignore-not-existing] [--ignore-dir DIRECTORY] [--llvm] [--path-mapping PATH_MAPPING_FILE] [--branch] [--filter]", program);
-    println!("You can specify one or more directories, separated by a space.");
-    println!("OUTPUT_TYPE can be one of:");
-    println!(" - (DEFAULT) lcov for the lcov INFO format;");
-    println!(" - coveralls for the Coveralls specific format.");
-    println!(" - coveralls+ for the Coveralls specific format with function information.");
-    println!(" - ade for the ActiveData-ETL specific format;");
-    println!(" - files to only return a list of files.");
-    println!("SOURCE_ROOT is the root directory of the source files.");
-    println!("PREFIX_PATH is a prefix to remove from the paths (e.g. if grcov is run on a different machine than the one that generated the code coverage information).");
-    println!("COVERALLS_REPO_TOKEN is the repository token from Coveralls, required for the 'coveralls' and 'coveralls+' format.");
-    println!(
-        "COVERALLS_COMMIT_SHA is the SHA of the commit used to generate the code coverage data."
-    );
-    println!("By default source files that can't be found on the disk are not ignored. Use --ignore-not-existing to ignore them.");
-    println!("The --llvm option can be used when the code coverage information is exclusively coming from a llvm build, to speed-up parsing.");
-    println!("The --ignore-dir option can be used to ignore files/directories specified as globs.");
-    println!("The --branch option enables parsing branch coverage information.");
-    println!("The --filter option allows filtering out covered/uncovered files. Use 'covered' to only return covered files, 'uncovered' to only return uncovered files.");
-}
-
 fn main() {
-    let args: Vec<String> = env::args().collect();
-    if args.len() < 2 {
-        eprintln!("[ERROR]: Missing required directory argument.\n");
-        print_usage(&args[0]);
-        process::exit(1);
-    }
-    let mut output_type = "lcov";
-    let mut source_dir = "";
-    let mut prefix_dir = "";
-    let mut repo_token = "";
-    let mut commit_sha = "";
-    let mut service_name = "";
-    let mut service_number = "";
-    let mut service_job_number = "";
-    let mut ignore_not_existing = false;
-    let mut to_ignore_dirs = Vec::new();
-    let mut is_llvm = false;
-    let mut branch_enabled = false;
-    let mut paths = Vec::new();
-    let mut i = 1;
-    let mut path_mapping_file = "";
-    let mut filter_option = None;
-    let mut num_threads = num_cpus::get() * 2;
-    let mut output_file_path = None;
-
-    while i < args.len() {
-        if args[i] == "-t" {
-            if args.len() <= i + 1 {
-                eprintln!("[ERROR]: Output format not specified.\n");
-                print_usage(&args[0]);
-                process::exit(1);
-            }
-
-            output_type = &args[i + 1];
-            i += 1;
-        } else if args[i] == "-s" {
-            if args.len() <= i + 1 {
-                eprintln!("[ERROR]: Source root directory not specified.\n");
-                print_usage(&args[0]);
-                process::exit(1);
-            }
-
-            source_dir = &args[i + 1];
-            i += 1;
-        } else if args[i] == "-p" {
-            if args.len() <= i + 1 {
-                eprintln!("[ERROR]: Prefix path not specified.\n");
-                print_usage(&args[0]);
-                process::exit(1);
-            }
-
-            prefix_dir = &args[i + 1];
-            i += 1;
-        } else if args[i] == "--token" {
-            if args.len() <= i + 1 {
-                eprintln!("[ERROR]: Repository token not specified.\n");
-                print_usage(&args[0]);
-                process::exit(1);
-            }
-
-            repo_token = &args[i + 1];
-            i += 1;
-        } else if args[i] == "--service-name" {
-            if args.len() <= i + 1 {
-                eprintln!("[ERROR]: Service name not specified.\n");
-                print_usage(&args[0]);
-                process::exit(1);
-            }
-
-            service_name = &args[i + 1];
-            i += 1;
-        } else if args[i] == "--service-number" {
-            if args.len() <= i + 1 {
-                eprintln!("[ERROR]: Service number not specified.\n");
-                print_usage(&args[0]);
-                process::exit(1);
-            }
-
-            service_number = &args[i + 1];
-            i += 1;
-        } else if args[i] == "--service-job-number" {
-            if args.len() <= i + 1 {
-                eprintln!("[ERROR]: Service job number not specified.\n");
-                print_usage(&args[0]);
-                process::exit(1);
-            }
-
-            service_job_number = &args[i + 1];
-            i += 1;
-        } else if args[i] == "--commit-sha" {
-            if args.len() <= i + 1 {
-                eprintln!("[ERROR]: Commit SHA not specified.\n");
-                print_usage(&args[0]);
-                process::exit(1);
-            }
-
-            commit_sha = &args[i + 1];
-            i += 1;
-        } else if args[i] == "--ignore-not-existing" {
-            ignore_not_existing = true;
-        } else if args[i] == "--ignore-dir" {
-            if args.len() <= i + 1 {
-                eprintln!("[ERROR]: Directory to ignore not specified.\n");
-                print_usage(&args[0]);
-                process::exit(1);
-            }
-
-            to_ignore_dirs.push(args[i + 1].clone());
-            i += 1;
-        } else if args[i] == "--llvm" {
-            is_llvm = true;
-        } else if args[i] == "--path-mapping" {
-            if args.len() <= i + 1 {
-                eprintln!("[ERROR]: Path mapping file not specified.\n");
-                print_usage(&args[0]);
-                process::exit(1);
-            }
-
-            path_mapping_file = &args[i + 1];
-            i += 1;
-        } else if args[i] == "--branch" {
-            branch_enabled = true;
-        } else if args[i] == "--filter" {
-            if args.len() <= i + 1 {
-                eprintln!("[ERROR]: Filter option not specified.\n");
-                print_usage(&args[0]);
-                process::exit(1);
-            }
-
-            if args[i + 1] == "covered" {
-                filter_option = Some(true);
-            } else if args[i + 1] == "uncovered" {
-                filter_option = Some(false);
-            } else {
-                eprintln!(
-                    "[ERROR]: Filter option invalid (should be either 'covered' or 'uncovered')\n"
-                );
-                print_usage(&args[0]);
-                process::exit(1);
-            }
-            i += 1;
-        } else if args[i] == "--threads" {
-            if args.len() <= i + 1 {
-                eprintln!("[ERROR]: Number of threads not specified.\n");
-                print_usage(&args[0]);
-                process::exit(1);
-            }
-
-            num_threads = args[i + 1]
-                .parse()
-                .expect("Number of threads should be a number");
-            i += 1;
-        } else if args[i] == "-o" {
-            if args.len() <= i + 1 {
-                eprintln!("[ERROR]: Output file not specified.\n");
-                print_usage(&args[0]);
-                process::exit(1);
-            }
-            output_file_path = Some(&args[i + 1]);
-            i += 1;
+    let default_num_threads = (num_cpus::get() * 2).to_string();
+
+    let matches = App::new("grcov")
+                          .author(crate_authors!("\n"))
+                          .about("Parse, collect and aggregate code coverage data for multiple source files")
+
+                          .arg(Arg::with_name("paths")
+                               .help("Sets the input paths to use")
+                               .required(true)
+                               .multiple(true)
+                               .takes_value(true))
+
+                          .arg(Arg::with_name("output_type")
+                               .help("Sets a custom output type")
+                               .long_help(
+"Sets a custom output type:
+- *lcov* for the lcov INFO format;
+- *coveralls* for the Coveralls specific format;
+- *coveralls+* for the Coveralls specific format with function information;
+- *ade* for the ActiveData-ETL specific format;
+- *files* to only return a list of files.
+")
+                               .short("t")
+                               .long("output-type")
+                               .value_name("OUTPUT TYPE")
+                               .default_value("lcov")
+                               .possible_values(&["ade", "lcov", "coveralls", "coveralls+", "files"])
+                               .takes_value(true))
+
+                          .arg(Arg::with_name("output_file")
+                               .help("Specifies the output file")
+                               .short("o")
+                               .long("output-file")
+                               .value_name("FILE")
+                               .takes_value(true))
+
+                          .arg(Arg::with_name("source_dir")
+                               .help("Specifies the root directory of the source files")
+                               .short("s")
+                               .long("source-dir")
+                               .value_name("DIRECTORY")
+                               .takes_value(true))
+
+                          .arg(Arg::with_name("prefix_dir")
+                               .help("Specifies a prefix to remove from the paths (e.g. if grcov is run on a different machine than the one that generated the code coverage information)")
+                               .short("p")
+                               .long("prefix-dir")
+                               .value_name("PATH")
+                               .takes_value(true))
+
+                          .arg(Arg::with_name("ignore_not_existing")
+                               .help("Ignore source files that can't be found on the disk")
+                               .long("ignore-not-existing"))
+
+                          .arg(Arg::with_name("ignore_dir")
+                               .help("Ignore files/directories specified as globs")
+                               .long("ignore-dir")
+                               .value_name("PATH")
+                               .multiple(true)
+                               .takes_value(true))
+
+                          .arg(Arg::with_name("path_mapping")
+                               .long("path-mapping")
+                               .value_name("PATH")
+                               .multiple(true)
+                               .takes_value(true))
+
+                          .arg(Arg::with_name("branch")
+                               .help("Enables parsing branch coverage information")
+                               .long("branch"))
+
+                          .arg(Arg::with_name("filter")
+                               .help("Filters out covered/uncovered files. Use 'covered' to only return covered files, 'uncovered' to only return uncovered files")
+                               .long("filter")
+                               .possible_values(&["covered", "uncovered"])
+                               .takes_value(true))
+
+                          .arg(Arg::with_name("llvm")
+                               .help("Speeds-up parsing, when the code coverage information is exclusively coming from a llvm build")
+                               .long("llvm"))
+
+                          .arg(Arg::with_name("token")
+                               .help("Sets the repository token from Coveralls, required for the 'coveralls' and 'coveralls+' formats")
+                               .long("token")
+                               .value_name("TOKEN")
+                               .takes_value(true)
+                               .required_ifs(&[
+                                   ("output_type", "coveralls"),
+                                   ("output_type", "coveralls+")
+                               ]))
+
+                          .arg(Arg::with_name("commit_sha")
+                               .help("Sets the hash of the commit used to generate the code coverage data")
+                               .long("commit-sha")
+                               .value_name("COMMIT HASH")
+                               .takes_value(true)
+                               .required_ifs(&[
+                                   ("output_type", "coveralls"),
+                                   ("output_type", "coveralls+")
+                               ]))
+
+                          .arg(Arg::with_name("service_name")
+                               .help("Sets the service name")
+                               .long("service-name")
+                               .value_name("SERVICE NAME")
+                               .takes_value(true))
+
+                          .arg(Arg::with_name("service_number")
+                               .help("Sets the service number")
+                               .long("service-number")
+                               .value_name("SERVICE NUMBER")
+                               .takes_value(true))
+
+                          .arg(Arg::with_name("service_job_number")
+                               .help("Sets the service job number")
+                               .long("service-job-number")
+                               .value_name("SERVICE JOB NUMBER")
+                               .takes_value(true))
+
+                          .arg(Arg::with_name("threads")
+                               .long("threads")
+                               .value_name("NUMBER")
+                               .default_value(&default_num_threads)
+                               .takes_value(true))
+
+                          .get_matches();
+
+    let paths: Vec<_> = matches.values_of("paths").unwrap().collect();
+    let paths: Vec<String> = paths.iter().map(|s| s.to_string()).collect();
+    let output_type = matches.value_of("output_type").unwrap();
+    let output_file_path = matches.value_of("output_file");
+    let source_dir = matches.value_of("source_dir").unwrap_or("");
+    let prefix_dir = matches.value_of("prefix_dir").unwrap_or("");
+    let ignore_not_existing = matches.is_present("ignore_not_existing");
+    let mut to_ignore_dirs: Vec<_> = if let Some(to_ignore_dirs) = matches.values_of("ignore_dir") {
+        to_ignore_dirs.collect()
+    } else {
+        Vec::new()
+    };
+    let path_mapping_file = matches.value_of("path_mapping").unwrap_or("");
+    let branch_enabled = matches.is_present("branch");
+    let filter_option = if let Some(filter) = matches.value_of("filter") {
+        if filter == "covered" {
+            Some(true)
         } else {
-            paths.push(args[i].clone());
-        }
-
-        i += 1;
-    }
-
-    if output_type != "ade"
-        && output_type != "lcov"
-        && output_type != "coveralls"
-        && output_type != "coveralls+"
-        && output_type != "files"
-    {
-        eprintln!(
-            "[ERROR]: '{}' output format is not supported.\n",
-            output_type
-        );
-        print_usage(&args[0]);
-        process::exit(1);
-    }
-
-    if output_type == "coveralls" || output_type == "coveralls+" {
-        if repo_token == "" {
-            eprintln!(
-                "[ERROR]: Repository token is needed when the output format is 'coveralls'.\n"
-            );
-            print_usage(&args[0]);
-            process::exit(1);
-        }
-
-        if commit_sha == "" {
-            eprintln!("[ERROR]: Commit SHA is needed when the output format is 'coveralls'.\n");
-            print_usage(&args[0]);
-            process::exit(1);
+            Some(false)
         }
-    }
+    } else {
+        None
+    };
+    let is_llvm = matches.is_present("llvm");
+    let repo_token = matches.value_of("token").unwrap_or("");
+    let commit_sha = matches.value_of("commit_sha").unwrap_or("");
+    let service_name = matches.value_of("service_name").unwrap_or("");
+    let service_number = matches.value_of("service_number").unwrap_or("");
+    let service_job_number = matches.value_of("service_job_number").unwrap_or("");
+    let num_threads: usize = matches
+        .value_of("threads")
+        .unwrap()
+        .parse()
+        .expect("Number of threads should be a number");
 
     let source_root = if source_dir != "" {
         Some(canonicalize_path(&source_dir).expect("Source directory does not exist."))
@@ -341,7 +287,7 @@ fn main() {
         source_root,
         prefix_dir,
         ignore_not_existing,
-        to_ignore_dirs,
+        &mut to_ignore_dirs,
         filter_option,
     );

diff --git a/src/output.rs b/src/output.rs
--- a/src/output.rs
+++ b/src/output.rs
@@ -8,7 +8,7 @@ use md5::{Md5, Digest};
 
 use crate::defs::*;
 
-fn get_target_output_writable(output_file: Option<&String>) -> Box<Write> {
+fn get_target_output_writable(output_file: Option<&str>) -> Box<Write> {
     let write_target: Box<Write> = match output_file {
         Some(filename) => Box::new(File::create(filename).unwrap()),
         None => {
@@ -19,7 +19,7 @@ fn get_target_output_writable(output_file: Option<&String>) -> Box<Write> {
     return write_target;
 }
 
-pub fn output_activedata_etl(results: CovResultIter, output_file: Option<&String>) {
+pub fn output_activedata_etl(results: CovResultIter, output_file: Option<&str>) {
     let mut writer = BufWriter::new(get_target_output_writable(output_file));
 
     for (_, rel_path, result) in results {
@@ -129,7 +129,7 @@ pub fn output_activedata_etl(results: CovResultIter, output_file: Option<&String
     }
 }
 
-pub fn output_lcov(results: CovResultIter, output_file: Option<&String>) {
+pub fn output_lcov(results: CovResultIter, output_file: Option<&str>) {
     let mut writer = BufWriter::new(get_target_output_writable(output_file));
     writer.write_all(b"TN:\n").unwrap();
 
@@ -216,7 +216,7 @@ pub fn output_coveralls(
     service_job_number: &str,
     commit_sha: &str,
     with_function_info: bool,
-    output_file: Option<&String>,
+    output_file: Option<&str>,
 ) {
     let mut source_files = Vec::new();
 
@@ -290,7 +290,7 @@ pub fn output_coveralls(
     .unwrap();
 }
 
-pub fn output_files(results: CovResultIter, output_file: Option<&String>) {
+pub fn output_files(results: CovResultIter, output_file: Option<&str>) {
     let mut writer = BufWriter::new(get_target_output_writable(output_file));
     for (_, rel_path, _) in results {
         writeln!(writer, "{}", rel_path.display()).unwrap();

diff --git a/src/path_rewriting.rs b/src/path_rewriting.rs
--- a/src/path_rewriting.rs
+++ b/src/path_rewriting.rs
@@ -188,7 +188,7 @@ pub fn rewrite_paths(
     source_dir: Option<PathBuf>,
     prefix_dir: Option<PathBuf>,
     ignore_not_existing: bool,
-    to_ignore_dirs: Vec<String>,
+    to_ignore_dirs: &mut [&str],
     filter_option: Option<bool>,
 ) -> CovResultIter {
     let mut glob_builder = GlobSetBuilder::new();
@@ -345,7 +345,7 @@ mod tests {
     fn test_rewrite_paths_basic() {
         let mut result_map: CovResultMap = FxHashMap::default();
         result_map.insert("main.cpp".to_string(), empty_result!());
-        let results = rewrite_paths(result_map, None, None, None, false, Vec::new(), None);
+        let results = rewrite_paths(result_map, None, None, None, false, &mut Vec::new(), None);
         let mut count = 0;
         for (abs_path, rel_path, result) in results {
             count += 1;
@@ -370,7 +370,7 @@ mod tests {
             None,
             Some(PathBuf::from("/home/worker/src/workspace/")),
             false,
-            Vec::new(),
+            &mut Vec::new(),
             None,
         );
         let mut count = 0;
@@ -397,7 +397,7 @@ mod tests {
             None,
             Some(PathBuf::from("C:\\Users\\worker\\src\\workspace\\")),
             false,
-            Vec::new(),
+            &mut Vec::new(),
             None,
         );
         let mut count = 0;
@@ -424,7 +424,7 @@ mod tests {
             None,
             Some(PathBuf::from("C:/Users/worker/src/workspace/")),
             false,
-            Vec::new(),
+            &mut Vec::new(),
             None,
         );
         let mut count = 0;
@@ -451,7 +451,7 @@ mod tests {
             None,
             Some(PathBuf::from("C:/Users/worker/src/")),
             false,
-            Vec::new(),
+            &mut Vec::new(),
             None,
         );
         let mut count = 0;
@@ -470,7 +470,7 @@ mod tests {
         let mut result_map: CovResultMap = FxHashMap::default();
         result_map.insert("tests/class/main.cpp".to_string(), empty_result!());
         result_map.insert("tests/class/doesntexist.cpp".to_string(), empty_result!());
-        let results = rewrite_paths(result_map, None, None, None, true, Vec::new(), None);
+        let results = rewrite_paths(result_map, None, None, None, true, &mut Vec::new(), None);
         let mut count = 0;
         for (abs_path, rel_path, result) in results {
             count += 1;
@@ -492,7 +492,7 @@ mod tests {
         let mut result_map: CovResultMap = FxHashMap::default();
         result_map.insert("tests\\class\\main.cpp".to_string(), empty_result!());
         result_map.insert("tests\\class\\doesntexist.cpp".to_string(), empty_result!());
-        let results = rewrite_paths(result_map, None, None, None, true, Vec::new(), None);
+        let results = rewrite_paths(result_map, None, None, None, true, &mut Vec::new(), None);
         let mut count = 0;
         for (abs_path, rel_path, result) in results {
             count += 1;
@@ -516,7 +516,7 @@ mod tests {
             None,
             None,
             false,
-            vec!["mydir/*".to_string()],
+            &mut vec!["mydir/*"],
             None,
         );
         let mut count = 0;
@@ -541,7 +541,7 @@ mod tests {
             None,
             None,
             false,
-            vec!["mydir/*".to_string()],
+            &mut vec!["mydir/*"],
             None,
         );
         let mut count = 0;
@@ -557,7 +557,7 @@ mod tests {
     #[cfg(unix)]
     #[test]
     fn test_rewrite_paths_ignore_multiple_directories() {
-        let mut ignore_dirs = vec!["mydir/*".to_string(), "mydir2/*".to_string()];
+        let mut ignore_dirs = vec!["mydir/*", "mydir2/*"];
         for _ in 0..2 {
             // we run the test twice, one with ignore_dirs and the other with ignore_dirs.reverse()
             let mut result_map: CovResultMap = FxHashMap::default();
@@ -570,7 +570,7 @@ mod tests {
                 None,
                 None,
                 false,
-                ignore_dirs.clone(),
+                &mut ignore_dirs.clone(),
                 None,
             );
             let mut count = 0;
@@ -588,7 +588,7 @@ mod tests {
     #[cfg(windows)]
     #[test]
     fn test_rewrite_paths_ignore_multiple_directories() {
-        let mut ignore_dirs = vec!["mydir/*".to_string(), "mydir2/*".to_string()];
+        let mut ignore_dirs = vec!["mydir/*", "mydir2/*"];
         for _ in 0..2 {
             // we run the test twice, one with ignore_dirs and the other with ignore_dirs.reverse()
             let mut result_map: CovResultMap = FxHashMap::default();
@@ -601,7 +601,7 @@ mod tests {
                 None,
                 None,
                 false,
-                ignore_dirs.clone(),
+                &mut ignore_dirs.clone(),
                 None,
             );
             let mut count = 0;
@@ -626,7 +626,7 @@ mod tests {
             Some(PathBuf::from("tests")),
             None,
             true,
-            Vec::new(),
+            &mut Vec::new(),
             None,
         );
     }
@@ -643,7 +643,7 @@ mod tests {
             Some(canonicalize_path("test").unwrap()),
             None,
             true,
-            Vec::new(),
+            &mut Vec::new(),
             None,
         );
         let mut count = 0;
@@ -669,7 +669,7 @@ mod tests {
             Some(canonicalize_path("test").unwrap()),
             None,
             true,
-            Vec::new(),
+            &mut Vec::new(),
             None,
         );
         let mut count = 0;
@@ -695,7 +695,7 @@ mod tests {
             Some(canonicalize_path(".").unwrap()),
             None,
             true,
-            Vec::new(),
+            &mut Vec::new(),
             None,
         );
         let mut results: Vec<(PathBuf, PathBuf, CovResult)> = results.collect();
@@ -720,7 +720,7 @@ mod tests {
             Some(canonicalize_path(".").unwrap()),
             None,
             true,
-            Vec::new(),
+            &mut Vec::new(),
             None,
         );
         let mut results: Vec<(PathBuf, PathBuf, CovResult)> = results.collect();
@@ -744,7 +744,7 @@ mod tests {
             Some(canonicalize_path(".").unwrap()),
             None,
             true,
-            Vec::new(),
+            &mut Vec::new(),
             None,
         );
         let mut count = 0;
@@ -769,7 +769,7 @@ mod tests {
             Some(canonicalize_path(".").unwrap()),
             None,
             true,
-            Vec::new(),
+            &mut Vec::new(),
             None,
         );
         let mut count = 0;
@@ -797,7 +797,7 @@ mod tests {
             Some(canonicalize_path("tests").unwrap()),
             Some(PathBuf::from("/home/worker/src/workspace")),
             true,
-            Vec::new(),
+            &mut Vec::new(),
             None,
         );
         let mut count = 0;
@@ -826,7 +826,7 @@ mod tests {
             Some(canonicalize_path("tests").unwrap()),
             Some(PathBuf::from("C:\\Users\\worker\\src\\workspace")),
             true,
-            Vec::new(),
+            &mut Vec::new(),
             None,
         );
         let mut count = 0;
@@ -851,7 +851,7 @@ mod tests {
             None,
             None,
             false,
-            Vec::new(),
+            &mut Vec::new(),
             None,
         );
         let mut count = 0;
@@ -875,7 +875,7 @@ mod tests {
             None,
             None,
             false,
-            Vec::new(),
+            &mut Vec::new(),
             None,
         );
         let mut count = 0;
@@ -902,7 +902,7 @@ mod tests {
             None,
             None,
             true,
-            Vec::new(),
+            &mut Vec::new(),
             None,
         );
         let mut count = 0;
@@ -930,7 +930,7 @@ mod tests {
             None,
             None,
             true,
-            Vec::new(),
+            &mut Vec::new(),
             None,
         );
         let mut count = 0;
@@ -958,7 +958,7 @@ mod tests {
             None,
             Some(PathBuf::from("/home/worker/src/workspace")),
             true,
-            Vec::new(),
+            &mut Vec::new(),
             None,
         );
         let mut count = 0;
@@ -989,7 +989,7 @@ mod tests {
             None,
             Some(PathBuf::from("C:\\Users\\worker\\src\\workspace")),
             true,
-            Vec::new(),
+            &mut Vec::new(),
             None,
         );
         let mut count = 0;
@@ -1016,7 +1016,7 @@ mod tests {
             None,
             Some(PathBuf::from("C:\\Users\\worker\\src\\workspace")),
             true,
-            Vec::new(),
+            &mut Vec::new(),
             None,
         );
         let mut count = 0;
@@ -1043,7 +1043,7 @@ mod tests {
             None,
             Some(PathBuf::from("c:\\Users\\worker\\src\\workspace")),
             true,
-            Vec::new(),
+            &mut Vec::new(),
             None,
         );
         let mut count = 0;
@@ -1070,7 +1070,7 @@ mod tests {
             None,
             Some(PathBuf::from("c:\\Users\\worker\\src\\workspace")),
             true,
-            Vec::new(),
+            &mut Vec::new(),
             None,
         );
         let mut count = 0;
@@ -1098,7 +1098,7 @@ mod tests {
             Some(canonicalize_path("tests").unwrap()),
             Some(PathBuf::from("/home/worker/src/workspace")),
             true,
-            Vec::new(),
+            &mut Vec::new(),
             None,
         );
         let mut count = 0;
@@ -1126,7 +1126,7 @@ mod tests {
             Some(canonicalize_path("tests").unwrap()),
             Some(PathBuf::from("C:\\Users\\worker\\src\\workspace")),
             true,
-            Vec::new(),
+            &mut Vec::new(),
             None,
         );
         let mut count = 0;
@@ -1145,7 +1145,15 @@ mod tests {
         let mut result_map: CovResultMap = FxHashMap::default();
         result_map.insert("covered.cpp".to_string(), covered_result!());
         result_map.insert("uncovered.cpp".to_string(), uncovered_result!());
-        let results = rewrite_paths(result_map, None, None, None, false, Vec::new(), Some(true));
+        let results = rewrite_paths(
+            result_map,
+            None,
+            None,
+            None,
+            false,
+            &mut Vec::new(),
+            Some(true),
+        );
         let mut count = 0;
         for (abs_path, rel_path, result) in results {
             count += 1;
@@ -1161,7 +1169,15 @@ mod tests {
         let mut result_map: CovResultMap = FxHashMap::default();
         result_map.insert("covered.cpp".to_string(), covered_result!());
         result_map.insert("uncovered.cpp".to_string(), uncovered_result!());
-        let results = rewrite_paths(result_map, None, None, None, false, Vec::new(), Some(false));
+        let results = rewrite_paths(
+            result_map,
+            None,
+            None,
+            None,
+            false,
+            &mut Vec::new(),
+            Some(false),
+        );
         let mut count = 0;
         for (abs_path, rel_path, result) in results {
             count += 1;


</patch>

Function signatures
<Signatures>
fn main() -> ()

pub fn output_activedata_etl(results: CovResultIter, output_file: Option<&str>) -> ()

pub fn output_coveralls(
results: CovResultIter,
repo_token: &str,
service_name: &str,
service_number: &str,
service_job_number: &str,
commit_sha: &str,
with_function_info: bool,
output_file: Option<&str>) -> ()

fn get_target_output_writable(output_file: Option<&str>) -> Box<Write>

pub fn rewrite_paths(
result_map: CovResultMap,
path_mapping: Option<Value>,
source_dir: Option<PathBuf>,
prefix_dir: Option<PathBuf>,
ignore_not_existing: bool,
to_ignore_dirs: &mut [&str],
filter_option: Option<bool>) -> CovResultIter
</Signatures>

You are a software tester at grcov and your are reviewing the above <patch> for the above <issue>
Identify whether a unit test is needed.
If there is no test needed or you believe you need additional testing resources beyond the Rust standard library (e.g., mocking libraries) to write a useful unit test, return <NO>.
If a test is needed, your task is:
1. Write exactly one rust test `#[test]fn test_...(){...}` block. Do NOT wrap the test inside a 'mod tests' block.
If the file you are adding the test already contains a test in the <patch>, ensure that the test name is unique.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. All 'use' declarations must be inside a <imports>...</imports> block. Additionally:
   - Do not use group imports.
  - Import only what is necessary for the test to run and make sure not to have colliding imports.
  - If the <patch> contains a 'mod tests' block with useful imports, do not add them to the <imports> block.
  - Use `use super::<function name> for the function under test.
.  - If multiple 'use' statements are needed, list each on a separate line.
5. To help you write the test, <Signatures> contains all modified function's:
  - name
  - parameters
  - Return type (assume '()' if empty)
6. Return only the absolute filename as it is in the <patch> block, the use statements, and rust test (no comments or explanations).

Here is an example structure:
<Filename> ... </Filename>
<imports> ... </imports>
<Rust>
#[test]
fn test_<describe_behavior>() {
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
}</Rust>

