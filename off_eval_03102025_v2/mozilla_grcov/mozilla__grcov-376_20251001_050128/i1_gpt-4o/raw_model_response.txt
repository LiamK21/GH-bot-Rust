<Filename>
src/output.rs
</Filename>
<imports>
use super::output_coveralls;
use std::path::PathBuf;
use serde_json::Value;
use crate::utils::read_file;
use crate::CovResult;
use crate::CovResultIter;
use std::collections::BTreeMap;
use rustc_hash::FxHashMap;
use tempfile;
</imports>
<Rust>
#[test]
fn test_coveralls_service_job_id_unique() {
    let tmp_dir = tempfile::tempdir().expect("Failed to create temporary directory");
    let file_name = "test_coveralls_service_job_id_unique.json";
    let file_path = tmp_dir.path().join(&file_name);

    let results = vec![(
        PathBuf::from("foo/bar/a.cpp"),
        PathBuf::from("foo/bar/a.cpp"),
        CovResult {
            lines: [(1, 10), (2, 11)].iter().cloned().collect(),
            branches: BTreeMap::new(),
            functions: FxHashMap::default(),
        },
    )];

    let results = Box::new(results.into_iter());
    let expected_service_job_id: &str = "unique_id_123";
    let with_function_info: bool = true;
    let parallel: bool = true;
    output_coveralls(
        results,
        "unused",
        "unused",
        "unused",
        expected_service_job_id,
        "unused",
        "unused",
        with_function_info,
        Some(file_path.to_str().unwrap()),
        "unused",
        parallel,
    );

    let results: Value = serde_json::from_str(&read_file(&file_path)).unwrap();

    assert_eq!(results["service_job_id"], expected_service_job_id);
}
</Rust>