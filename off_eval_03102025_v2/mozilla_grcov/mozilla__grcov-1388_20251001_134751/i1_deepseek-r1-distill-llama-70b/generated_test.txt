#[test]
fn test_known_binary_detection() {
    // Test cases: (bytes, expected_result)
    let test_cases = [
        // ELF (Linux)
        ([0x7F, 0x45, 0x4C, 0x46].as_slice(), true),
        // PE (Windows)
        ([0x4D, 0x5A].as_slice(), true),
        // Mach-O (macOS)
        ([0xFE, 0xED, 0xFA, 0xCE].as_slice(), true),
        // COFF
        ([0x014C].as_slice(), true),
        // WebAssembly
        ([0x00, 0x61, 0x73, 0x6D].as_slice(), true),
        // LLVM Bitcode
        ([0x42, 0x43, 0xC0, 0xDE].as_slice(), true),
        // Non-binary (text file)
        ([0x74, 0x65, 0x73, 0x74].as_slice(), false),
    ];

    for (bytes, expected) in &test_cases {
        let mut cursor = Cursor::new(bytes);
        let mut read_bytes = [0u8; 128];
        let read = cursor.read(&mut read_bytes).unwrap();
        let actual = is_known_binary(&read_bytes[..read]);
        assert_eq!(actual, *expected, 
            "is_known_binary failed for bytes: {:x?} (expected: {})",
            bytes, *expected);
    }
}