Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Enable clippy::pedantic
There are a bunch of problems that might be revealed by clippy::pedantic.  While false positives are a risk, we can suppress individual warnings as they are analyzed.
</issue>

Patch:
<patch>
diff --git a/neqo-common/src/codec.rs b/neqo-common/src/codec.rs
--- a/neqo-common/src/codec.rs
+++ b/neqo-common/src/codec.rs
@@ -83,14 +83,13 @@ impl<'a> Decoder<'a> {
     }
 
     fn decode_checked(&mut self, n: u64) -> Option<&[u8]> {
-        match TryFrom::try_from(n) {
-            Ok(len) => self.decode(len),
-            _ => {
-                // sizeof(usize) < sizeof(u64) and the value is greater than usize can hold.
-                // Throw away the rest of the input.
-                self.offset = self.buf.len();
-                None
-            }
+        if let Ok(len) = TryFrom::try_from(n) {
+            self.decode(len)
+        } else {
+            // sizeof(usize) < sizeof(u64) and the value is greater than usize can hold.
+            // Throw away the rest of the input.
+            self.offset = self.buf.len();
+            None
         }
     }
 
@@ -100,7 +99,7 @@ impl<'a> Decoder<'a> {
         if self.remaining() < n {
             return None;
         }
-        let mut v = 0u64;
+        let mut v = 0_u64;
         for i in 0..n {
             let b = self.buf[self.offset + i];
             v = v << 8 | u64::from(b);
@@ -194,13 +193,13 @@ impl Encoder {
     }
 
     /// Default construction of an empty buffer.
-    pub fn new() -> Encoder {
-        Encoder::default()
+    pub fn new() -> Self {
+        Self::default()
     }
 
     /// Construction of a buffer with a predetermined capacity.
-    pub fn with_capacity(capacity: usize) -> Encoder {
-        Encoder {
+    pub fn with_capacity(capacity: usize) -> Self {
+        Self {
             buf: Vec::with_capacity(capacity),
         }
     }
@@ -212,13 +211,13 @@ impl Encoder {
     }
 
     /// Don't use this except in testing.
-    pub fn from_hex(s: &str) -> Encoder {
+    pub fn from_hex(s: &str) -> Self {
         if s.len() % 2 != 0 {
             panic!("Needs to be even length");
         }
 
         let cap = s.len() / 2;
-        let mut enc = Encoder::with_capacity(cap);
+        let mut enc = Self::with_capacity(cap);
 
         for i in 0..cap {
             let v = u8::from_str_radix(&s[i * 2..i * 2 + 2], 16).unwrap();
@@ -240,6 +239,7 @@ impl Encoder {
     }
 
     /// Encode an integer of any size up to u64.
+    #[allow(clippy::cast_possible_truncation)]
     pub fn encode_uint<T: Into<u64>>(&mut self, n: usize, v: T) -> &mut Self {
         let v = v.into();
         assert!(n > 0 && n <= 8);
@@ -269,6 +269,7 @@ impl Encoder {
     }
 
     /// Encode a vector in TLS style using a closure for the contents.
+    #[allow(clippy::cast_possible_truncation)]
     pub fn encode_vec_with<F: FnOnce(&mut Self)>(&mut self, n: usize, f: F) -> &mut Self {
         let start = self.buf.len();
         self.buf.resize(self.buf.len() + n, 0);
@@ -309,14 +310,14 @@ impl Debug for Encoder {
 }
 
 impl<'a> From<Decoder<'a>> for Encoder {
-    fn from(dec: Decoder<'a>) -> Encoder {
-        Encoder::from(&dec.buf[dec.offset..])
+    fn from(dec: Decoder<'a>) -> Self {
+        Self::from(&dec.buf[dec.offset..])
     }
 }
 
 impl From<&[u8]> for Encoder {
-    fn from(buf: &[u8]) -> Encoder {
-        Encoder {
+    fn from(buf: &[u8]) -> Self {
+        Self {
             buf: Vec::from(buf),
         }
     }
@@ -516,10 +517,10 @@ mod tests {
     #[test]
     fn encode_uint() {
         let mut enc = Encoder::default();
-        enc.encode_uint(2, 10u8); // 000a
-        enc.encode_uint(1, 257u16); // 01
-        enc.encode_uint(3, 0xff_ffffu32); // ffffff
-        enc.encode_uint(8, 0xfedc_ba98_7654_3210u64);
+        enc.encode_uint(2, 10_u8); // 000a
+        enc.encode_uint(1, 257_u16); // 01
+        enc.encode_uint(3, 0xff_ffff_u32); // ffffff
+        enc.encode_uint(8, 0xfedc_ba98_7654_3210_u64);
         assert_eq!(enc, Encoder::from_hex("000a01fffffffedcba9876543210"));
     }

diff --git a/neqo-common/src/datagram.rs b/neqo-common/src/datagram.rs
--- a/neqo-common/src/datagram.rs
+++ b/neqo-common/src/datagram.rs
@@ -15,8 +15,8 @@ pub struct Datagram {
 }
 
 impl Datagram {
-    pub fn new<V: Into<Vec<u8>>>(src: SocketAddr, dst: SocketAddr, d: V) -> Datagram {
-        Datagram {
+    pub fn new<V: Into<Vec<u8>>>(src: SocketAddr, dst: SocketAddr, d: V) -> Self {
+        Self {
             src,
             dst,
             d: d.into(),

diff --git a/neqo-common/src/incrdecoder.rs b/neqo-common/src/incrdecoder.rs
--- a/neqo-common/src/incrdecoder.rs
+++ b/neqo-common/src/incrdecoder.rs
@@ -4,11 +4,12 @@
 // option. This file may not be copied, modified, or distributed
 // except according to those terms.
 
+use std::convert::TryFrom;
 use std::mem;
 
 use crate::codec::Decoder;
 
-/// IncrementalDecoder incrementally processes input from incomplete input.
+/// `IncrementalDecoder` incrementally processes input from incomplete input.
 /// Use this to process data that might be incomplete when it arrives.
 ///
 /// ```
@@ -32,7 +33,7 @@ pub enum IncrementalDecoder {
     Ignoring { remaining: usize },
 }
 
-/// IncrementalDecoderResult is the result of decoding a partial input.
+/// `IncrementalDecoderResult` is the result of decoding a partial input.
 /// You only get an error if the decoder completed its last instruction.
 #[derive(Debug, PartialEq)]
 pub enum IncrementalDecoderResult {
@@ -45,7 +46,7 @@ pub enum IncrementalDecoderResult {
 
 impl IncrementalDecoder {
     /// Decode a buffer of fixed size.
-    pub fn decode(n: usize) -> IncrementalDecoder {
+    pub fn decode(n: usize) -> Self {
         IncrementalDecoder::InBuffer {
             v: Vec::new(),
             remaining: n,
@@ -53,27 +54,27 @@ impl IncrementalDecoder {
     }
 
     /// Decode an unsigned integer of fixed size.
-    pub fn decode_uint(n: usize) -> IncrementalDecoder {
+    pub fn decode_uint(n: usize) -> Self {
         IncrementalDecoder::InUint { v: 0, remaining: n }
     }
 
     /// Decode a QUIC variable-length integer.
-    pub fn decode_varint() -> IncrementalDecoder {
+    pub fn decode_varint() -> Self {
         IncrementalDecoder::BeforeVarint
     }
 
     /// Decode a vector that as a fixed-sized length prefix.
-    pub fn decode_vec(n: usize) -> IncrementalDecoder {
-        IncrementalDecoder::InBufferLen(Box::new(IncrementalDecoder::decode_uint(n)))
+    pub fn decode_vec(n: usize) -> Self {
+        IncrementalDecoder::InBufferLen(Box::new(Self::decode_uint(n)))
     }
 
     /// Decode a vector that as a varint-sized length prefix.
-    pub fn decode_vvec() -> IncrementalDecoder {
-        IncrementalDecoder::InBufferLen(Box::new(IncrementalDecoder::decode_varint()))
+    pub fn decode_vvec() -> Self {
+        IncrementalDecoder::InBufferLen(Box::new(Self::decode_varint()))
     }
 
     /// Ignore a certain number of bytes.
-    pub fn ignore(n: usize) -> IncrementalDecoder {
+    pub fn ignore(n: usize) -> Self {
         IncrementalDecoder::Ignoring { remaining: n }
     }
 
@@ -110,12 +111,12 @@ impl IncrementalDecoder {
         dv: &mut Decoder,
     ) -> IncrementalDecoderResult {
         if remaining <= dv.remaining() {
-            v = IncrementalDecoder::consume_uint_part(v, remaining, dv);
+            v = Self::consume_uint_part(v, remaining, dv);
             *self = IncrementalDecoder::Idle;
             IncrementalDecoderResult::Uint(v)
         } else {
             let r = dv.remaining();
-            v = IncrementalDecoder::consume_uint_part(v, r, dv);
+            v = Self::consume_uint_part(v, r, dv);
             remaining -= r;
             *self = IncrementalDecoder::InUint { v, remaining };
             IncrementalDecoderResult::InProgress
@@ -181,7 +182,11 @@ impl IncrementalDecoder {
                     IncrementalDecoderResult::InProgress
                 }
                 IncrementalDecoderResult::Uint(n) => {
-                    self.consume_buffer_remainder(Vec::with_capacity(n as usize), n as usize, dv)
+                    if let Ok(len) = usize::try_from(n) {
+                        self.consume_buffer_remainder(Vec::with_capacity(len), len, dv)
+                    } else {
+                        IncrementalDecoderResult::Error
+                    }
                 }
                 _ => unreachable!(),
             },
@@ -208,7 +213,7 @@ impl IncrementalDecoder {
 }
 
 impl Default for IncrementalDecoder {
-    fn default() -> IncrementalDecoder {
+    fn default() -> Self {
         IncrementalDecoder::Idle
     }
 }
@@ -244,7 +249,11 @@ mod tests {
     // Take a |decoder|, an encoded buffer |db|, and an |expected| outcome and run
     // the buffer through the encoder several times and check the result.
     // Split the buffer in a different position each time.
-    fn run_split(decoder: IncrementalDecoder, mut db: Encoder, expected: IncrementalDecoderResult) {
+    fn run_split(
+        decoder: &IncrementalDecoder,
+        mut db: Encoder,
+        expected: &IncrementalDecoderResult,
+    ) {
         eprintln!(
             "decode {:?} ; with {:?} ; expect {:?}",
             decoder, db, expected
@@ -274,7 +283,7 @@ mod tests {
             }
 
             assert_eq!(dec.min_remaining(), 0);
-            assert_eq!(res, expected);
+            assert_eq!(&res, expected);
         }
     }
 
@@ -284,11 +293,11 @@ mod tests {
     }
 
     impl UintTestCase {
-        pub fn run(&self, dec: IncrementalDecoder) {
+        pub fn run(&self, dec: &IncrementalDecoder) {
             run_split(
-                dec,
+                &dec,
                 Encoder::from_hex(&self.b),
-                IncrementalDecoderResult::Uint(self.v),
+                &IncrementalDecoderResult::Uint(self.v),
             );
         }
     }
@@ -309,7 +318,7 @@ mod tests {
             "012345" => 0x12345,
             "ffffffffffffffff" => 0xffff_ffff_ffff_ffff,
         ] {
-            c.run(IncrementalDecoder::decode_uint(c.b.len() / 2));
+            c.run(&IncrementalDecoder::decode_uint(c.b.len() / 2));
         }
     }
 
@@ -326,7 +335,7 @@ mod tests {
             "c000000040000000" => 1 << 30,
             "ffffffffffffffff" => (1 << 62) - 1,
         ] {
-            c.run(IncrementalDecoder::decode_varint());
+            c.run(&IncrementalDecoder::decode_varint());
         }
     }
 
@@ -336,11 +345,11 @@ mod tests {
     }
 
     impl BufTestCase {
-        pub fn run(&self, dec: IncrementalDecoder) {
+        pub fn run(&self, dec: &IncrementalDecoder) {
             run_split(
-                dec,
+                &dec,
                 Encoder::from_hex(&self.b),
-                IncrementalDecoderResult::Buffer(Encoder::from_hex(&self.v).into()),
+                &IncrementalDecoderResult::Buffer(Encoder::from_hex(&self.v).into()),
             );
         }
     }
@@ -359,7 +368,7 @@ mod tests {
             "01ff" => "ff",
             "03012345" => "012345",
         ] {
-            c.run(IncrementalDecoder::decode_vec(1));
+            c.run(&IncrementalDecoder::decode_vec(1));
         }
         for c in buf_tc![
             "0000" => "",
@@ -367,7 +376,7 @@ mod tests {
             "0001ff" => "ff",
             "0003012345" => "012345",
         ] {
-            c.run(IncrementalDecoder::decode_vec(2));
+            c.run(&IncrementalDecoder::decode_vec(2));
         }
     }
 
@@ -379,7 +388,7 @@ mod tests {
             "01ff" => "ff",
             "03012345" => "012345",
         ] {
-            c.run(IncrementalDecoder::decode_vvec());
+            c.run(&IncrementalDecoder::decode_vvec());
         }
     }
 
@@ -403,9 +412,9 @@ mod tests {
     fn ignore() {
         let enc = Encoder::from_hex("12345678");
         run_split(
-            IncrementalDecoder::ignore(4),
+            &IncrementalDecoder::ignore(4),
             enc,
-            IncrementalDecoderResult::Ignored,
+            &IncrementalDecoderResult::Ignored,
         );
     }
 }

diff --git a/neqo-common/src/once.rs b/neqo-common/src/once.rs
--- a/neqo-common/src/once.rs
+++ b/neqo-common/src/once.rs
@@ -6,6 +6,7 @@
 
 use std::sync::Once;
 
+#[allow(clippy::module_name_repetitions)]
 pub struct OnceResult<T> {
     once: Once,
     v: Option<T>,
@@ -13,7 +14,7 @@ pub struct OnceResult<T> {
 
 impl<T> OnceResult<T> {
     pub const fn new() -> Self {
-        OnceResult {
+        Self {
             once: Once::new(),
             v: None,
         }

diff --git a/neqo-crypto/src/aead.rs b/neqo-crypto/src/aead.rs
--- a/neqo-crypto/src/aead.rs
+++ b/neqo-crypto/src/aead.rs
@@ -14,6 +14,7 @@ use crate::result;
 use crate::ssl;
 use crate::ssl::{PRUint16, PRUint64, PRUint8, SSLAeadContext};
 
+use std::convert::TryInto;
 use std::fmt;
 use std::ops::{Deref, DerefMut};
 use std::os::raw::{c_char, c_uint};
@@ -62,9 +63,9 @@ impl Aead {
         cipher: Cipher,
         secret: &SymKey,
         prefix: S,
-    ) -> Res<Aead> {
+    ) -> Res<Self> {
         let s: *mut PK11SymKey = **secret;
-        unsafe { Aead::from_raw(version, cipher, s, prefix) }
+        unsafe { Self::from_raw(version, cipher, s, prefix) }
     }
 
     unsafe fn from_raw<S: Into<String>>(
@@ -72,7 +73,7 @@ impl Aead {
         cipher: Cipher,
         secret: *mut PK11SymKey,
         prefix: S,
-    ) -> Res<Aead> {
+    ) -> Res<Self> {
         let prefix_str = prefix.into();
         let p = prefix_str.as_bytes();
         let mut ctx: *mut ssl::SSLAeadContext = null_mut();
@@ -81,12 +82,12 @@ impl Aead {
             cipher,
             secret,
             p.as_ptr() as *const i8,
-            p.len() as u32,
+            p.len().try_into()?,
             &mut ctx,
         );
         result::result(rv)?;
         match NonNull::new(ctx) {
-            Some(ctx_ptr) => Ok(Aead {
+            Some(ctx_ptr) => Ok(Self {
                 ctx: AeadContext::new(ctx_ptr),
             }),
             None => Err(Error::InternalError),

diff --git a/neqo-crypto/src/agent.rs b/neqo-crypto/src/agent.rs
--- a/neqo-crypto/src/agent.rs
+++ b/neqo-crypto/src/agent.rs
@@ -53,7 +53,7 @@ impl HandshakeState {
 
 fn get_alpn(fd: *mut ssl::PRFileDesc, pre: bool) -> Res<Option<String>> {
     let mut alpn_state = ssl::SSLNextProtoState::SSL_NEXT_PROTO_NO_SUPPORT;
-    let mut chosen = vec![0u8; 255];
+    let mut chosen = vec![0_u8; 255];
     let mut chosen_len: c_uint = 0;
     let rv = unsafe {
         ssl::SSL_GetNextProto(
@@ -99,18 +99,18 @@ macro_rules! preinfo_arg {
 }
 
 impl SecretAgentPreInfo {
-    fn new(fd: *mut ssl::PRFileDesc) -> Res<SecretAgentPreInfo> {
+    fn new(fd: *mut ssl::PRFileDesc) -> Res<Self> {
         let mut info: ssl::SSLPreliminaryChannelInfo = unsafe { mem::uninitialized() };
         let rv = unsafe {
             ssl::SSL_GetPreliminaryChannelInfo(
                 fd,
                 &mut info,
-                mem::size_of::<ssl::SSLPreliminaryChannelInfo>() as ssl::PRUint32,
+                mem::size_of::<ssl::SSLPreliminaryChannelInfo>().try_into()?,
             )
         };
         result::result(rv)?;
 
-        Ok(SecretAgentPreInfo {
+        Ok(Self {
             info,
             alpn: get_alpn(fd, true)?,
         })
@@ -150,24 +150,24 @@ pub struct SecretAgentInfo {
 }
 
 impl SecretAgentInfo {
-    fn new(fd: *mut ssl::PRFileDesc) -> Res<SecretAgentInfo> {
+    fn new(fd: *mut ssl::PRFileDesc) -> Res<Self> {
         let mut info: ssl::SSLChannelInfo = unsafe { mem::uninitialized() };
         let rv = unsafe {
             ssl::SSL_GetChannelInfo(
                 fd,
                 &mut info,
-                mem::size_of::<ssl::SSLChannelInfo>() as ssl::PRUint32,
+                mem::size_of::<ssl::SSLChannelInfo>().try_into()?,
             )
         };
         result::result(rv)?;
-        Ok(SecretAgentInfo {
+        Ok(Self {
             version: info.protocolVersion as Version,
             cipher: info.cipherSuite as Cipher,
-            group: info.keaGroup as Group,
+            group: info.keaGroup.try_into()?,
             resumed: info.resumed != 0,
             early_data: info.earlyDataAccepted != 0,
             alpn: get_alpn(fd, false)?,
-            signature_scheme: info.signatureScheme as SignatureScheme,
+            signature_scheme: info.signatureScheme.try_into()?,
         })
     }
 
@@ -194,8 +194,9 @@ impl SecretAgentInfo {
     }
 }
 
-/// SecretAgent holds the common parts of client and server.
+/// `SecretAgent` holds the common parts of client and server.
 #[derive(Debug)]
+#[allow(clippy::module_name_repetitions)]
 pub struct SecretAgent {
     fd: *mut ssl::PRFileDesc,
     secrets: SecretHolder,
@@ -218,10 +219,10 @@ pub struct SecretAgent {
 }
 
 impl SecretAgent {
-    fn new() -> Res<SecretAgent> {
-        let mut agent = SecretAgent {
+    fn new() -> Res<Self> {
+        let mut agent = Self {
             fd: null_mut(),
-            secrets: Default::default(),
+            secrets: SecretHolder::default(),
             raw: None,
             io: Box::new(AgentIo::new()),
             state: HandshakeState::New,
@@ -230,8 +231,8 @@ impl SecretAgent {
             alert: Box::new(None),
             now: Box::new(0),
 
-            extension_handlers: Default::default(),
-            inf: Default::default(),
+            extension_handlers: Vec::new(),
+            inf: None,
 
             no_eoed: false,
         };
@@ -290,13 +291,10 @@ impl SecretAgent {
             // Fatal alerts demand attention.
             let p = arg as *mut Option<Alert>;
             let st = p.as_mut().unwrap();
-            match st {
-                None => {
-                    *st = Some(alert.description);
-                }
-                _ => {
-                    qwarn!([format!("{:p}", fd)] "duplicate alert {}", alert.description);
-                }
+            if st.is_none() {
+                *st = Some(alert.description);
+            } else {
+                qwarn!([format!("{:p}", fd)] "duplicate alert {}", alert.description);
             }
         }
     }
@@ -309,29 +307,29 @@ impl SecretAgent {
 
     // Ready this for connecting.
     fn ready(&mut self, is_server: bool) -> Res<()> {
-        let rv = unsafe {
+        let mut rv = unsafe {
             ssl::SSL_AuthCertificateHook(
                 self.fd,
-                Some(SecretAgent::auth_complete_hook),
+                Some(Self::auth_complete_hook),
                 &mut *self.auth_required as *mut bool as *mut c_void,
             )
         };
         result::result(rv)?;
 
-        let rv = unsafe {
+        rv = unsafe {
             ssl::SSL_AlertSentCallback(
                 self.fd,
-                Some(SecretAgent::alert_sent_cb),
+                Some(Self::alert_sent_cb),
                 &mut *self.alert as *mut Option<Alert> as *mut c_void,
             )
         };
         result::result(rv)?;
 
         // TODO(mt) move to time.rs so we can remove PRTime definition from nss_ssl bindings.
-        let rv = unsafe {
+        rv = unsafe {
             ssl::SSL_SetTimeFunc(
                 self.fd,
-                Some(SecretAgent::time_func),
+                Some(Self::time_func),
                 &mut *self.now as *mut PRTime as *mut c_void,
             )
         };
@@ -419,8 +417,10 @@ impl SecretAgent {
         // Prepare to encode.
         let mut encoded = Vec::with_capacity(encoded_len);
         let mut add = |v: &str| {
-            encoded.push(v.len() as u8);
-            encoded.extend_from_slice(v.as_bytes());
+            if let Ok(s) = v.len().try_into() {
+                encoded.push(s);
+                encoded.extend_from_slice(v.as_bytes());
+            }
         };
 
         // NSS inherited an idiosyncratic API as a result of having implemented NPN
@@ -574,7 +574,7 @@ impl SecretAgent {
         self.set_raw(true)?;
 
         // Setup for accepting records.
-        let mut records: Box<RecordList> = Default::default();
+        let mut records = Box::new(RecordList::default());
         let records_ptr = &mut *records as *mut RecordList as *mut c_void;
         let rv =
             unsafe { ssl::SSL_RecordLayerWriteCallback(self.fd, Some(ingest_record), records_ptr) };
@@ -683,7 +683,7 @@ impl Client {
         }
         result::result(unsafe { ssl::SSL_SetURL(agent.fd, url.unwrap().as_ptr()) })?;
         agent.ready(false)?;
-        let mut client = Client {
+        let mut client = Self {
             agent,
             resumption: Box::new(None),
         };
@@ -709,7 +709,7 @@ impl Client {
         let rv = unsafe {
             ssl::SSL_SetResumptionTokenCallback(
                 self.fd,
-                Some(Client::resumption_token_cb),
+                Some(Self::resumption_token_cb),
                 &mut *self.resumption as *mut Option<Vec<u8>> as *mut c_void,
             )
         };
@@ -743,7 +743,7 @@ impl DerefMut for Client {
     }
 }
 
-/// ZeroRttCheckResult encapsulates the options for handling a ClientHello.
+/// `ZeroRttCheckResult` encapsulates the options for handling a `ClientHello`.
 #[derive(Clone, Debug, PartialEq)]
 pub enum ZeroRttCheckResult {
     /// Accept 0-RTT; the default.
@@ -756,7 +756,7 @@ pub enum ZeroRttCheckResult {
     Fail,
 }
 
-/// A ZeroRttChecker is used by the agent to validate the application token (as provided by send_ticket)
+/// A `ZeroRttChecker` is used by the agent to validate the application token (as provided by `send_ticket`)
 pub trait ZeroRttChecker: std::fmt::Debug {
     fn check(&self, token: &[u8]) -> ZeroRttCheckResult;
 }
@@ -768,11 +768,8 @@ struct ZeroRttCheckState {
 }
 
 impl ZeroRttCheckState {
-    pub fn new(
-        fd: *mut ssl::PRFileDesc,
-        checker: Box<dyn ZeroRttChecker>,
-    ) -> Box<ZeroRttCheckState> {
-        Box::new(ZeroRttCheckState { fd, checker })
+    pub fn new(fd: *mut ssl::PRFileDesc, checker: Box<dyn ZeroRttChecker>) -> Box<Self> {
+        Box::new(Self { fd, checker })
     }
 }
 
@@ -811,7 +808,7 @@ impl Server {
         }
 
         agent.ready(true)?;
-        Ok(Server {
+        Ok(Self {
             agent,
             zero_rtt_check: None,
         })
@@ -865,11 +862,11 @@ impl Server {
     ) -> Res<()> {
         let mut check_state = ZeroRttCheckState::new(self.agent.fd, checker);
         let arg = &mut *check_state as *mut ZeroRttCheckState as *mut c_void;
-        let rv = unsafe {
-            ssl::SSL_HelloRetryRequestCallback(self.agent.fd, Some(Server::hello_retry_cb), arg)
+        let mut rv = unsafe {
+            ssl::SSL_HelloRetryRequestCallback(self.agent.fd, Some(Self::hello_retry_cb), arg)
         };
         result::result(rv)?;
-        let rv = unsafe { ssl::SSL_SetMaxEarlyDataSize(self.agent.fd, max_early_data) };
+        rv = unsafe { ssl::SSL_SetMaxEarlyDataSize(self.agent.fd, max_early_data) };
         result::result(rv)?;
         self.zero_rtt_check = Some(check_state);
         self.agent.enable_0rtt()?;

diff --git a/neqo-crypto/src/agentio.rs b/neqo-crypto/src/agentio.rs
--- a/neqo-crypto/src/agentio.rs
+++ b/neqo-crypto/src/agentio.rs
@@ -13,6 +13,7 @@ use crate::ssl;
 
 use neqo_common::{hex, qtrace};
 use std::cmp::min;
+use std::convert::{TryFrom, TryInto};
 use std::fmt;
 use std::mem;
 use std::ops::Deref;
@@ -43,8 +44,8 @@ pub struct Record {
 }
 
 impl Record {
-    pub fn new(epoch: Epoch, ct: ssl::SSLContentType::Type, data: &[u8]) -> Record {
-        Record {
+    pub fn new(epoch: Epoch, ct: ssl::SSLContentType::Type, data: &[u8]) -> Self {
+        Self {
             epoch,
             ct,
             data: data.to_vec(),
@@ -206,8 +207,8 @@ pub struct AgentIo {
 }
 
 impl AgentIo {
-    pub fn new() -> AgentIo {
-        AgentIo {
+    pub fn new() -> Self {
+        Self {
             input: AgentIoInput {
                 input: null(),
                 available: 0,
@@ -216,9 +217,9 @@ impl AgentIo {
         }
     }
 
-    unsafe fn borrow(fd: &mut PrFd) -> &mut AgentIo {
+    unsafe fn borrow(fd: &mut PrFd) -> &mut Self {
         #[allow(clippy::cast_ptr_alignment)]
-        let io = (**fd).secret as *mut AgentIo;
+        let io = (**fd).secret as *mut Self;
         io.as_mut().unwrap()
     }
 
@@ -256,12 +257,13 @@ unsafe extern "C" fn agent_close(fd: PrFd) -> PrStatus {
 
 unsafe extern "C" fn agent_read(mut fd: PrFd, buf: *mut c_void, amount: prio::PRInt32) -> PrStatus {
     let io = AgentIo::borrow(&mut fd);
-    if amount <= 0 {
-        return PR_FAILURE;
-    }
-    match io.input.read_input(buf as *mut u8, amount as usize) {
-        Ok(_) => PR_SUCCESS,
-        Err(_) => PR_FAILURE,
+    if let Ok(a) = amount.try_into() {
+        match io.input.read_input(buf as *mut u8, a) {
+            Ok(_) => PR_SUCCESS,
+            Err(_) => PR_FAILURE,
+        }
+    } else {
+        PR_FAILURE
     }
 }
 
@@ -276,9 +278,13 @@ unsafe extern "C" fn agent_recv(
     if amount <= 0 || flags != 0 {
         return PR_FAILURE;
     }
-    match io.input.read_input(buf as *mut u8, amount as usize) {
-        Ok(v) => v as prio::PRInt32,
-        Err(_) => -1,
+    if let Ok(a) = amount.try_into() {
+        match io.input.read_input(buf as *mut u8, a) {
+            Ok(v) => prio::PRInt32::try_from(v).unwrap_or(PR_FAILURE),
+            Err(_) => PR_FAILURE,
+        }
+    } else {
+        PR_FAILURE
     }
 }
 
@@ -291,8 +297,12 @@ unsafe extern "C" fn agent_write(
     if amount <= 0 {
         return PR_FAILURE;
     }
-    io.save_output(buf as *const u8, amount as usize);
-    amount as prio::PRInt32
+    if let Ok(a) = amount.try_into() {
+        io.save_output(buf as *const u8, a);
+        amount
+    } else {
+        PR_FAILURE
+    }
 }
 
 unsafe extern "C" fn agent_send(
@@ -307,22 +317,31 @@ unsafe extern "C" fn agent_send(
     if amount <= 0 || flags != 0 {
         return PR_FAILURE;
     }
-    io.save_output(buf as *const u8, amount as usize);
-    amount as prio::PRInt32
+    if let Ok(a) = amount.try_into() {
+        io.save_output(buf as *const u8, a);
+        amount
+    } else {
+        PR_FAILURE
+    }
 }
 
 unsafe extern "C" fn agent_available(mut fd: PrFd) -> prio::PRInt32 {
     let io = AgentIo::borrow(&mut fd);
-    io.input.available as prio::PRInt32
+    io.input.available.try_into().unwrap_or(PR_FAILURE)
 }
 
 unsafe extern "C" fn agent_available64(mut fd: PrFd) -> prio::PRInt64 {
     let io = AgentIo::borrow(&mut fd);
-    io.input.available as prio::PRInt64
+    io.input
+        .available
+        .try_into()
+        .unwrap_or_else(|_| PR_FAILURE.into())
 }
 
+#[allow(clippy::cast_possible_truncation)]
 unsafe extern "C" fn agent_getname(_fd: PrFd, addr: *mut prio::PRNetAddr) -> PrStatus {
     let a = addr.as_mut().unwrap();
+    // Cast is safe because prio::PR_AF_INET is 2
     a.inet.family = prio::PR_AF_INET as prio::PRUint16;
     a.inet.port = 0;
     a.inet.ip = 0;

diff --git a/neqo-crypto/src/cert.rs b/neqo-crypto/src/cert.rs
--- a/neqo-crypto/src/cert.rs
+++ b/neqo-crypto/src/cert.rs
@@ -4,8 +4,6 @@
 // option. This file may not be copied, modified, or distributed
 // except according to those terms.
 
-use std::ptr::{null_mut, NonNull};
-
 use crate::p11::{
     CERTCertList, CERTCertListNode, CERT_GetCertificateDer, CertList, PRCList, SECItem,
     SECItemArray, SECItemType,
@@ -15,6 +13,8 @@ use crate::ssl::{
     PRFileDesc, SSL_PeerCertificateChain, SSL_PeerSignedCertTimestamps,
     SSL_PeerStapledOCSPResponses,
 };
+use std::convert::TryInto;
+use std::ptr::{null_mut, NonNull};
 
 use std::slice;
 
@@ -38,6 +38,8 @@ fn peer_certificate_chain(fd: *mut PRFileDesc) -> Option<(CertList, *const CERTC
     Some((certs, cursor))
 }
 
+// As explained in rfc6961, an OCSPResponseList can have at most
+// 2^24 items. Casting its length is therefore safe even on 32 bits targets.
 fn stapled_ocsp_responses(fd: *mut PRFileDesc) -> Option<Vec<Vec<u8>>> {
     let ocsp_nss = unsafe { SSL_PeerStapledOCSPResponses(fd) };
     match NonNull::new(ocsp_nss as *mut SECItemArray) {
@@ -45,8 +47,11 @@ fn stapled_ocsp_responses(fd: *mut PRFileDesc) -> Option<Vec<Vec<u8>>> {
             let mut ocsp_helper: Vec<Vec<u8>> = Vec::new();
             let len = unsafe { ocsp_ptr.as_ref().len };
             for inx in 0..len {
-                let item_nss =
-                    unsafe { ocsp_ptr.as_ref().items.offset(inx as isize) as *const SECItem };
+                let item_nss = if let Ok(i) = inx.try_into() {
+                    unsafe { ocsp_ptr.as_ref().items.offset(i) as *const SECItem }
+                } else {
+                    return None;
+                };
                 let item =
                     unsafe { slice::from_raw_parts((*item_nss).data, (*item_nss).len as usize) };
                 ocsp_helper.push(item.to_owned());
@@ -73,7 +78,7 @@ fn signed_cert_timestamp(fd: *mut PRFileDesc) -> Option<Vec<u8>> {
 impl CertificateInfo {
     pub(crate) fn new(fd: *mut PRFileDesc) -> Option<Self> {
         match peer_certificate_chain(fd) {
-            Some((certs, cursor)) => Some(CertificateInfo {
+            Some((certs, cursor)) => Some(Self {
                 certs,
                 cursor,
                 stapled_ocsp_responses: stapled_ocsp_responses(fd),

diff --git a/neqo-crypto/src/err.rs b/neqo-crypto/src/err.rs
--- a/neqo-crypto/src/err.rs
+++ b/neqo-crypto/src/err.rs
@@ -17,6 +17,7 @@ pub mod NSPRErrorCodes {
 pub type Res<T> = Result<T, Error>;
 
 #[derive(Clone, Debug, PartialEq, PartialOrd, Ord, Eq)]
+#[allow(clippy::pub_enum_variant_names)]
 pub enum Error {
     AeadInitFailure,
     AeadError,
@@ -57,7 +58,7 @@ impl std::fmt::Display for Error {
 
 // TryFromIntError is only ever used in time.rs for time conversion.
 impl From<std::num::TryFromIntError> for Error {
-    fn from(_: std::num::TryFromIntError) -> Error {
+    fn from(_: std::num::TryFromIntError) -> Self {
         Error::TimeTravelError
     }
 }

diff --git a/neqo-crypto/src/ext.rs b/neqo-crypto/src/ext.rs
--- a/neqo-crypto/src/ext.rs
+++ b/neqo-crypto/src/ext.rs
@@ -70,6 +70,7 @@ impl ExtensionTracker {
         f(rc.borrow_mut().deref_mut())
     }
 
+    #[allow(clippy::cast_possible_truncation)]
     unsafe extern "C" fn extension_writer(
         _fd: *mut PRFileDesc,
         message: SSLHandshakeType::Type,
@@ -79,7 +80,8 @@ impl ExtensionTracker {
         arg: *mut c_void,
     ) -> PRBool {
         let d = std::slice::from_raw_parts_mut(data, max_len as usize);
-        ExtensionTracker::wrap_handler_call(arg, |handler| {
+        Self::wrap_handler_call(arg, |handler| {
+            // Cast is safe here because the message type is always part of the enum
             match handler.write(message as HandshakeMessage, d) {
                 ExtensionWriterResult::Write(sz) => {
                     *len = to_c_uint(sz).expect("integer overflow from extension writer");
@@ -99,7 +101,9 @@ impl ExtensionTracker {
         arg: *mut c_void,
     ) -> SECStatus {
         let d = std::slice::from_raw_parts(data, len as usize);
-        ExtensionTracker::wrap_handler_call(arg, |handler| {
+        #[allow(clippy::cast_possible_truncation)]
+        Self::wrap_handler_call(arg, |handler| {
+            // Cast is safe here because the message type is always part of the enum
             match handler.handle(message as HandshakeMessage, d) {
                 ExtensionHandlerResult::Ok => SECSuccess,
                 ExtensionHandlerResult::Alert(a) => {
@@ -114,7 +118,7 @@ impl ExtensionTracker {
         fd: *mut PRFileDesc,
         extension: Extension,
         handler: Rc<RefCell<dyn ExtensionHandler>>,
-    ) -> Res<ExtensionTracker> {
+    ) -> Res<Self> {
         // The ergonomics here aren't great for users of this API, but it's
         // even worse here. The double box is used to allow us to own a reference
         // to the handler AND also pass a bare pointer to the inner box to C.
@@ -122,7 +126,7 @@ impl ExtensionTracker {
         // the access in the callback from decrementing the Rc counters when the
         // duped instance is dropped.  That would result in the object being dropped
         // in the callbacks (and the UAF that follows).
-        let mut tracker = ExtensionTracker {
+        let mut tracker = Self {
             extension,
             handler: Box::new(Box::new(handler)),
         };
@@ -130,9 +134,9 @@ impl ExtensionTracker {
         let rv = SSL_InstallExtensionHooks(
             fd,
             extension,
-            Some(ExtensionTracker::extension_writer),
+            Some(Self::extension_writer),
             p,
-            Some(ExtensionTracker::extension_handler),
+            Some(Self::extension_handler),
             p,
         );
         result::result(rv)?;

diff --git a/neqo-crypto/src/hp.rs b/neqo-crypto/src/hp.rs
--- a/neqo-crypto/src/hp.rs
+++ b/neqo-crypto/src/hp.rs
@@ -81,12 +81,14 @@ pub fn extract_hp<S: Into<String>>(
 
 impl HpKey {
     /// Generate a header protection mask for QUIC.
+    #[allow(clippy::cast_sign_loss)]
     pub fn mask(&self, sample: &[u8]) -> Res<Vec<u8>> {
         let k: *mut PK11SymKey = *self.0;
         let mech = unsafe { PK11_GetMechanism(k) };
+        // Cast is safe because block size is always greater than or equal to 0
         let block_size = unsafe { PK11_GetBlockSize(mech, null_mut()) } as usize;
 
-        let mut output = vec![0u8; block_size];
+        let mut output = vec![0_u8; block_size];
         let output_slice = &mut output[..];
         let mut output_len: c_uint = 0;
 
@@ -95,7 +97,7 @@ impl HpKey {
             data: sample.as_ptr() as *mut u8,
             len: to_c_uint(sample.len())?,
         };
-        let zero = vec![0u8; block_size];
+        let zero = vec![0_u8; block_size];
         let (iv, inbuf) = match () {
             _ if mech == CK_MECHANISM_TYPE::from(CKM_AES_ECB) => (null_mut(), sample),
             _ if mech == CK_MECHANISM_TYPE::from(CKM_NSS_CHACHA20_CTR) => {

diff --git a/neqo-crypto/src/lib.rs b/neqo-crypto/src/lib.rs
--- a/neqo-crypto/src/lib.rs
+++ b/neqo-crypto/src/lib.rs
@@ -5,6 +5,10 @@
 // except according to those terms.
 
 #![deny(warnings)]
+// Bindgen auto generated code
+// won't adhere to the clippy rules below
+#![allow(clippy::module_name_repetitions)]
+#![allow(clippy::unseparated_literal_suffix)]
 
 #[macro_use]
 mod exp;
@@ -88,9 +92,9 @@ pub fn init() {
                 return NssLoaded::External;
             }
 
-            let st = nss::NSS_NoDB_Init(null());
+            let mut st = nss::NSS_NoDB_Init(null());
             result(st).expect("NSS_NoDB_Init failed");
-            let st = nss::NSS_SetDomesticPolicy();
+            st = nss::NSS_SetDomesticPolicy();
             result(st).expect("NSS_SetDomesticPolicy failed");
 
             NssLoaded::NoDb
@@ -111,7 +115,7 @@ pub fn init_db<P: Into<PathBuf>>(dir: P) {
             let pathstr = path.to_str().expect("path converts to string").to_string();
             let dircstr = CString::new(pathstr).expect("new CString");
             let empty = CString::new("").expect("new empty CString");
-            let st = nss::NSS_Initialize(
+            let mut st = nss::NSS_Initialize(
                 dircstr.as_ptr(),
                 empty.as_ptr(),
                 empty.as_ptr(),
@@ -120,10 +124,10 @@ pub fn init_db<P: Into<PathBuf>>(dir: P) {
             );
             result(st).expect("NSS_Initialize failed");
 
-            let st = nss::NSS_SetDomesticPolicy();
+            st = nss::NSS_SetDomesticPolicy();
             result(st).expect("NSS_SetDomesticPolicy failed");
 
-            let st = ssl::SSL_ConfigServerSessionIDCache(1024, 0, 0, dircstr.as_ptr());
+            st = ssl::SSL_ConfigServerSessionIDCache(1024, 0, 0, dircstr.as_ptr());
             result(st).expect("SSL_ConfigServerSessionIDCache failed");
 
             NssLoaded::Db(path.to_path_buf().into_boxed_path())

diff --git a/neqo-crypto/src/p11.rs b/neqo-crypto/src/p11.rs
--- a/neqo-crypto/src/p11.rs
+++ b/neqo-crypto/src/p11.rs
@@ -29,8 +29,8 @@ macro_rules! scoped_ptr {
         }
 
         impl $scoped {
-            pub fn new(ptr: NonNull<$target>) -> $scoped {
-                $scoped { ptr: ptr.as_ptr() }
+            pub fn new(ptr: NonNull<$target>) -> Self {
+                Self { ptr: ptr.as_ptr() }
             }
         }

diff --git a/neqo-crypto/src/prio.rs b/neqo-crypto/src/prio.rs
--- a/neqo-crypto/src/prio.rs
+++ b/neqo-crypto/src/prio.rs
@@ -8,6 +8,7 @@
 #![allow(non_upper_case_globals)]
 #![allow(non_snake_case)]
 #![allow(clippy::cognitive_complexity)]
+#![allow(clippy::empty_enum)]
 
 include!(concat!(env!("OUT_DIR"), "/nspr_io.rs"));

diff --git a/neqo-crypto/src/replay.rs b/neqo-crypto/src/replay.rs
--- a/neqo-crypto/src/replay.rs
+++ b/neqo-crypto/src/replay.rs
@@ -17,6 +17,7 @@ use std::ptr::{null_mut, NonNull};
 use std::time::{Duration, Instant};
 
 // This is an opaque struct in NSS.
+#[allow(clippy::empty_enum)]
 pub enum SSLAntiReplayContext {}
 
 experimental_api!(SSL_CreateAntiReplayContext(
@@ -38,10 +39,11 @@ scoped_ptr!(
     SSL_ReleaseAntiReplayContext
 );
 
-/// AntiReplay is used by servers when processing 0-RTT handshakes.
+/// `AntiReplay` is used by servers when processing 0-RTT handshakes.
 /// It limits the exposure of servers to replay attack by rejecting 0-RTT
 /// if it appears to be a replay.  There is a false-positive rate that can be
 /// managed by tuning the parameters used to create the context.
+#[allow(clippy::module_name_repetitions)]
 pub struct AntiReplay {
     ctx: AntiReplayContext,
 }
@@ -49,7 +51,7 @@ pub struct AntiReplay {
 impl AntiReplay {
     /// Make a new anti-replay context.
     /// See the documentation in NSS for advice on how to set these values.
-    pub fn new(now: Instant, window: Duration, k: usize, bits: usize) -> Res<AntiReplay> {
+    pub fn new(now: Instant, window: Duration, k: usize, bits: usize) -> Res<Self> {
         let mut ctx: *mut SSLAntiReplayContext = null_mut();
         let rv = unsafe {
             SSL_CreateAntiReplayContext(
@@ -63,7 +65,7 @@ impl AntiReplay {
         result::result(rv)?;
 
         match NonNull::new(ctx) {
-            Some(ctx_nn) => Ok(AntiReplay {
+            Some(ctx_nn) => Ok(Self {
                 ctx: AntiReplayContext::new(ctx_nn),
             }),
             None => Err(Error::InternalError),

diff --git a/neqo-crypto/src/secrets.rs b/neqo-crypto/src/secrets.rs
--- a/neqo-crypto/src/secrets.rs
+++ b/neqo-crypto/src/secrets.rs
@@ -38,6 +38,7 @@ impl From<SSLSecretDirection::Type> for SecretDirection {
 }
 
 #[derive(Debug, Default)]
+#[allow(clippy::module_name_repetitions)]
 pub struct DirectionalSecrets {
     // We only need to maintain 3 secrets for the epochs used during the handshake.
     secrets: [Option<SymKey>; 3],
@@ -74,7 +75,7 @@ impl Secrets {
         secret: *mut PK11SymKey,
         arg: *mut c_void,
     ) {
-        let secrets_ptr = arg as *mut Secrets;
+        let secrets_ptr = arg as *mut Self;
         let secrets = secrets_ptr.as_mut().unwrap();
         secrets.put_raw(epoch, dir, secret);
     }

diff --git a/neqo-crypto/src/ssl.rs b/neqo-crypto/src/ssl.rs
--- a/neqo-crypto/src/ssl.rs
+++ b/neqo-crypto/src/ssl.rs
@@ -19,14 +19,16 @@ mod SSLOption {
 }
 
 // I clearly don't understand how bindgen operates.
+#[allow(clippy::empty_enum)]
 pub enum PLArenaPool {}
+#[allow(clippy::empty_enum)]
 pub enum PRFileDesc {}
 
 // Remap some constants.
 pub const SECSuccess: SECStatus = _SECStatus_SECSuccess;
 pub const SECFailure: SECStatus = _SECStatus_SECFailure;
 
-#[derive(Debug)]
+#[derive(Debug, Copy, Clone)]
 pub enum Opt {
     Locking,
     Tickets,
@@ -41,7 +43,9 @@ pub enum Opt {
 }
 
 impl Opt {
-    pub fn as_int(&self) -> PRInt32 {
+    // Cast is safe here because SSLOptions are within the i32 range
+    #[allow(clippy::cast_possible_wrap)]
+    pub fn as_int(self) -> PRInt32 {
         let i = match self {
             Opt::Locking => SSLOption::SSL_NO_LOCKS,
             Opt::Tickets => SSLOption::SSL_ENABLE_SESSION_TICKETS,
@@ -58,7 +62,7 @@ impl Opt {
     }
 
     // Some options are backwards, like SSL_NO_LOCKS, so use this to manage that.
-    pub fn map_enabled(&self, enabled: bool) -> PRIntn {
+    pub fn map_enabled(self, enabled: bool) -> PRIntn {
         let v = match self {
             Opt::Locking => !enabled,
             _ => enabled,

diff --git a/neqo-crypto/src/time.rs b/neqo-crypto/src/time.rs
--- a/neqo-crypto/src/time.rs
+++ b/neqo-crypto/src/time.rs
@@ -14,7 +14,7 @@ use std::time::{Duration, Instant};
 
 include!(concat!(env!("OUT_DIR"), "/nspr_time.rs"));
 
-/// This struct holds the zero time used for converting between Instant and PRTime.
+/// This struct holds the zero time used for converting between `Instant` and `PRTime`.
 #[derive(Debug)]
 struct TimeZero {
     instant: Instant,
@@ -28,13 +28,13 @@ impl TimeZero {
     /// `BASE_TIME` are used with these conversion functions, they will fail.
     /// To avoid that, we make sure that this sets the base time using the first value
     /// it sees if it is in the past.  If it is not, then use `Instant::now()` instead.
-    pub fn baseline(t: Instant) -> TimeZero {
+    pub fn baseline(t: Instant) -> Self {
         let now = Instant::now();
         let prnow = unsafe { PR_Now() };
 
         if now <= t {
             // `t` is in the future, just use `now`.
-            TimeZero {
+            Self {
                 instant: now,
                 prtime: prnow,
             }
@@ -43,7 +43,7 @@ impl TimeZero {
             // An error from these unwrap functions would require
             // ridiculously long application running time.
             let prelapsed: PRTime = elapsed.try_into().unwrap();
-            TimeZero {
+            Self {
                 instant: t,
                 prtime: prnow.checked_sub(prelapsed).unwrap(),
             }
@@ -65,7 +65,7 @@ pub(crate) fn init() {
     let _ = get_base();
 }
 
-/// Time wraps Instant and provides conversion functions into PRTime.
+/// Time wraps Instant and provides conversion functions into `PRTime`.
 #[derive(Clone, Copy, Debug, PartialEq)]
 pub struct Time {
     t: Instant,
@@ -84,22 +84,18 @@ impl From<Instant> for Time {
         // Call `TimeZero::baseline(t)` so that time zero can be set.
         let f = || TimeZero::baseline(t);
         let _ = unsafe { BASE_TIME.call_once(f) };
-        Time { t }
+        Self { t }
     }
 }
 
 impl TryFrom<PRTime> for Time {
     type Error = Error;
-    fn try_from(prtime: PRTime) -> Res<Time> {
+    fn try_from(prtime: PRTime) -> Res<Self> {
         let base = get_base();
         if let Some(delta) = prtime.checked_sub(base.prtime) {
-            if !delta.is_negative() {
-                let d = Duration::from_nanos(delta as u64);
-                if let Some(t) = base.instant.checked_add(d) {
-                    Ok(Time { t })
-                } else {
-                    Err(Error::TimeTravelError)
-                }
+            let d = Duration::from_nanos(delta.try_into()?);
+            if let Some(t) = base.instant.checked_add(d) {
+                Ok(Self { t })
             } else {
                 Err(Error::TimeTravelError)
             }
@@ -133,7 +129,7 @@ impl Into<Instant> for Time {
     }
 }
 
-/// Interval wraps Duration and provides conversion functions into PRTime.
+/// Interval wraps Duration and provides conversion functions into `PRTime`.
 #[derive(Clone, Copy, Debug, PartialEq)]
 pub struct Interval {
     d: Duration,
@@ -148,16 +144,16 @@ impl Deref for Interval {
 
 impl TryFrom<PRTime> for Interval {
     type Error = Error;
-    fn try_from(prtime: PRTime) -> Res<Interval> {
-        Ok(Interval {
+    fn try_from(prtime: PRTime) -> Res<Self> {
+        Ok(Self {
             d: Duration::from_nanos(u64::try_from(prtime)?),
         })
     }
 }
 
 impl From<Duration> for Interval {
-    fn from(d: Duration) -> Interval {
-        Interval { d }
+    fn from(d: Duration) -> Self {
+        Self { d }
     }
 }

diff --git a/neqo-transport/src/connection.rs b/neqo-transport/src/connection.rs
--- a/neqo-transport/src/connection.rs
+++ b/neqo-transport/src/connection.rs
@@ -151,7 +151,7 @@ impl Path {
 }
 
 #[derive(Clone, Debug, PartialEq)]
-/// Type returned from process() and process_output(). Users are required to
+/// Type returned from process() and `process_output()`. Users are required to
 /// call these repeatedly until `Callback` or `None` is returned.
 pub enum Output {
     /// Connection requires no action.
@@ -1082,14 +1082,14 @@ impl Connection {
         let swapped = mem::replace(&mut self.tps, Rc::default());
         {
             let tph = swapped.borrow();
-            let tps = tph.remote();
+            let remote = tph.remote();
             self.indexes.remote_max_stream_bidi =
-                StreamIndex::new(tps.get_integer(tp_const::INITIAL_MAX_STREAMS_BIDI));
+                StreamIndex::new(remote.get_integer(tp_const::INITIAL_MAX_STREAMS_BIDI));
             self.indexes.remote_max_stream_uni =
-                StreamIndex::new(tps.get_integer(tp_const::INITIAL_MAX_STREAMS_UNI));
+                StreamIndex::new(remote.get_integer(tp_const::INITIAL_MAX_STREAMS_UNI));
             self.flow_mgr
                 .borrow_mut()
-                .conn_increase_max_credit(tps.get_integer(tp_const::INITIAL_MAX_DATA));
+                .conn_increase_max_credit(remote.get_integer(tp_const::INITIAL_MAX_DATA));
         }
         mem::replace(&mut self.tps, swapped);
     }
@@ -1330,8 +1330,8 @@ impl Connection {
         for acked in acked_packets {
             for token in acked.tokens {
                 match token {
-                    RecoveryToken::Ack(at) => self.acks.acked(at),
-                    RecoveryToken::Stream(st) => self.send_streams.acked(st),
+                    RecoveryToken::Ack(at) => self.acks.acked(&at),
+                    RecoveryToken::Stream(st) => self.send_streams.acked(&st),
                     RecoveryToken::Crypto(ct) => self.crypto.acked(ct),
                     RecoveryToken::Flow(ft) => {
                         self.flow_mgr.borrow_mut().acked(ft, &mut self.send_streams)
@@ -1343,7 +1343,7 @@ impl Connection {
             for token in lost.tokens {
                 match token {
                     RecoveryToken::Ack(_) => {}
-                    RecoveryToken::Stream(st) => self.send_streams.lost(st),
+                    RecoveryToken::Stream(st) => self.send_streams.lost(&st),
                     RecoveryToken::Crypto(ct) => self.crypto.lost(ct),
                     RecoveryToken::Flow(ft) => self.flow_mgr.borrow_mut().lost(
                         ft,
@@ -1371,7 +1371,7 @@ impl Connection {
             for token in dropped.tokens {
                 match token {
                     RecoveryToken::Ack(_) => {}
-                    RecoveryToken::Stream(st) => self.send_streams.lost(st),
+                    RecoveryToken::Stream(st) => self.send_streams.lost(&st),
                     RecoveryToken::Crypto(ct) => self.crypto.lost(ct),
                     RecoveryToken::Flow(ft) => self.flow_mgr.borrow_mut().lost(
                         ft,
@@ -1743,7 +1743,7 @@ impl Connection {
                     for token in lost.tokens {
                         match token {
                             RecoveryToken::Ack(_) => {} // Do nothing
-                            RecoveryToken::Stream(st) => self.send_streams.lost(st),
+                            RecoveryToken::Stream(st) => self.send_streams.lost(&st),
                             RecoveryToken::Crypto(ct) => self.crypto.lost(ct),
                             RecoveryToken::Flow(ft) => self.flow_mgr.borrow_mut().lost(
                                 ft,

diff --git a/neqo-transport/src/crypto.rs b/neqo-transport/src/crypto.rs
--- a/neqo-transport/src/crypto.rs
+++ b/neqo-transport/src/crypto.rs
@@ -62,6 +62,9 @@ impl Crypto {
 
     // Create the initial crypto state.
     pub fn create_initial_state(&mut self, role: Role, dcid: &[u8]) -> CryptoState {
+        const CLIENT_INITIAL_LABEL: &str = "client in";
+        const SERVER_INITIAL_LABEL: &str = "server in";
+
         qinfo!(
             [self]
             "Creating initial cipher state role={:?} dcid={}",
@@ -69,8 +72,6 @@ impl Crypto {
             hex(dcid)
         );
 
-        const CLIENT_INITIAL_LABEL: &str = "client in";
-        const SERVER_INITIAL_LABEL: &str = "server in";
         let (write_label, read_label) = match role {
             Role::Client => (CLIENT_INITIAL_LABEL, SERVER_INITIAL_LABEL),
             Role::Server => (SERVER_INITIAL_LABEL, CLIENT_INITIAL_LABEL),
@@ -231,11 +232,11 @@ impl CryptoDxState {
         label: S,
         dcid: &[u8],
     ) -> Option<CryptoDxState> {
-        let cipher = TLS_AES_128_GCM_SHA256;
         const INITIAL_SALT: &[u8] = &[
             0x7f, 0xbc, 0xdb, 0x0e, 0x7c, 0x66, 0xbb, 0xe9, 0x19, 0x3a, 0x96, 0xcd, 0x21, 0x51,
             0x9e, 0xbd, 0x7a, 0x02, 0x64, 0x4a,
         ];
+        let cipher = TLS_AES_128_GCM_SHA256;
         let initial_secret = hkdf::extract(
             TLS_VERSION_1_3,
             cipher,

diff --git a/neqo-transport/src/dump.rs b/neqo-transport/src/dump.rs
--- a/neqo-transport/src/dump.rs
+++ b/neqo-transport/src/dump.rs
@@ -12,6 +12,7 @@ use crate::frame::decode_frame;
 use crate::packet::PacketHdr;
 use neqo_common::{qdebug, Decoder};
 
+#[allow(clippy::module_name_repetitions)]
 pub fn dump_packet(conn: &Connection, dir: &str, hdr: &PacketHdr, payload: &[u8]) {
     let mut s = String::from("");
     let mut d = Decoder::from(payload);

diff --git a/neqo-transport/src/events.rs b/neqo-transport/src/events.rs
--- a/neqo-transport/src/events.rs
+++ b/neqo-transport/src/events.rs
@@ -45,6 +45,7 @@ pub enum ConnectionEvent {
 }
 
 #[derive(Debug, Default, Clone)]
+#[allow(clippy::module_name_repetitions)]
 pub struct ConnectionEvents {
     events: Rc<RefCell<BTreeSet<ConnectionEvent>>>,
 }

diff --git a/neqo-transport/src/frame.rs b/neqo-transport/src/frame.rs
--- a/neqo-transport/src/frame.rs
+++ b/neqo-transport/src/frame.rs
@@ -12,6 +12,7 @@ use crate::stream_id::StreamIndex;
 use crate::{AppError, TransportError};
 use crate::{ConnectionError, Error, Res};
 
+#[allow(clippy::module_name_repetitions)]
 pub type FrameType = u64;
 
 const FRAME_TYPE_PADDING: FrameType = 0x0;
@@ -90,8 +91,7 @@ impl CloseError {
 
     fn code(&self) -> u64 {
         match self {
-            CloseError::Transport(c) => *c,
-            CloseError::Application(c) => *c,
+            CloseError::Transport(c) | CloseError::Application(c) => *c,
         }
     }
 }
@@ -232,8 +232,7 @@ impl Frame {
         enc.encode_varint(self.get_type());
 
         match self {
-            Frame::Padding => (),
-            Frame::Ping => (),
+            Frame::Padding | Frame::Ping => (),
             Frame::Ack {
                 largest_acknowledged,
                 ack_delay,
@@ -369,10 +368,10 @@ impl Frame {
         if !ack_ranges.is_empty() && largest_acked < first_ack_range + 1 {
             return Err(Error::FrameEncodingError);
         }
-        let mut cur = if !ack_ranges.is_empty() {
-            largest_acked - first_ack_range - 1
-        } else {
+        let mut cur = if ack_ranges.is_empty() {
             0
+        } else {
+            largest_acked - first_ack_range - 1
         };
         for r in ack_ranges {
             if cur < r.gap + 1 {
@@ -420,6 +419,7 @@ impl Frame {
     }
 }
 
+#[allow(clippy::module_name_repetitions)]
 pub fn decode_frame(dec: &mut Decoder) -> Res<Frame> {
     macro_rules! d {
         ($d:expr) => {
@@ -495,18 +495,18 @@ pub fn decode_frame(dec: &mut Decoder) -> Res<Frame> {
         }
         FRAME_TYPE_STREAM..=FRAME_TYPE_STREAM_MAX => {
             let s = dv!(dec);
-            let o = if t & STREAM_FRAME_BIT_OFF != 0 {
-                dv!(dec)
-            } else {
+            let o = if t & STREAM_FRAME_BIT_OFF == 0 {
                 0
+            } else {
+                dv!(dec)
             };
             qdebug!("STREAM {}", t);
-            let data = if (t & STREAM_FRAME_BIT_LEN) != 0 {
-                qdebug!("STREAM frame has a length");
-                d!(dec.decode_vvec())
-            } else {
+            let data = if (t & STREAM_FRAME_BIT_LEN) == 0 {
                 qdebug!("STREAM frame extends to the end of the packet");
                 dec.decode_remainder()
+            } else {
+                qdebug!("STREAM frame has a length");
+                d!(dec.decode_vvec())
             };
             Ok(Frame::Stream {
                 fin: (t & STREAM_FRAME_BIT_FIN) != 0,

diff --git a/neqo-transport/src/lib.rs b/neqo-transport/src/lib.rs
--- a/neqo-transport/src/lib.rs
+++ b/neqo-transport/src/lib.rs
@@ -36,6 +36,7 @@ pub const QUIC_VERSION: u32 = 0xff00_0016;
 type TransportError = u64;
 
 #[derive(Clone, Debug, PartialEq, PartialOrd, Ord, Eq)]
+#[allow(clippy::pub_enum_variant_names)]
 pub enum Error {
     NoError,
     InternalError,
@@ -50,6 +51,7 @@ pub enum Error {
     InvalidMigration,
     CryptoError(neqo_crypto::Error),
     CryptoAlert(u8),
+    TypeError,
     NoMoreData,
     TooMuchData,
     UnknownFrameType,
@@ -74,7 +76,6 @@ impl Error {
     pub fn code(&self) -> TransportError {
         match self {
             Error::NoError => 0,
-            Error::InternalError => 1,
             Error::ServerBusy => 2,
             Error::FlowControlError => 3,
             Error::StreamLimitError => 4,
@@ -88,6 +89,7 @@ impl Error {
             Error::PeerError(a) => *a,
             // TODO(ekr@rtfm.com): Map these errors.
             Error::CryptoError(_)
+            | Error::TypeError
             | Error::NoMoreData
             | Error::TooMuchData
             | Error::UnknownFrameType
@@ -104,7 +106,8 @@ impl Error {
             | Error::WrongRole
             | Error::InvalidResumptionToken
             | Error::InvalidInput
-            | Error::IdleTimeout => 1,
+            | Error::IdleTimeout
+            | Error::InternalError => 1,
         }
     }
 }
@@ -116,6 +119,13 @@ impl From<neqo_crypto::Error> for Error {
     }
 }
 
+impl From<std::num::TryFromIntError> for Error {
+    fn from(err: std::num::TryFromIntError) -> Self {
+        qinfo!("Type decode to u16 failed {:?}", err);
+        Error::TypeError
+    }
+}
+
 impl ::std::error::Error for Error {
     fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
         match self {

diff --git a/neqo-transport/src/packet.rs b/neqo-transport/src/packet.rs
--- a/neqo-transport/src/packet.rs
+++ b/neqo-transport/src/packet.rs
@@ -6,6 +6,9 @@
 
 // Encoding and decoding packets off the wire.
 
+// A lot of methods and types contain the word Packet
+#![allow(clippy::module_name_repetitions)]
+
 use derive_more::Deref;
 use rand::Rng;
 
@@ -38,7 +41,7 @@ pub enum PacketType {
 }
 
 impl Default for PacketType {
-    fn default() -> PacketType {
+    fn default() -> Self {
         PacketType::Short
     }
 }
@@ -62,11 +65,11 @@ pub type PacketNumber = u64;
 pub struct ConnectionId(pub Vec<u8>);
 
 impl ConnectionId {
-    pub fn generate(len: usize) -> ConnectionId {
+    pub fn generate(len: usize) -> Self {
         assert!(matches!(len, 4..=18));
         let mut v = vec![0; len];
         rand::thread_rng().fill(&mut v[..]);
-        ConnectionId(v)
+        Self(v)
     }
 }
 
@@ -83,6 +86,7 @@ impl ::std::fmt::Display for ConnectionId {
 }
 
 #[derive(Default, Debug)]
+#[allow(clippy::module_name_repetitions)]
 pub struct PacketHdr {
     pub tbyte: u8,
     pub tipe: PacketType,
@@ -96,6 +100,9 @@ pub struct PacketHdr {
 }
 
 impl PacketHdr {
+    // Similar names are allowed here because
+    // dcid and scid are defined and commonly used in the spec.
+    #[allow(clippy::similar_names)]
     pub fn new(
         tbyte: u8,
         tipe: PacketType,
@@ -104,8 +111,8 @@ impl PacketHdr {
         scid: Option<ConnectionId>,
         pn: PacketNumber,
         epoch: Epoch,
-    ) -> PacketHdr {
-        PacketHdr {
+    ) -> Self {
+        Self {
             tbyte,
             tipe,
             version,
@@ -137,16 +144,16 @@ pub struct PacketNumberDecoder {
     expected: u64,
 }
 impl PacketNumberDecoder {
-    pub fn new(largest_acknowledged: Option<u64>) -> PacketNumberDecoder {
-        PacketNumberDecoder {
-            expected: largest_acknowledged.map(|x| x + 1).unwrap_or(0),
+    pub fn new(largest_acknowledged: Option<u64>) -> Self {
+        Self {
+            expected: largest_acknowledged.map_or(0, |x| x + 1),
         }
     }
 
     // TODO(mt) test this.  It's a strict implementation of the spec,
     // but that doesn't mean we shouldn't test it.
     fn decode_pn(&self, pn: u64, w: usize) -> PacketNumber {
-        let window = 1u64 << (w * 8);
+        let window = 1_u64 << (w * 8);
         let candidate = (self.expected & !(window - 1)) | pn;
         if candidate + (window / 2) <= self.expected {
             candidate + window
@@ -398,7 +405,7 @@ fn encode_packet_vn(hdr: &PacketHdr, vers: &[u32]) -> Vec<u8> {
     let mut rand_byte: [u8; 1] = [0; 1];
     rand::thread_rng().fill(&mut rand_byte);
     d.encode_byte(PACKET_BIT_LONG | rand_byte[0]);
-    d.encode_uint(4, 0u64); // version
+    d.encode_uint(4, 0_u64); // version
     d.encode_vec(1, &hdr.dcid);
     d.encode_vec(1, hdr.scid.as_ref().unwrap());
     for ver in vers {

diff --git a/neqo-transport/src/recovery.rs b/neqo-transport/src/recovery.rs
--- a/neqo-transport/src/recovery.rs
+++ b/neqo-transport/src/recovery.rs
@@ -440,7 +440,7 @@ impl LossRecovery {
             (LossRecoveryMode::LostPackets, Some(earliest_time))
         } else {
             // Calculate PTO duration
-            let timeout = self.rtt_vals.pto() * 2u32.pow(self.pto_count);
+            let timeout = self.rtt_vals.pto() * 2_u32.pow(self.pto_count);
             (
                 LossRecoveryMode::PTO,
                 self.time_of_last_sent_ack_eliciting_packet

diff --git a/neqo-transport/src/recv_stream.rs b/neqo-transport/src/recv_stream.rs
--- a/neqo-transport/src/recv_stream.rs
+++ b/neqo-transport/src/recv_stream.rs
@@ -10,6 +10,7 @@
 use std::cell::RefCell;
 use std::cmp::{max, min};
 use std::collections::BTreeMap;
+use std::convert::TryInto;
 use std::mem;
 use std::ops::Bound::{Included, Unbounded};
 use std::rc::Rc;
@@ -177,8 +178,7 @@ impl RxStreamOrderer {
         self.data_ranges
             .keys()
             .next()
-            .map(|&start| start <= self.retired)
-            .unwrap_or(false)
+            .map_or(false, |&start| start <= self.retired)
     }
 
     /// How many bytes are readable?
@@ -230,9 +230,9 @@ impl RxStreamOrderer {
 
                 // Convert to offset into data vec and move past bytes we
                 // already have
-                let copy_offset = (max(range_start, self.retired) - range_start) as usize;
-                let copy_bytes = min(range_data.len() - copy_offset as usize, buf_remaining);
-                let copy_slc = &mut range_data[copy_offset as usize..copy_offset + copy_bytes];
+                let copy_offset = (max(range_start, self.retired) - range_start).try_into()?;
+                let copy_bytes = min(range_data.len() - copy_offset, buf_remaining);
+                let copy_slc = &mut range_data[copy_offset..copy_offset + copy_bytes];
                 buf[copied..copied + copy_bytes].copy_from_slice(copy_slc);
                 copied += copy_bytes;
                 buf_remaining -= copy_bytes;
@@ -294,7 +294,7 @@ enum RecvStreamState {
 }
 
 impl RecvStreamState {
-    fn new(max_bytes: u64) -> RecvStreamState {
+    fn new(max_bytes: u64) -> Self {
         RecvStreamState::Recv {
             recv_buf: RxStreamOrderer::new(),
             max_bytes,
@@ -314,9 +314,9 @@ impl RecvStreamState {
 
     fn recv_buf(&self) -> Option<&RxStreamOrderer> {
         match self {
-            RecvStreamState::Recv { recv_buf, .. } => Some(recv_buf),
-            RecvStreamState::SizeKnown { recv_buf, .. } => Some(recv_buf),
-            RecvStreamState::DataRecvd { recv_buf } => Some(recv_buf),
+            RecvStreamState::Recv { recv_buf, .. }
+            | RecvStreamState::SizeKnown { recv_buf, .. }
+            | RecvStreamState::DataRecvd { recv_buf } => Some(recv_buf),
             RecvStreamState::DataRead | RecvStreamState::ResetRecvd => None,
         }
     }
@@ -328,7 +328,7 @@ impl RecvStreamState {
         }
     }
 
-    fn transition(&mut self, new_state: RecvStreamState) {
+    fn transition(&mut self, new_state: Self) {
         qtrace!("RecvStream state {} -> {}", self.name(), new_state.name());
         *self = new_state;
     }
@@ -349,8 +349,8 @@ impl RecvStream {
         max_stream_data: u64,
         flow_mgr: Rc<RefCell<FlowMgr>>,
         conn_events: ConnectionEvents,
-    ) -> RecvStream {
-        RecvStream {
+    ) -> Self {
+        Self {
             stream_id,
             state: RecvStreamState::new(max_stream_data),
             flow_mgr,
@@ -379,9 +379,7 @@ impl RecvStream {
                     return Err(Error::FlowControlError);
                 }
 
-                if !fin {
-                    recv_buf.inbound_frame(offset, data)?;
-                } else {
+                if fin {
                     let final_size = offset + data.len() as u64;
                     if final_size < recv_buf.highest_seen_offset() {
                         return Err(Error::FinalSizeError);
@@ -398,6 +396,8 @@ impl RecvStream {
                             final_size,
                         });
                     }
+                } else {
+                    recv_buf.inbound_frame(offset, data)?;
                 }
             }
             RecvStreamState::SizeKnown {
@@ -481,8 +481,7 @@ impl RecvStream {
     fn data_ready(&self) -> bool {
         self.state
             .recv_buf()
-            .map(RxStreamOrderer::data_ready)
-            .unwrap_or(false)
+            .map_or(false, RxStreamOrderer::data_ready)
     }
 
     pub fn read(&mut self, buf: &mut [u8]) -> Res<(u64, bool)> {

diff --git a/neqo-transport/src/send_stream.rs b/neqo-transport/src/send_stream.rs
--- a/neqo-transport/src/send_stream.rs
+++ b/neqo-transport/src/send_stream.rs
@@ -9,6 +9,7 @@
 use std::cell::RefCell;
 use std::cmp::{max, min};
 use std::collections::{hash_map::IterMut, BTreeMap, HashMap};
+use std::convert::{TryFrom, TryInto};
 use std::mem;
 use std::rc::Rc;
 
@@ -45,16 +46,14 @@ impl RangeTracker {
         self.used
             .range(..)
             .next_back()
-            .map(|(k, (v, _))| *k + *v)
-            .unwrap_or(0)
+            .map_or(0, |(k, (v, _))| *k + *v)
     }
 
     fn acked_from_zero(&self) -> u64 {
         self.used
             .get(&0)
             .filter(|(_, state)| *state == RangeState::Acked)
-            .map(|(v, _)| *v)
-            .unwrap_or(0)
+            .map_or(0, |(v, _)| *v)
     }
 
     /// Find the first unmarked range. If all are contiguous, this will return
@@ -283,10 +282,10 @@ pub struct TxBuffer {
 }
 
 impl TxBuffer {
-    pub fn new() -> TxBuffer {
-        TxBuffer {
+    pub fn new() -> Self {
+        Self {
             send_buf: SliceDeque::with_capacity(TX_STREAM_BUFFER),
-            ..TxBuffer::default()
+            ..Self::default()
         }
     }
 
@@ -302,15 +301,25 @@ impl TxBuffer {
 
     pub fn next_bytes(&self, _mode: TxMode) -> Option<(u64, &[u8])> {
         let (start, maybe_len) = self.ranges.first_unmarked_range();
-
-        if start == self.retired + self.buffered() as u64 {
-            return None;
-        }
-
-        let buff_off = (start - self.retired) as usize;
-        match maybe_len {
-            Some(len) => Some((start, &self.send_buf[buff_off..buff_off + len as usize])),
-            None => Some((start, &self.send_buf[buff_off..])),
+        match (usize::try_from(start), usize::try_from(self.retired)) {
+            (Ok(s), Ok(retired)) => {
+                if s == retired + self.buffered() {
+                    return None;
+                }
+                debug_assert!(s >= retired);
+                let buff_off = s - retired;
+                // Unwrap is safe here because we checked if maybe_len.is_some() beforehand
+                if maybe_len.is_some() {
+                    if let Ok(len) = usize::try_from(maybe_len.unwrap()) {
+                        Some((start, &self.send_buf[buff_off..buff_off + len]))
+                    } else {
+                        Some((start, &self.send_buf[buff_off..]))
+                    }
+                } else {
+                    Some((start, &self.send_buf[buff_off..]))
+                }
+            }
+            _ => None,
         }
     }
 
@@ -325,10 +334,12 @@ impl TxBuffer {
 
         // We can drop contig acked range from the buffer
         let new_retirable = self.ranges.acked_from_zero() - self.retired;
-        if new_retirable > 0 {
-            let keep_len = self.buffered() - new_retirable as usize;
+        if let Ok(nr) = usize::try_from(new_retirable) {
+            let keep_len: usize = self.buffered() - nr;
             self.send_buf.truncate_front(keep_len);
             self.retired += new_retirable;
+        } else {
+            // FIXME: What do we want to do here ?
         }
     }
 
@@ -379,8 +390,9 @@ enum SendStreamState {
 impl SendStreamState {
     fn tx_buf(&self) -> Option<&TxBuffer> {
         match self {
-            SendStreamState::Send { send_buf } => Some(send_buf),
-            SendStreamState::DataSent { send_buf, .. } => Some(send_buf),
+            SendStreamState::Send { send_buf } | SendStreamState::DataSent { send_buf, .. } => {
+                Some(send_buf)
+            }
             SendStreamState::Ready
             | SendStreamState::DataRecvd { .. }
             | SendStreamState::ResetSent
@@ -390,8 +402,9 @@ impl SendStreamState {
 
     fn tx_buf_mut(&mut self) -> Option<&mut TxBuffer> {
         match self {
-            SendStreamState::Send { send_buf } => Some(send_buf),
-            SendStreamState::DataSent { send_buf, .. } => Some(send_buf),
+            SendStreamState::Send { send_buf } | SendStreamState::DataSent { send_buf, .. } => {
+                Some(send_buf)
+            }
             SendStreamState::Ready
             | SendStreamState::DataRecvd { .. }
             | SendStreamState::ResetSent
@@ -401,8 +414,8 @@ impl SendStreamState {
 
     fn final_size(&self) -> Option<u64> {
         match self {
-            SendStreamState::DataSent { final_size, .. } => Some(*final_size),
-            SendStreamState::DataRecvd { final_size } => Some(*final_size),
+            SendStreamState::DataSent { final_size, .. }
+            | SendStreamState::DataRecvd { final_size } => Some(*final_size),
             SendStreamState::Ready
             | SendStreamState::Send { .. }
             | SendStreamState::ResetSent
@@ -421,7 +434,7 @@ impl SendStreamState {
         }
     }
 
-    fn transition(&mut self, new_state: SendStreamState) {
+    fn transition(&mut self, new_state: Self) {
         qtrace!("SendStream state {} -> {}", self.name(), new_state.name());
         *self = new_state;
     }
@@ -443,11 +456,11 @@ impl SendStream {
         max_stream_data: u64,
         flow_mgr: Rc<RefCell<FlowMgr>>,
         conn_events: ConnectionEvents,
-    ) -> SendStream {
+    ) -> Self {
         if max_stream_data > 0 {
             conn_events.send_stream_writable(stream_id);
         }
-        SendStream {
+        Self {
             stream_id,
             max_stream_data,
             state: SendStreamState::Ready,
@@ -469,11 +482,11 @@ impl SendStream {
                 if bytes.is_some() {
                     // Must be a resend
                     bytes
-                } else if !fin_sent {
+                } else if fin_sent {
+                    None
+                } else {
                     // Send empty stream frame with fin set
                     Some((final_size, &[]))
-                } else {
-                    None
                 }
             }
             SendStreamState::Ready
@@ -547,8 +560,7 @@ impl SendStream {
     pub fn credit_avail(&self) -> u64 {
         self.state
             .tx_buf()
-            .map(|tx| self.max_stream_data - tx.data_limit())
-            .unwrap_or(0)
+            .map_or(0, |tx| self.max_stream_data - tx.data_limit())
     }
 
     /// Bytes sendable on stream. Constrained by both stream credit available
@@ -556,8 +568,7 @@ impl SendStream {
     pub fn avail(&self) -> u64 {
         self.state
             .tx_buf()
-            .map(|tx| min(self.credit_avail(), tx.avail() as u64))
-            .unwrap_or(0)
+            .map_or(0, |tx| min(self.credit_avail(), tx.avail() as u64))
     }
 
     pub fn max_stream_data(&self) -> u64 {
@@ -603,7 +614,7 @@ impl SendStream {
         let stream_credit_avail = self.credit_avail();
         let conn_credit_avail = self.flow_mgr.borrow().conn_credit_avail();
         let credit_avail = min(stream_credit_avail, conn_credit_avail);
-        let buff_avail = self.state.tx_buf().map(|tx| tx.avail()).unwrap_or(0);
+        let buff_avail = self.state.tx_buf().map_or(0, TxBuffer::avail);
         let space_avail = min(credit_avail, buff_avail as u64);
         let can_send_bytes = min(space_avail, buf.len() as u64);
 
@@ -611,7 +622,7 @@ impl SendStream {
             return Ok(0);
         }
 
-        let buf = &buf[..can_send_bytes as usize];
+        let buf = &buf[..can_send_bytes.try_into()?];
 
         let sent = match &mut self.state {
             SendStreamState::Ready => unreachable!(),
@@ -699,9 +710,9 @@ impl SendStreams {
         self.0.insert(id, stream);
     }
 
-    pub fn acked(&mut self, token: StreamRecoveryToken) {
+    pub fn acked(&mut self, token: &StreamRecoveryToken) {
         if let Some(ss) = self.0.get_mut(&token.id) {
-            ss.mark_as_acked(token.offset, token.length as usize, token.fin);
+            ss.mark_as_acked(token.offset, token.length, token.fin);
         }
     }
 
@@ -711,9 +722,13 @@ impl SendStreams {
         }
     }
 
-    pub fn lost(&mut self, token: StreamRecoveryToken) {
+    pub fn lost(&mut self, token: &StreamRecoveryToken) {
         if let Some(ss) = self.0.get_mut(&token.id) {
-            ss.mark_as_lost(token.offset, token.length as usize, token.fin);
+            if let Ok(len) = token.length.try_into() {
+                ss.mark_as_lost(token.offset, len, token.fin);
+            } else {
+                //FIXME: Do we want to log something?
+            }
         }
     }
 
@@ -748,24 +763,24 @@ impl SendStreams {
                     remaining
                 );
                 let frame_hdr_len = stream_frame_hdr_len(*stream_id, offset, remaining);
-                let data_len = min(data.len(), remaining - frame_hdr_len);
+                let length = min(data.len(), remaining - frame_hdr_len);
                 let fin = match fin {
                     None => false,
-                    Some(fin) => fin == offset + data_len as u64,
+                    Some(fin) => fin == offset + length as u64,
                 };
                 let frame = Frame::Stream {
                     fin,
                     stream_id: stream_id.as_u64(),
                     offset,
-                    data: data[..data_len].to_vec(),
+                    data: data[..length].to_vec(),
                 };
-                stream.mark_as_sent(offset, data_len, fin);
+                stream.mark_as_sent(offset, length, fin);
                 return Some((
                     frame,
                     Some(RecoveryToken::Stream(StreamRecoveryToken {
                         id: *stream_id,
                         offset,
-                        length: data_len as u64,
+                        length,
                         fin,
                     })),
                 ));
@@ -800,7 +815,7 @@ fn stream_frame_hdr_len(stream_id: StreamId, offset: u64, remaining: usize) -> u
 pub(crate) struct StreamRecoveryToken {
     pub(crate) id: StreamId,
     offset: u64,
-    length: u64,
+    length: usize,
     fin: bool,
 }

diff --git a/neqo-transport/src/server.rs b/neqo-transport/src/server.rs
--- a/neqo-transport/src/server.rs
+++ b/neqo-transport/src/server.rs
@@ -39,7 +39,7 @@ impl Server {
         ConnectionId::generate(self.cidlen)
     }
 
-    pub fn check_retry(&self, received: Datagram) -> Res<RetryResult> {
+    pub fn check_retry(&self, received: &Datagram) -> Res<RetryResult> {
         qinfo!("Generating a Retry packet");
         qtrace!("Received packet: {}", hex(&received[..]));

diff --git a/neqo-transport/src/stream_id.rs b/neqo-transport/src/stream_id.rs
--- a/neqo-transport/src/stream_id.rs
+++ b/neqo-transport/src/stream_id.rs
@@ -23,8 +23,8 @@ pub struct StreamIndexes {
 }
 
 impl StreamIndexes {
-    pub fn new() -> StreamIndexes {
-        StreamIndexes {
+    pub fn new() -> Self {
+        Self {
             local_max_stream_bidi: StreamIndex::new(LOCAL_STREAM_LIMIT_BIDI),
             local_max_stream_uni: StreamIndex::new(LOCAL_STREAM_LIMIT_UNI),
             local_next_stream_uni: StreamIndex::new(0),
@@ -100,7 +100,7 @@ impl StreamId {
 
 impl From<u64> for StreamId {
     fn from(val: u64) -> Self {
-        StreamId(val)
+        Self(val)
     }
 }
 
@@ -108,8 +108,8 @@ impl From<u64> for StreamId {
 pub struct StreamIndex(u64);
 
 impl StreamIndex {
-    pub fn new(val: u64) -> StreamIndex {
-        StreamIndex(val)
+    pub fn new(val: u64) -> Self {
+        Self(val)
     }
 
     pub fn to_stream_id(self, stream_type: StreamType, role: Role) -> StreamId {
@@ -132,12 +132,12 @@ impl StreamIndex {
 
 impl From<StreamId> for StreamIndex {
     fn from(val: StreamId) -> Self {
-        StreamIndex(val.as_u64() >> 2)
+        Self(val.as_u64() >> 2)
     }
 }
 
 impl AddAssign<u64> for StreamIndex {
     fn add_assign(&mut self, other: u64) {
-        *self = StreamIndex::new(self.as_u64() + other)
+        *self = Self::new(self.as_u64() + other)
     }
 }


</patch>

Function signatures
<Signatures>
fn agent_write(
mut fd: PrFd,
buf: *const c_void,
amount: prio::PRInt32) -> PrStatus

fn agent_close(fd: PrFd) -> PrStatus

fn agent_recv(
mut fd: PrFd,
buf: *mut c_void,
amount: prio::PRInt32,
flags: prio::PRIntn,
_timeout: prio::PRIntervalTime) -> prio::PRInt32

fn agent_send(
mut fd: PrFd,
buf: *const c_void,
amount: prio::PRInt32,
flags: prio::PRIntn,
_timeout: prio::PRIntervalTime) -> prio::PRInt32

fn stapled_ocsp_responses(fd: *mut PRFileDesc) -> Option<Vec<Vec<u8>>>

pub fn stapled_ocsp_responses(&mut self) -> &Option<Vec<Vec<u8>>>

fn signed_cert_timestamp(fd: *mut PRFileDesc) -> Option<Vec<u8>>

pub fn signed_cert_timestamp(&mut self) -> &Option<Vec<u8>>

fn peer_certificate_chain(fd: *mut PRFileDesc) -> Option<(CertList, *const CERTCertListNode)>

pub fn init() -> ()

fn init() -> ()

pub fn decode_frame(dec: &mut Decoder) -> Res<Frame>

fn encode_packet_vn(hdr: &PacketHdr, vers: &[u32]) -> Vec<u8>

fn stream_frame_hdr_len(stream_id: StreamId, offset: u64, remaining: usize) -> usize
</Signatures>

You are a software tester at neqo and your are reviewing the above <patch> for the above <issue>
Identify whether a unit test is needed.
If there is no test needed or you believe you need additional testing resources beyond the Rust standard library (e.g., mocking libraries) to write a useful unit test, return <NO>.
If a test is needed, your task is:
1. Write exactly one rust test `#[test]fn test_...(){...}` block. Do NOT wrap the test inside a 'mod tests' block.
If the file you are adding the test already contains a test in the <patch>, ensure that the test name is unique.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. All 'use' declarations must be inside a <imports>...</imports> block. Additionally:
   - Do not use group imports.
  - Import only what is necessary for the test to run and make sure not to have colliding imports.
  - If the <patch> contains a 'mod tests' block with useful imports, do not add them to the <imports> block.
  - Use `use super::<function name> for the function under test.
.  - If multiple 'use' statements are needed, list each on a separate line.
5. To help you write the test, <Signatures> contains all modified function's:
  - name
  - parameters
  - Return type (assume '()' if empty)
6. Return only the absolute filename as it is in the <patch> block, the use statements, and rust test (no comments or explanations).

Here is an example structure:
<Filename> ... </Filename>
<imports> ... </imports>
<Rust>
#[test]
fn test_<describe_behavior>() {
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
}</Rust>

