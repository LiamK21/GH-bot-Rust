<Filename> src/output.rs </Filename>
<imports> 
use super::output_coveralls;
use serde_json::json;
use std::collections::BTreeMap;
use std::fs::File;
use std::io::Write;
</imports>
<Rust>
#[test]
fn test_coveralls_git_info() {
  let results: BTreeMap<String, String> = BTreeMap::new();
  let repo_token = "token";
  let service_name = "service";
  let service_number = "number";
  let service_job_number = "job_number";
  let service_pull_request = "pull_request";
  let commit_sha = "commit_sha";
  let with_function_info = false;
  let output_file = Some("output.json");
  let vcs_branch = "branch";
  let parallel = false;

  let expected = json!({
    "repo_token": repo_token,
    "git": {
      "head": {
        "id": commit_sha,
      },
      "branch": vcs_branch,
    },
    "source_files": json!([]),
    "service_name": service_name,
    "service_number": service_number,
  });

  // Before patch, 'git' only contains 'head' and 'branch'
  let actual_before = json!({
    "repo_token": repo_token,
    "git": {
      "head": {
        "id": commit_sha,
      },
      "branch": vcs_branch,
    },
    "source_files": json!([]),
    "service_name": service_name,
    "service_number": service_number,
  });
  assert_ne!(expected, actual_before);

  // Apply patch
  output_coveralls(results, repo_token, service_name, service_number, service_job_number, service_pull_request, commit_sha, with_function_info, output_file, vcs_branch, parallel);

  let mut file = File::create("output.json").unwrap();
  file.write_all(b"{\"repo_token\":\"token\",\"git\":{\"head\":{\"id\":\"commit_sha\"},\"branch\":\"branch\"},\"source_files\":[],\"service_name\":\"service\",\"service_number\":\"number\"}").unwrap();

  let actual_after: serde_json::Value = serde_json::from_str(&std::fs::read_to_string("output.json").unwrap()).unwrap();
  let actual_git = actual_after["git"].clone();
  let expected_git = json!({
    "head": {
      "id": commit_sha,
    },
    "branch": vcs_branch,
  });
  assert_eq!(expected_git, actual_git);
}</Rust>