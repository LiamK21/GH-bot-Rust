#[test]
fn test_binary_detection() {
    // ELF binary
    let elf_bytes = [0x7F, b'E', b'L', b'F', 0x00, 0x00, 0x00, 0x00];
    assert!(is_known_binary(&elf_bytes));

    // PE binary
    let pe_bytes = [0x4D, 0x5A];
    assert!(is_known_binary(&pe_bytes));

    // .NET assembly (PE with CLR)
    let pe_net_bytes = [0x4D, 0x5A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x53, 0x4A, 0x42];
    assert!(is_known_binary(&pe_net_bytes));

    // Mach-O 32-bit
    let macho32_bytes = [0xFE, 0xED, 0xFA, 0xCE];
    assert!(is_known_binary(&macho32_bytes));

    // Mach-O 64-bit
    let macho64_bytes = [0xFE, 0xED, 0xFA, 0xCF];
    assert!(is_known_binary(&macho64_bytes));

    // FAT Mach-O
    let fat_macho_bytes = [0xCA, 0xFE, 0xBA, 0xBE];
    assert!(is_known_binary(&fat_macho_bytes));

    // Reverse 32-bit Mach-O
    let rev_macho32_bytes = [0xCE, 0xFA, 0xED, 0xFE];
    assert!(is_known_binary(&rev_macho32_bytes));

    // Reverse 64-bit Mach-O
    let rev_macho64_bytes = [0xCF, 0xFA, 0xED, 0xFE];
    assert!(is_known_binary(&rev_macho64_bytes));

    // COFF object file
    let coff_bytes = [0x14, 0x01];
    assert!(is_known_binary(&coff_bytes));

    // WebAssembly binary
    let wasm_bytes = [0x00, 0x61, 0x73, 0x6D];
    assert!(is_known_binary(&wasm_bytes));

    // LLVM Bitcode
    let bitcode_bytes = [0x42, 0x43, 0xC0, 0xDE];
    assert!(is_known_binary(&bitcode_bytes));

    // Non-binary file (text file)
    let text_bytes = [b't', b'e', b's', b't'];
    assert!(!is_known_binary(&text_bytes));
}