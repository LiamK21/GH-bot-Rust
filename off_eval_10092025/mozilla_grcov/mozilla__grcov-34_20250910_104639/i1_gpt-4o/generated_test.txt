#[test]
fn test_output_coveralls_with_function_info() {
    let results = vec![(
        PathBuf::from("src/lib.rs"),
        "src/lib.rs".to_string(),
        CovResult {
            coverage: vec![Some(1), Some(0), None],
            branches: vec![(1, 0, true), (2, 0, false)],
            functions: HashMap::from([
                ("foo".to_string(), FunctionCoverage { start: 1, executed: 1 }),
                ("bar".to_string(), FunctionCoverage { start: 2, executed: 0 }),
            ]),
        },
    )];
    let repo_token = "dummy_token";
    let service_name = "dummy_service";
    let service_number = "123";
    let service_job_number = "456";
    let commit_sha = "abcdef";

    let mut output = Vec::new();
    {
        let stdout = std::io::stdout();
        let handle = stdout.lock();
        let _ = std::io::set_output_capture(Some(&mut output));
        output_coveralls(results.into_iter(), repo_token, service_name, service_number, service_job_number, commit_sha, true);
        let _ = std::io::set_output_capture(None);
    }

    let expected = json!({
        "repo_token": repo_token,
        "service_name": service_name,
        "service_number": service_number,
        "service_job_number": service_job_number,
        "commit_sha": commit_sha,
        "source_files": [{
            "name": "src/lib.rs",
            "source_digest": "dummy_digest",
            "coverage": [1, 0, null],
            "branches": [1, 0],
            "functions": [
                {"name": "foo", "start": 1, "exec": 1},
                {"name": "bar", "start": 2, "exec": 0}
            ]
        }]
    });

    let actual: serde_json::Value = serde_json::from_slice(&output).unwrap();
    assert_eq!(actual, expected);
}