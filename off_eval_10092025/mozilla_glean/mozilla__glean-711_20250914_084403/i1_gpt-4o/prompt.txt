Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Implement processing of upload response to upload module in glean-core
As described in [the design document](https://docs.google.com/document/d/1YEhrudNl5aHBnht3FCjT66Bj58ckDw3jO-_V56mnqHs/edit?usp=sharing), the upload module should have two main functionalities: get a new ping request, process an upload response.

The "get" part was implemented on [Bug 1605077](https://bugzilla.mozilla.org/show_bug.cgi?id=1605077).
</issue>

Patch:
<patch>
diff --git a/glean-core/src/upload/directory.rs b/glean-core/src/upload/directory.rs
--- a/glean-core/src/upload/directory.rs
+++ b/glean-core/src/upload/directory.rs
@@ -0,0 +1,326 @@
+// This Source Code Form is subject to the terms of the Mozilla Public
+// License, v. 2.0. If a copy of the MPL was not distributed with this
+// file, You can obtain one at https://mozilla.org/MPL/2.0/.
+
+//! Pings directory processing utilities.
+
+use std::cmp::Ordering;
+use std::fs::{self, File};
+use std::io::{BufRead, BufReader};
+use std::path::{Path, PathBuf};
+
+use log;
+use serde_json::Value as JsonValue;
+use uuid::Uuid;
+
+use super::PingRequest;
+use crate::Result;
+
+/// Get the file name from a path as a &str.
+///
+/// # Panics
+///
+/// Won't panic if not able to get file name.
+fn get_file_name_as_str(path: &Path) -> Option<&str> {
+    match path.file_name() {
+        None => {
+            log::warn!("Error getting file name from path: {}", path.display());
+            None
+        }
+        Some(file_name) => {
+            let file_name = file_name.to_str();
+            if file_name.is_none() {
+                log::warn!("File name is not valid unicode: {}", path.display());
+            }
+            file_name
+        }
+    }
+}
+
+/// Manages the pending pings directories.
+#[derive(Debug, Clone)]
+pub struct PingDirectoryManager {
+    /// Path to the pending pings directory.
+    data_path: PathBuf,
+}
+
+impl PingDirectoryManager {
+    /// Creates a new directory manager.
+    ///
+    /// # Arguments
+    ///
+    /// * `data_path` - Path to the pending pings directory.
+    pub fn new<P: Into<PathBuf>>(data_path: P) -> Self {
+        Self {
+            data_path: data_path.into(),
+        }
+    }
+
+    /// Get the pending pings directory path.
+    pub fn get_dir(&self) -> PathBuf {
+        self.data_path.join("pending_pings")
+    }
+
+    /// Attempts to delete a ping file.
+    ///
+    /// ## Arguments
+    ///
+    /// * `uuid` - The UUID of the ping file to be deleted
+    ///
+    /// ## Panics
+    ///
+    /// Won't panic if unable to delete the file.
+    pub fn delete_file(&self, uuid: &str) {
+        let path = self.get_dir().join(uuid);
+        match fs::remove_file(&path) {
+            Err(e) => log::error!("Error deleting file {}. {}", path.display(), e),
+            _ => log::info!("Files was deleted {}", path.display()),
+        };
+    }
+
+    /// Reads a ping file and returns a `PingRequest` from it.
+    ///
+    /// If the file is not properly formatted, it will be deleted and `None` will be returned.
+    ///
+    /// ## Arguments
+    ///
+    /// * `uuid` - The UUID of the ping file to be processed
+    pub fn process_file(&self, uuid: &str) -> Option<PingRequest> {
+        let path = self.get_dir().join(uuid);
+        let file = match File::open(path) {
+            Ok(file) => file,
+            Err(_) => return None,
+        };
+
+        log::info!("Processing ping: {}", uuid);
+
+        // The way the ping file is structured,
+        // first line should always have the url
+        // and second line should have the body with the ping contents in JSON format
+        let mut lines = BufReader::new(file).lines();
+        if let (Some(Ok(url)), Some(Ok(body))) = (lines.next(), lines.next()) {
+            if let Ok(parsed_body) = serde_json::from_str::<JsonValue>(&body) {
+                return Some(PingRequest::new(uuid, &url, parsed_body));
+            } else {
+                log::warn!(
+                    "Error processing ping file: {}. Can't parse ping contents as JSON.",
+                    uuid
+                );
+            }
+        } else {
+            log::warn!(
+                "Error processing ping file: {}. Ping file is not formatted as expected.",
+                uuid
+            );
+        }
+        self.delete_file(uuid);
+        None
+    }
+
+    /// Process the pings directory and return a vector of `PingRequest`s
+    /// corresponding to each valid ping file in the directory.
+    /// This vector will be ordered by file `modified_date`.
+    ///
+    /// Any files that don't match the UUID regex will be deleted
+    /// to prevent files from polluting the pings directory.
+    ///
+    /// Files that are not correctly formatted will also be deleted.
+    ///
+    /// # Return value
+    ///
+    /// `Result<Vec<PingRequest>>` - see [`PingRequest`](struct.PingRequest.html) for more information.
+    ///                              This will only be `Err` in case it is unable to read the pings directory.
+    pub fn process_dir(&self) -> Result<Vec<PingRequest>> {
+        let pings_dir = self.get_dir();
+
+        log::info!("Processing persisted pings at {}", pings_dir.display());
+
+        // Walk the pings directory and process each file in it,
+        // deleting invalid ones and ignoring unreadable ones.
+        // Create a vector of tuples: (modified_date, PingRequest)
+        // using the contents and metadata of all valid files.
+        let mut pending_pings: Vec<_> = pings_dir
+            .read_dir()?
+            .filter_map(|entry| entry.ok())
+            .filter_map(|entry| {
+                let path = entry.path();
+                if let Some(file_name) = get_file_name_as_str(&path) {
+                    // Delete file if it doesn't match the pattern.
+                    if Uuid::parse_str(file_name).is_err() {
+                        log::warn!("Pattern mismatch. Deleting {}", path.display());
+                        self.delete_file(file_name);
+                        return None;
+                    }
+                    // In case we can't process the file we just ignore it.
+                    if let Some(request) = self.process_file(file_name) {
+                        // Get the modified date of the file, which will later be used
+                        // for sorting the resulting vector.
+                        let modified_date = fs::metadata(&path).and_then(|data| data.modified());
+                        return Some((modified_date, request));
+                    }
+                };
+                None
+            })
+            .collect();
+
+        // Sort by `modified_date`.
+        pending_pings.sort_by(|(a, _), (b, _)| {
+            // We might not be able to get the modified date for a given file,
+            // in which case we just put it at the end.
+            if let (Ok(a), Ok(b)) = (a, b) {
+                a.partial_cmp(b).unwrap()
+            } else {
+                Ordering::Less
+            }
+        });
+
+        // Return the vector leaving only the `PingRequest`s in it
+        Ok(pending_pings
+            .into_iter()
+            .map(|(_, request)| request)
+            .collect())
+    }
+}
+
+#[cfg(test)]
+mod test {
+    use std::fs::File;
+    use std::io::prelude::*;
+    use uuid::Uuid;
+
+    use super::*;
+    use crate::metrics::PingType;
+    use crate::tests::new_glean;
+
+    #[test]
+    fn test_doesnt_panic_if_no_pending_pings_directory() {
+        let dir = tempfile::tempdir().unwrap();
+        let directory_manager = PingDirectoryManager::new(dir.path());
+
+        // Verify that processing the directory didn't panic
+        assert!(directory_manager.process_dir().is_err());
+    }
+
+    #[test]
+    fn test_creates_requests_correctly_from_valid_ping_file() {
+        let (mut glean, dir) = new_glean(None);
+
+        // Register a ping for testing
+        let ping_type = PingType::new("test", true, true, vec![]);
+        glean.register_ping_type(&ping_type);
+
+        // Submit the ping to populate the pending_pings directory
+        glean.submit_ping(&ping_type, None).unwrap();
+
+        let directory_manager = PingDirectoryManager::new(dir.path());
+
+        // Try and process the pings folder
+        let requests = directory_manager.process_dir().unwrap();
+
+        // Verify there is just the one request
+        assert_eq!(requests.len(), 1);
+
+        // Verify request was returned for the "test" ping
+        let request_ping_type = requests[0].url.split('/').nth(3).unwrap();
+        assert_eq!(request_ping_type, "test");
+    }
+
+    #[test]
+    fn test_non_uuid_files_are_deleted_and_ignored() {
+        let (mut glean, dir) = new_glean(None);
+
+        // Register a ping for testing
+        let ping_type = PingType::new("test", true, true, vec![]);
+        glean.register_ping_type(&ping_type);
+
+        // Submit the ping to populate the pending_pings directory
+        glean.submit_ping(&ping_type, None).unwrap();
+
+        let directory_manager = PingDirectoryManager::new(dir.path());
+
+        // Add non uuid file to pending_pings directory
+        let not_uuid_path = directory_manager.get_dir().join("not-uuid-file-name.txt");
+        File::create(&not_uuid_path).unwrap();
+
+        // Try and process the pings folder
+        let requests = directory_manager.process_dir().unwrap();
+
+        // Verify there is just the one request
+        assert_eq!(requests.len(), 1);
+
+        // Verify request was returned for the "test" ping
+        let request_ping_type = requests[0].url.split('/').nth(3).unwrap();
+        assert_eq!(request_ping_type, "test");
+
+        // Verify that file was indeed deleted
+        assert!(!not_uuid_path.exists());
+    }
+
+    #[test]
+    fn test_wrongly_formatted_files_are_deleted_and_ignored() {
+        let (mut glean, dir) = new_glean(None);
+
+        // Register a ping for testing
+        let ping_type = PingType::new("test", true, true, vec![]);
+        glean.register_ping_type(&ping_type);
+
+        // Submit the ping to populate the pending_pings directory
+        glean.submit_ping(&ping_type, None).unwrap();
+
+        let directory_manager = PingDirectoryManager::new(dir.path());
+
+        // Create a file that will have wrong format contents
+        let wrong_contents_file_path = directory_manager.get_dir().join(Uuid::new_v4().to_string());
+        File::create(&wrong_contents_file_path).unwrap();
+
+        // Try and process the pings folder
+        let requests = directory_manager.process_dir().unwrap();
+
+        // Verify there is just the one request
+        assert_eq!(requests.len(), 1);
+
+        // Verify request was returned for the "test" ping
+        let request_ping_type = requests[0].url.split('/').nth(3).unwrap();
+        assert_eq!(request_ping_type, "test");
+
+        // Verify that file was indeed deleted
+        assert!(!wrong_contents_file_path.exists());
+    }
+
+    #[test]
+    fn test_non_json_ping_body_files_are_deleted_and_ignored() {
+        let (mut glean, dir) = new_glean(None);
+
+        // Register a ping for testing
+        let ping_type = PingType::new("test", true, true, vec![]);
+        glean.register_ping_type(&ping_type);
+
+        // Submit the ping to populate the pending_pings directory
+        glean.submit_ping(&ping_type, None).unwrap();
+
+        let directory_manager = PingDirectoryManager::new(dir.path());
+
+        // Create a file that will have wrong format contents
+        let non_json_body_file_path = directory_manager.get_dir().join(Uuid::new_v4().to_string());
+        let mut non_json_body_file = File::create(&non_json_body_file_path).unwrap();
+        non_json_body_file
+            .write_all(
+                b"https://doc.rust-lang.org/std/fs/struct.File.html
+                This is not JSON!!!!",
+            )
+            .unwrap();
+
+        // Try and process the pings folder
+        let requests = directory_manager.process_dir().unwrap();
+
+        // Verify there is just the one request
+        assert_eq!(requests.len(), 1);
+
+        // Verify request was returned for the "test" ping
+        let request_ping_type = requests[0].url.split('/').nth(3).unwrap();
+        assert_eq!(request_ping_type, "test");
+
+        // Verify that file was indeed deleted
+        assert!(!non_json_body_file_path.exists());
+    }
+}

diff --git a/glean-core/src/upload/mod.rs b/glean-core/src/upload/mod.rs
--- a/glean-core/src/upload/mod.rs
+++ b/glean-core/src/upload/mod.rs
@@ -16,7 +16,6 @@
 
 use std::collections::VecDeque;
 use std::path::PathBuf;
-use std::str::FromStr;
 use std::sync::atomic::{AtomicBool, Ordering};
 use std::sync::{Arc, RwLock};
 use std::thread;
@@ -24,11 +23,11 @@ use std::thread;
 use log;
 use serde_json::Value as JsonValue;
 
+use directory::PingDirectoryManager;
 use request::PingRequest;
-use util::process_pings_dir;
 
+mod directory;
 mod request;
-mod util;
 
 /// When asking for the next ping request to upload,
 /// the requester may receive one out of three possible tasks.
@@ -49,6 +48,8 @@ pub enum PingUploadTask {
 pub struct PingUploadManager {
     /// A FIFO queue storing a `PingRequest` for each pending ping.
     queue: Arc<RwLock<VecDeque<PingRequest>>>,
+    /// A manager for the pending pings directories.
+    directory_manager: PingDirectoryManager,
     /// A flag signaling if we are done processing the pending pings directories.
     ///
     /// This does not indicate that processing of the directory was successful,
@@ -69,17 +70,18 @@ impl PingUploadManager {
     /// # Panics
     ///
     /// Will panic if unable to spawn a new thread.
-    pub fn new(data_path: &str) -> Self {
+    pub fn new<P: Into<PathBuf>>(data_path: P) -> Self {
         let queue = Arc::new(RwLock::new(VecDeque::new()));
+        let directory_manager = PingDirectoryManager::new(data_path);
         let processed_pending_pings = Arc::new(AtomicBool::new(false));
 
-        let data_path = PathBuf::from_str(data_path).expect("data_path must be a valid path.");
         let local_queue = queue.clone();
         let local_flag = processed_pending_pings.clone();
+        let local_manager = directory_manager.clone();
         let _ = thread::Builder::new()
-            .name("glean.upload_manager.process_pings_dir".to_string())
+            .name("glean.ping_directory_manager.process_dir".to_string())
             .spawn(move || {
-                match process_pings_dir(&data_path) {
+                match local_manager.process_dir() {
                     Ok(requests) => {
                         let mut local_queue = local_queue
                             .write()
@@ -95,6 +97,7 @@ impl PingUploadManager {
         Self {
             queue,
             processed_pending_pings,
+            directory_manager,
         }
     }
 
@@ -140,6 +143,74 @@ impl PingUploadManager {
             None => PingUploadTask::Done,
         }
     }
+
+    /// Processes the response from an attempt to upload a ping.
+    ///
+    /// Based on the HTTP status of said response,
+    /// the possible outcomes are:
+    ///
+    /// * **200 - 299 Success**
+    ///   Any status on the 2XX range is considered a succesful upload,
+    ///   which means the corresponding ping file can be deleted.
+    ///   _Known 2XX status:_
+    ///   * 200 - OK. Request accepted into the pipeline.
+    ///
+    /// * **400 - 499 Unrecoverable error**
+    ///   Any status on the 4XX range means something our client did is not correct.
+    ///   It is unlikely that the client is going to recover from this by retrying,
+    ///   so in this case the corresponding ping file can also be deleted.
+    ///   _Known 4XX status:_
+    ///   * 404 - not found - POST/PUT to an unknown namespace
+    ///   * 405 - wrong request type (anything other than POST/PUT)
+    ///   * 411 - missing content-length header
+    ///   * 413 - request body too large Note that if we have badly-behaved clients that
+    ///           retry on 4XX, we should send back 202 on body/path too long).
+    ///   * 414 - request path too long (See above)
+    ///
+    /// * **Any other error**
+    ///   For any other error, a warning is logged and the ping is re-enqueued.
+    ///   _Known other errors:_
+    ///   * 500 - internal error
+    ///
+    /// # Note
+    ///
+    /// The disk I/O performed by this function is not done off-thread,
+    /// as it is expected to be called off-thread by the platform.
+    ///
+    /// # Arguments
+    ///
+    /// `uuid` - The UUID of the ping in question.
+    /// `status` - The HTTP status of the response.
+    pub fn process_ping_upload_response(&self, uuid: &str, status: u16) {
+        match status {
+            200..=299 => {
+                log::info!("Ping {} successfully sent {}.", uuid, status);
+                self.directory_manager.delete_file(uuid);
+            }
+            400..=499 => {
+                log::error!(
+                    "Server returned client error code {} while attempting to send ping {}.",
+                    status,
+                    uuid
+                );
+                self.directory_manager.delete_file(uuid);
+            }
+            _ => {
+                log::error!(
+                    "Server returned response code {} while attempting to send ping {}.",
+                    status,
+                    uuid
+                );
+                if let Some(request) = self.directory_manager.process_file(uuid) {
+                    let mut queue = self
+                        .queue
+                        .write()
+                        .expect("Can't write to pending pings queue.");
+                    queue.push_back(request);
+                }
+            }
+        };
+    }
 }
 
 #[cfg(test)]
@@ -160,8 +231,7 @@ mod test {
     fn test_doesnt_error_when_there_are_no_pending_pings() {
         // Create a new upload_manager
         let dir = tempfile::tempdir().unwrap();
-        let tmpname = dir.path().display().to_string();
-        let upload_manager = PingUploadManager::new(&tmpname);
+        let upload_manager = PingUploadManager::new(dir.path());
 
         // Wait for processing of pending pings directory to finish.
         while upload_manager.get_upload_task() == PingUploadTask::Wait {
@@ -177,8 +247,7 @@ mod test {
     fn test_returns_ping_request_when_there_is_one() {
         // Create a new upload_manager
         let dir = tempfile::tempdir().unwrap();
-        let tmpname = dir.path().display().to_string();
-        let upload_manager = PingUploadManager::new(&tmpname);
+        let upload_manager = PingUploadManager::new(dir.path());
 
         // Wait for processing of pending pings directory to finish.
         while upload_manager.get_upload_task() == PingUploadTask::Wait {
@@ -200,8 +269,7 @@ mod test {
     fn test_returns_as_many_ping_requests_as_there_are() {
         // Create a new upload_manager
         let dir = tempfile::tempdir().unwrap();
-        let tmpname = dir.path().display().to_string();
-        let upload_manager = PingUploadManager::new(&tmpname);
+        let upload_manager = PingUploadManager::new(dir.path());
 
         // Wait for processing of pending pings directory to finish.
         while upload_manager.get_upload_task() == PingUploadTask::Wait {
@@ -230,8 +298,7 @@ mod test {
     fn test_clearing_the_queue_works_correctly() {
         // Create a new upload_manager
         let dir = tempfile::tempdir().unwrap();
-        let tmpname = dir.path().display().to_string();
-        let upload_manager = PingUploadManager::new(&tmpname);
+        let upload_manager = PingUploadManager::new(dir.path());
 
         // Wait for processing of pending pings directory to finish.
         while upload_manager.get_upload_task() == PingUploadTask::Wait {
@@ -265,8 +332,7 @@ mod test {
         }
 
         // Create a new upload_manager
-        let data_path = dir.path().to_str().unwrap();
-        let upload_manager = PingUploadManager::new(data_path);
+        let upload_manager = PingUploadManager::new(dir.path());
 
         // Wait for processing of pending pings directory to finish.
         let mut upload_task = upload_manager.get_upload_task();
@@ -288,4 +354,126 @@ mod test {
         // Verify that after all requests are returned, none are left
         assert_eq!(upload_manager.get_upload_task(), PingUploadTask::Done);
     }
+
+    #[test]
+    fn test_processes_correctly_success_upload_response() {
+        let (mut glean, dir) = new_glean(None);
+
+        // Register a ping for testing
+        let ping_type = PingType::new("test", true, /* send_if_empty */ true, vec![]);
+        glean.register_ping_type(&ping_type);
+
+        // Submit a ping
+        glean.submit_ping(&ping_type, None).unwrap();
+
+        // Create a new upload_manager
+        let upload_manager = PingUploadManager::new(dir.path());
+
+        // Wait for processing of pending pings directory to finish.
+        let mut upload_task = upload_manager.get_upload_task();
+        while upload_task == PingUploadTask::Wait {
+            thread::sleep(Duration::from_millis(10));
+            upload_task = upload_manager.get_upload_task();
+        }
+
+        // Get the pending ping directory path
+        let pending_pings_dir = upload_manager.directory_manager.get_dir();
+
+        // Get the submitted PingRequest
+        match upload_task {
+            PingUploadTask::Upload(request) => {
+                // Simulate the processing of a sucessfull request
+                let uuid = request.uuid;
+                upload_manager.process_ping_upload_response(&uuid, 200);
+                // Verify file was deleted
+                assert!(!pending_pings_dir.join(uuid).exists());
+            }
+            _ => panic!("Expected upload manager to return the next request!"),
+        }
+
+        // Verify that after request is returned, none are left
+        assert_eq!(upload_manager.get_upload_task(), PingUploadTask::Done);
+    }
+
+    #[test]
+    fn test_processes_correctly_client_error_upload_response() {
+        let (mut glean, dir) = new_glean(None);
+
+        // Register a ping for testing
+        let ping_type = PingType::new("test", true, /* send_if_empty */ true, vec![]);
+        glean.register_ping_type(&ping_type);
+
+        // Submit a ping
+        glean.submit_ping(&ping_type, None).unwrap();
+
+        // Create a new upload_manager
+        let upload_manager = PingUploadManager::new(dir.path());
+
+        // Wait for processing of pending pings directory to finish.
+        let mut upload_task = upload_manager.get_upload_task();
+        while upload_task == PingUploadTask::Wait {
+            thread::sleep(Duration::from_millis(10));
+            upload_task = upload_manager.get_upload_task();
+        }
+
+        // Get the pending ping directory path
+        let pending_pings_dir = upload_manager.directory_manager.get_dir();
+
+        // Get the submitted PingRequest
+        match upload_task {
+            PingUploadTask::Upload(request) => {
+                // Simulate the processing of a client error
+                let uuid = request.uuid;
+                upload_manager.process_ping_upload_response(&uuid, 404);
+                // Verify file was deleted
+                assert!(!pending_pings_dir.join(uuid).exists());
+            }
+            _ => panic!("Expected upload manager to return the next request!"),
+        }
+
+        // Verify that after request is returned, none are left
+        assert_eq!(upload_manager.get_upload_task(), PingUploadTask::Done);
+    }
+
+    #[test]
+    fn test_processes_correctly_server_error_upload_response() {
+        let (mut glean, dir) = new_glean(None);
+
+        // Register a ping for testing
+        let ping_type = PingType::new("test", true, /* send_if_empty */ true, vec![]);
+        glean.register_ping_type(&ping_type);
+
+        // Submit a ping
+        glean.submit_ping(&ping_type, None).unwrap();
+
+        // Create a new upload_manager
+        let upload_manager = PingUploadManager::new(dir.path());
+
+        // Wait for processing of pending pings directory to finish.
+        let mut upload_task = upload_manager.get_upload_task();
+        while upload_task == PingUploadTask::Wait {
+            thread::sleep(Duration::from_millis(10));
+            upload_task = upload_manager.get_upload_task();
+        }
+
+        // Get the submitted PingRequest
+        match upload_task {
+            PingUploadTask::Upload(request) => {
+                // Simulate the processing of a client error
+                let uuid = request.uuid;
+                upload_manager.process_ping_upload_response(&uuid, 500);
+                // Verify this ping was indeed re-enqueued
+                match upload_manager.get_upload_task() {
+                    PingUploadTask::Upload(request) => {
+                        assert_eq!(uuid, request.uuid);
+                    }
+                    _ => panic!("Expected upload manager to return the next request!"),
+                }
+            }
+            _ => panic!("Expected upload manager to return the next request!"),
+        }
+
+        // Verify that after request is returned, none are left
+        assert_eq!(upload_manager.get_upload_task(), PingUploadTask::Done);
+    }
 }

diff --git a/glean-core/src/upload/util.rs b/glean-core/src/upload/util.rs
--- a/glean-core/src/upload/util.rs
+++ b/glean-core/src/upload/util.rs
@@ -1,265 +0,0 @@
-// This Source Code Form is subject to the terms of the Mozilla Public
-// License, v. 2.0. If a copy of the MPL was not distributed with this
-// file, You can obtain one at https://mozilla.org/MPL/2.0/.
-
-//! Pings directory processing utilities.
-
-use std::cmp::Ordering;
-use std::fs::{self, File};
-use std::io::{BufRead, BufReader};
-use std::path::{Path, PathBuf};
-
-use log;
-use serde_json::Value as JsonValue;
-use uuid::Uuid;
-
-use super::PingRequest;
-use crate::Result;
-
-/// Attempt to delete a file.
-///
-/// This won't panic if not able to delete, just log.
-fn delete_file(path: &Path) {
-    match fs::remove_file(path) {
-        Err(e) => log::error!("Error deleting file {}. {}", path.display(), e),
-        _ => log::info!("Deleted file {}", path.display()),
-    };
-}
-
-/// Get the file name from a path as a &str.
-///
-/// This won't panic if not able to get file name, just log.
-fn get_file_name_as_str(path: &Path) -> Option<&str> {
-    match path.file_name() {
-        None => {
-            log::warn!("Error getting file name from path: {}", path.display());
-            None
-        }
-        Some(file_name) => {
-            let file_name = file_name.to_str();
-            if file_name.is_none() {
-                log::warn!("File name is not valid unicode: {}", path.display());
-            }
-            file_name
-        }
-    }
-}
-
-/// Get the pending pings directory path.
-fn get_pings_dir(data_path: &Path) -> PathBuf {
-    data_path.join("pending_pings")
-}
-
-/// Reads a ping file and returns a `PingRequest` from it.
-///
-/// If the file is not properly formatted, it will be deleted.
-///
-/// ## Panics
-///
-/// Will panic if unable to read the file.
-fn process_ping_file(uuid: &str, path: &Path) -> Option<PingRequest> {
-    let file = File::open(path).expect("Should be able to read ping file.");
-    let mut lines = BufReader::new(file).lines();
-    // The way the ping file is structured,
-    // first line should always have the url
-    // and second line should have the body with the ping contents in JSON format
-    if let (Some(Ok(url)), Some(Ok(body))) = (lines.next(), lines.next()) {
-        if let Ok(parsed_body) = serde_json::from_str::<JsonValue>(&body) {
-            return Some(PingRequest::new(uuid, &url, parsed_body));
-        } else {
-            log::warn!("Can't parse ping contents as JSON.");
-        }
-    } else {
-        log::warn!("Ping file is not formatted as expected.");
-    }
-    delete_file(path);
-    None
-}
-
-/// Process the pings directory and return a vector of `PingRequest`s
-/// corresponding to each valid ping file in the directory.
-/// This vector will be ordered by file `modified_date`.
-///
-/// Any files that don't match the UUID regex will be deleted
-/// to prevent files from polluting the pings directory.
-///
-/// Files that are not correctly formatted will also be deleted.
-pub fn process_pings_dir(data_path: &Path) -> Result<Vec<PingRequest>> {
-    let pings_dir = get_pings_dir(data_path);
-    let mut pending_pings: Vec<_> = pings_dir
-        .read_dir()?
-        .filter_map(|entry| entry.ok())
-        .filter_map(|entry| {
-            let path = entry.path();
-            if let Some(file_name) = get_file_name_as_str(&path) {
-                // Delete file if it doesn't match the pattern.
-                if Uuid::parse_str(file_name).is_err() {
-                    log::warn!("Pattern mismatch {}", path.display());
-                    delete_file(&path);
-                    return None;
-                }
-                // In case we can't process the file we just ignore it.
-                if let Some(request) = process_ping_file(file_name, &path) {
-                    // Get the modified date of the file, which will later be used
-                    // for sorting the resulting vector.
-                    let modified_date = fs::metadata(&path).and_then(|data| data.modified());
-                    return Some((modified_date, request));
-                }
-            };
-            None
-        })
-        .collect();
-
-    // Sort by `modified_date`.
-    pending_pings.sort_by(|(a, _), (b, _)| {
-        // We might not be able to get the modified date for a given file,
-        // in which case we just put it at the end.
-        if let (Ok(a), Ok(b)) = (a, b) {
-            a.partial_cmp(b).unwrap()
-        } else {
-            Ordering::Less
-        }
-    });
-
-    // Return the vector leaving only the `PingRequest`s in it
-    Ok(pending_pings
-        .into_iter()
-        .map(|(_, request)| request)
-        .collect())
-}
-
-#[cfg(test)]
-mod test {
-    use std::fs::File;
-    use std::io::prelude::*;
-    use uuid::Uuid;
-
-    use super::*;
-    use crate::metrics::PingType;
-    use crate::tests::new_glean;
-
-    #[test]
-    fn test_doesnt_panic_if_no_pending_pings_directory() {
-        let dir = tempfile::tempdir().unwrap();
-        assert!(process_pings_dir(&dir.path()).is_err());
-    }
-
-    #[test]
-    fn test_creates_requests_correctly_from_valid_ping_file() {
-        let (mut glean, dir) = new_glean(None);
-        let data_path = dir.path();
-
-        // Register a ping for testing
-        let ping_type = PingType::new("test", true, true, vec![]);
-        glean.register_ping_type(&ping_type);
-
-        // Submit the ping to populate the pending_pings directory
-        glean.submit_ping(&ping_type, None).unwrap();
-
-        // Try and process the pings folder
-        let requests = process_pings_dir(&data_path).unwrap();
-
-        // Verify there is just the one request
-        assert_eq!(requests.len(), 1);
-
-        // Verify request was returned for the "test" ping
-        let request_ping_type = requests[0].url.split('/').nth(3).unwrap();
-        assert_eq!(request_ping_type, "test");
-    }
-
-    #[test]
-    fn test_non_uuid_files_are_deleted_and_ignored() {
-        let (mut glean, dir) = new_glean(None);
-        let data_path = dir.path();
-
-        // Register a ping for testing
-        let ping_type = PingType::new("test", true, true, vec![]);
-        glean.register_ping_type(&ping_type);
-
-        // Submit the ping to populate the pending_pings directory
-        glean.submit_ping(&ping_type, None).unwrap();
-
-        // Add non uuid file to pending_pings directory
-        let not_uuid_path = get_pings_dir(&data_path).join("not-uuid-file-name.txt");
-        File::create(&not_uuid_path).unwrap();
-
-        // Try and process the pings folder
-        let requests = process_pings_dir(&data_path).unwrap();
-
-        // Verify there is just the one request
-        assert_eq!(requests.len(), 1);
-
-        // Verify request was returned for the "test" ping
-        let request_ping_type = requests[0].url.split('/').nth(3).unwrap();
-        assert_eq!(request_ping_type, "test");
-
-        // Verify that file was indeed deleted
-        assert!(!not_uuid_path.exists());
-    }
-
-    #[test]
-    fn test_wrongly_formatted_files_are_deleted_and_ignored() {
-        let (mut glean, dir) = new_glean(None);
-        let data_path = dir.path();
-
-        // Register a ping for testing
-        let ping_type = PingType::new("test", true, true, vec![]);
-        glean.register_ping_type(&ping_type);
-
-        // Submit the ping to populate the pending_pings directory
-        glean.submit_ping(&ping_type, None).unwrap();
-
-        // Create a file that will have wrong format contents
-        let wrong_contents_file_path = get_pings_dir(&data_path).join(Uuid::new_v4().to_string());
-        File::create(&wrong_contents_file_path).unwrap();
-
-        // Try and process the pings folder
-        let requests = process_pings_dir(&data_path).unwrap();
-
-        // Verify there is just the one request
-        assert_eq!(requests.len(), 1);
-
-        // Verify request was returned for the "test" ping
-        let request_ping_type = requests[0].url.split('/').nth(3).unwrap();
-        assert_eq!(request_ping_type, "test");
-
-        // Verify that file was indeed deleted
-        assert!(!wrong_contents_file_path.exists());
-    }
-
-    #[test]
-    fn test_non_json_ping_body_files_are_deleted_and_ignored() {
-        let (mut glean, dir) = new_glean(None);
-        let data_path = dir.path();
-
-        // Register a ping for testing
-        let ping_type = PingType::new("test", true, true, vec![]);
-        glean.register_ping_type(&ping_type);
-
-        // Submit the ping to populate the pending_pings directory
-        glean.submit_ping(&ping_type, None).unwrap();
-
-        // Create a file that will have wrong format contents
-        let non_json_body_file_path = get_pings_dir(&data_path).join(Uuid::new_v4().to_string());
-        let mut non_json_body_file = File::create(&non_json_body_file_path).unwrap();
-        non_json_body_file
-            .write_all(
-                b"https://doc.rust-lang.org/std/fs/struct.File.html
-                This is not JSON!!!!",
-            )
-            .unwrap();
-
-        // Try and process the pings folder
-        let requests = process_pings_dir(&data_path).unwrap();
-
-        // Verify there is just the one request
-        assert_eq!(requests.len(), 1);
-
-        // Verify request was returned for the "test" ping
-        let request_ping_type = requests[0].url.split('/').nth(3).unwrap();
-        assert_eq!(request_ping_type, "test");
-
-        // Verify that file was indeed deleted
-        assert!(!non_json_body_file_path.exists());
-    }
-}


</patch>

Function signatures
<Signatures>

</Signatures>

You are a software tester at glean and your are reviewing the above <patch> for the above <issue>
Identify whether a unit test is needed.
If there is no test needed, return <NO>.
If a test is needed, your task is:
1. Write exactly one rust test `#[test]fn test_...(){...}` block. Do NOT wrap the test inside a 'mod tests' block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. All 'use' declarations must be inside a <imports>...</imports> block.
 Use `use super::<function name> for the function under test.
.If multiple 'use' statements are needed, list each on a separate line.
5. To help you write the test, <Signatures> contains all modified function's:
- name
- parameters
- Return type (assume '()' if empty)
6. Return only the absolute filename as it is in the <patch> block, the use statements, and rust test (no comments or explanations).

Here is an example structure:
<Filename> ... </Filename>
<imports> ... </imports>
<Rust>
#[test]
fn test_<describe_behavior>() {
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
}</Rust>

