#[test]
fn maximum_wait_attempts_are_enforced() {
    let (glean, dir) = new_glean(None);

    // Create a new upload manager
    let mut upload_manager =
        PingUploadManager::new(dir.path(), "Testing", /* sync */ true);

    // Add a rate limiter to the upload manager with max of 1 ping every 5 seconds
    let secs_per_interval = 5;
    let max_pings_per_interval = 1;
    upload_manager.set_rate_limiter(secs_per_interval, max_pings_per_interval);

    // Enqueue two pings
    upload_manager.enqueue_ping(&glean, &Uuid::new_v4().to_string(), "test/path", "", None);
    upload_manager.enqueue_ping(&glean, &Uuid::new_v4().to_string(), "test/path", "", None);

    // First ping should be Upload task
    match upload_manager.get_upload_task(&glean, false) {
        PingUploadTask::Upload(_) => (),
        _ => panic!("Expected Upload task"),
    }

    // Next calls should return Wait up to MAX_WAIT_ATTEMPTS times
    for _ in 0..MAX_WAIT_ATTEMPTS {
        match upload_manager.get_upload_task(&glean, false) {
            PingUploadTask::Wait => (),
            _ => panic!("Expected Wait task"),
        }
    }

    // After MAX_WAIT_ATTEMPTS, should return Done
    match upload_manager.get_upload_task(&glean, false) {
        PingUploadTask::Done => (),
        _ => panic!("Expected Done task"),
    }

    // Wait for the rate limiter interval
    thread::sleep(Duration::from_secs(secs_per_interval));

    // Now should be able to get Upload task again
    match upload_manager.get_upload_task(&glean, false) {
        PingUploadTask::Upload(_) => (),
        _ => panic!("Expected Upload task after interval"),
    }

    // And then Done as there are no more pings
    match upload_manager.get_upload_task(&glean, false) {
        PingUploadTask::Done => (),
        _ => panic!("Expected Done task"),
    }
}