<think>
Okay, I need to determine whether a unit test is necessary for the given patch. The issue is that the message "Glean disabled: not submitting any pings" is always printed when Glean is disabled. The patch changes this from a log::error to a log::info, which is a lower severity level. 

First, I should understand the problem. The user wants to avoid the error message appearing on every mach invocation when telemetry is disabled. By changing the log level, the message will be less intrusive. However, the problem is whether this change can be verified with a test.

Since the patch modifies the logging behavior, a test can check that the error message is no longer logged when Glean is disabled. But how can we test this in Rust? 

I recall that in Rust, testing logging can be tricky because logs are usually macro-based and don't return values. One approach is to use a test logger that captures the logs and then checks if the expected message is present at the correct level.

So, I'll need to write a test that initializes Glean with telemetry disabled, then calls a function that would trigger the log message, like submit_ping. Then, I'll check if the log message is an info instead of an error.

I should use a custom logging implementation for the test to capture the logs. Maybe using the log-test crate or a similar approach. Alternatively, I can set up a logger in the test that captures the messages and their levels.

The test steps would be:
1. Set up a test logger that can capture log messages.
2. Initialize Glean with telemetry disabled.
3. Call submit_ping, which should trigger the log message.
4. Check that the log message was recorded as info, not error.

I need to make sure that the test fails before the patch and passes after. So, the test should assert that the message is logged at the info level.

Now, considering the code structure, I'll need to import the necessary functions and set up the test environment. The test function will be named something like test_glean_disabled_message_is_info.

I should also ensure that the test is self-contained and doesn't rely on external state beyond what's set up in the test.

So, the test will look something like this:
- Use a logger that captures messages.
- Initialize Glean with upload disabled.
- Call submit_ping on a dummy ping.
- Check that the log message is present and is an info level.

I think this approach covers the necessary verification. Now, I'll write the code accordingly, making sure to include all necessary imports and set up the test correctly.
</think>

The patch changes the log level from error to info when Glean is disabled. A test is needed to verify that the message is logged correctly at the info level instead of error.

<Filename> glean-core/src/lib.rs </Filename>
<imports>
use log::Level;
use super::Glean;
</imports>
<Rust>
#[test]
fn test_glean_disabled_message_is_info() {
    // Set up logging to capture messages
    let (handler, mut listener) = logging::handler::with_level(Level::Info)
        .build()
        .rotate()
        .test();

    // Initialize Glean with telemetry disabled
    let glean = Glean::new(
        "test".into(),
        "test".into(),
        None,
        None,
        false, // telemetry disabled
    );

    // Call submit_ping to trigger the log message
    let result = glean.submit_ping(&PingType::default(), None);
    assert!(result.is_ok());

    // Check the logs for the expected info message
    listener.refresh();
    let records = listener.records();
    assert_eq!(records.len(), 1);
    assert_eq!(records[0].level(), Level::Info);
    assert_eq!(
        records[0].args().to_string(),
        "Glean disabled: not submitting any pings."
    );
}
</Rust>