<Filename>glean-core/src/upload/mod.rs</Filename>
<imports>
use super::PingUploadManager;
use crate::Glean;
use crate::PingType;
use crate::upload::PingUploadTask;
use std::time::Duration;
use std::thread;
</imports>
<Rust>
#[test]
fn test_pending_pings_quota_enforcement() {
    let (mut glean, tmpdir) = new_glean(None);

    // Register a ping for testing
    let ping_type = PingType::new("test", true, /* send_if_empty */ true, vec![]);
    glean.register_ping_type(&ping_type);

    // Submit the ping multiple times
    let n = 10;
    for _ in 0..n {
        glean.submit_ping(&ping_type, None).unwrap();
    }

    // Create a new upload manager pointing to the same data_path as the glean instance.
    let upload_manager = PingUploadManager::new(tmpdir.path(), "Rust", true);

    // Enqueue cached pings and set the quota to just a little over the size on an empty ping file.
    upload_manager.enqueue_cached_pings(&glean, 500);

    // Get a task once
    match upload_manager.get_upload_task(&glean, false) {
        PingUploadTask::Upload(_) => {}
        _ => panic!("Expected upload manager to return the next request!"),
    }

    // Verify that no other requests were returned,
    assert_eq!(
        upload_manager.get_upload_task(&glean, false),
        PingUploadTask::Done
    );

    // Verify that the correct number of deleted pings was recorded
    assert_eq!(
        n - 1,
        upload_manager
            .upload_metrics
            .deleted_pings_after_quota_hit
            .test_get_value(&glean, "metrics")
            .unwrap()
    )
}
</Rust>