#[test]
fn test_merge_metrics_enabled_config() {
    let (glean, _t) = new_glean(None);
    let metric1 = StringMetric::new(CommonMetricData {
        category: "category1".to_string(),
        name: "string_metric1".to_string(),
        send_in_pings: vec![String::from("ping1")],
        ..Default::default()
    });
    let metric2 = StringMetric::new(CommonMetricData {
        category: "category2".to_string(),
        name: "string_metric2".to_string(),
        send_in_pings: vec![String::from("ping2")],
        ..Default::default()
    });

    // Initial configuration enables metric1
    let config1 = json!({
        "category1.string_metric1": true
    }).to_string();
    glean.set_metrics_enabled_config(
        MetricsEnabledConfig::try_from(config1).unwrap(),
    );

    // Try setting metric1 - should work
    metric1.set_sync(&glean, "VALUE1");
    assert_eq!(
        "VALUE1",
        metric1.get_value(&glean, "baseline").unwrap(),
        "Should set when enabled"
    );

    // Try setting metric2 - should fail
    assert_panics!(metric2.set_sync(&glean, "VALUE2"), "Cannot set metric when it's disabled");
    assert_eq!(
        None,
        metric2.get_value(&glean, "baseline"),
        "Should not set when disabled"
    );

    // Merge with configuration that enables metric2
    let config2 = json!({
        "category2.string_metric2": true
    }).to_string();
    glean.set_metrics_enabled_config(
        MetricsEnabledConfig::try_from(config2).unwrap(),
    );

    // Now both metrics should be enabled
    metric1.set_sync(&glean, "VALUE3");
    assert_eq!(
        "VALUE3",
        metric1.get_value(&glean, "baseline").unwrap(),
        "Should set when still enabled"
    );

    metric2.set_sync(&glean, "VALUE4");
    assert_eq!(
        "VALUE4",
        metric2.get_value(&glean, "baseline").unwrap(),
        "Should set when newly enabled"
    );
}