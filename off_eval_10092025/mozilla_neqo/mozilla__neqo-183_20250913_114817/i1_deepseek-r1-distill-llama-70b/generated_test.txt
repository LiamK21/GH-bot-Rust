#[test]
fn test_send_stream_writable_event_after_max_data() {
    let mut client = default_client();
    let mut server = default_server();
    connect(&mut client, &mut server);

    let stream_id = client.stream_create(StreamType::UniDi).unwrap();
    assert_eq!(stream_id, 2);
    assert_eq!(
        client.stream_avail_send_space(stream_id).unwrap(),
        16383 // LOCAL_MAX_DATA in test config
    );

    // Initial send should succeed but not generate any events because credit is available
    let evts = client.events().collect::<BTreeSet<_>>();
    assert!(evts.is_empty());

    // Send data and check events
    client.stream_send(stream_id, &[b'a'; 4096]).unwrap();
    let evts = client.events().collect::<BTreeSet<_>>();
    assert!(evts.is_empty());

    // Mark data as sent and acked
    let mut ss = client.send_streams.get_mut(stream_id.into()).unwrap();
    ss.mark_as_sent(0, 4096, false);
    ss.mark_as_acked(0, 4096, false);

    // No event because still limited by conn max data
    let evts = client.events().collect::<BTreeSet<_>>();
    assert!(evts.is_empty());

    // Increase max data and check event
    client.handle_max_data(100000);
    let evts = client.events().collect::<BTreeSet<_>>();
    assert_eq!(evts.len(), 1);
    assert!(matches!(evts.into_iter().next().unwrap(), ConnectionEvent::SendStreamWritable(_)));
}