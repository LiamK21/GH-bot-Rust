<Filename> neqo-http3/src/connection.rs </Filename>
<imports> 
use super::connect_and_receive_control_stream;
use super::now;
use crate::http3::Error;
use crate::http3::Http3Connection;
use crate::http3::Http3Event;
use crate::http3::QPackEncoder;
use crate::neqo_trans_conn::Connection;
use crate::neqo_trans_conn::ConnectionEvent;
use crate::neqo_trans_conn::StreamType;
</imports>
<Rust>
#[test]
fn test_read_frames_header_blocked() {
    let (mut hconn, mut neqo_trans_conn, _, mut encoder) =
        connect_and_receive_control_stream(true);
    let request_stream_id = hconn
        .fetch(
            "GET",
            "https",
            "something.com",
            "/",
            &Vec::<(String, String)>::new(),
        )
        .unwrap();
    assert_eq!(request_stream_id, 0);
    let _ = hconn.stream_close_send(request_stream_id);
    let out = hconn.process(None, now());
    neqo_trans_conn.process(out.dgram(), now());

    encoder.set_max_capacity(100).unwrap();
    encoder.set_max_blocked_streams(100).unwrap();

    // find the new request/response stream and send frame v on it.
    let events = neqo_trans_conn.events();
    for e in events {
        match e {
            ConnectionEvent::NewStream {
                stream_id,
                stream_type,
            } => {
                assert_eq!(stream_id, request_stream_id);
                assert_eq!(stream_type, StreamType::BiDi);
            }
            ConnectionEvent::RecvStreamReadable { stream_id } => {
                assert_eq!(stream_id, request_stream_id);
                let mut buf = [0u8; 100];
                let (amount, fin) = neqo_trans_conn.stream_recv(stream_id, &mut buf).unwrap();
                assert_eq!(fin, true);
                assert_eq!(amount, 18);
                assert_eq!(
                    buf[..18],
                    [
                        0x01, 0x10, 0x00, 0x00, 0xd1, 0xd7, 0x50, 0x89, 0x41, 0xe9, 0x2a, 0x67,
                        0x35, 0x53, 0x2e, 0x43, 0xd3, 0xc1
                    ]
                );

                let headers = vec![
                    (String::from(":status"), String::from("200")),
                    (String::from("my-header"), String::from("my-header")),
                    (String::from("content-length"), String::from("3")),
                ];
                let encoded_headers = encoder.encode_header_block(&headers, stream_id);
                let hframe = crate::http3::HFrame::Headers {
                    len: encoded_headers.len() as u64,
                };
                let mut d = crate::http3::Encoder::default();
                hframe.encode(&mut d);
                d.encode(&encoded_headers);
                let d_frame = crate::http3::HFrame::Data { len: 3 };
                d_frame.encode(&mut d);
                d.encode(&[0x61, 0x62,