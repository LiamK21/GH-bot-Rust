Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Use `strum`
> There is  [`FromRepr` in `strum_macros`](https://docs.rs/strum_macros/latest/strum_macros/derive.FromRepr.html), which is already a dependency for Firefox. If we want to use this, I suggest a separate PR, since it will probably be useful for other `enum`s.

_Originally posted by @larseggert in https://github.com/mozilla/neqo/pull/2438#discussion_r1952233515_
            
</issue>

Patch:
<patch>
diff --git a/neqo-common/src/tos.rs b/neqo-common/src/tos.rs
--- a/neqo-common/src/tos.rs
+++ b/neqo-common/src/tos.rs
@@ -7,23 +7,21 @@
 use std::fmt::Debug;
 
 use enum_map::Enum;
+use strum::FromRepr;
 
 /// ECN (Explicit Congestion Notification) codepoints mapped to the
 /// lower 2 bits of the TOS field.
 /// <https://www.iana.org/assignments/dscp-registry/dscp-registry.xhtml>
-#[derive(Copy, Clone, PartialEq, Eq, Enum, Default, Debug)]
+#[derive(Copy, Clone, PartialEq, Eq, Enum, Default, Debug, FromRepr)]
 #[repr(u8)]
 pub enum IpTosEcn {
     #[default]
     /// Not-ECT, Not ECN-Capable Transport, RFC3168
     NotEct = 0b00,
-
     /// ECT(1), ECN-Capable Transport(1), RFC8311 and RFC9331
     Ect1 = 0b01,
-
     /// ECT(0), ECN-Capable Transport(0), RFC3168
     Ect0 = 0b10,
-
     /// CE, Congestion Experienced, RFC3168
     Ce = 0b11,
 }
@@ -36,13 +34,7 @@ impl From<IpTosEcn> for u8 {
 
 impl From<u8> for IpTosEcn {
     fn from(v: u8) -> Self {
-        match v & 0b0000_0011 {
-            0b00 => Self::NotEct,
-            0b01 => Self::Ect1,
-            0b10 => Self::Ect0,
-            0b11 => Self::Ce,
-            _ => unreachable!(),
-        }
+        Self::from_repr(v & 0b0000_0011).expect("all ECN values are covered")
     }
 }
 
@@ -64,76 +56,54 @@ impl IpTosEcn {
 
 /// Diffserv codepoints, mapped to the upper six bits of the TOS field.
 /// <https://www.iana.org/assignments/dscp-registry/dscp-registry.xhtml>
-#[derive(Copy, Clone, PartialEq, Eq, Enum, Default, Debug)]
+#[derive(Copy, Clone, PartialEq, Eq, Enum, Default, Debug, FromRepr)]
 #[repr(u8)]
 pub enum IpTosDscp {
     #[default]
     /// Class Selector 0, RFC2474
     Cs0 = 0b0000_0000,
-
     /// Class Selector 1, RFC2474
     Cs1 = 0b0010_0000,
-
     /// Class Selector 2, RFC2474
     Cs2 = 0b0100_0000,
-
     /// Class Selector 3, RFC2474
     Cs3 = 0b0110_0000,
-
     /// Class Selector 4, RFC2474
     Cs4 = 0b1000_0000,
-
     /// Class Selector 5, RFC2474
     Cs5 = 0b1010_0000,
-
     /// Class Selector 6, RFC2474
     Cs6 = 0b1100_0000,
-
     /// Class Selector 7, RFC2474
     Cs7 = 0b1110_0000,
-
     /// Assured Forwarding 11, RFC2597
     Af11 = 0b0010_1000,
-
     /// Assured Forwarding 12, RFC2597
     Af12 = 0b0011_0000,
-
     /// Assured Forwarding 13, RFC2597
     Af13 = 0b0011_1000,
-
     /// Assured Forwarding 21, RFC2597
     Af21 = 0b0100_1000,
-
     /// Assured Forwarding 22, RFC2597
     Af22 = 0b0101_0000,
-
     /// Assured Forwarding 23, RFC2597
     Af23 = 0b0101_1000,
-
     /// Assured Forwarding 31, RFC2597
     Af31 = 0b0110_1000,
-
     /// Assured Forwarding 32, RFC2597
     Af32 = 0b0111_0000,
-
     /// Assured Forwarding 33, RFC2597
     Af33 = 0b0111_1000,
-
     /// Assured Forwarding 41, RFC2597
     Af41 = 0b1000_1000,
-
     /// Assured Forwarding 42, RFC2597
     Af42 = 0b1001_0000,
-
     /// Assured Forwarding 43, RFC2597
     Af43 = 0b1001_1000,
-
     /// Expedited Forwarding, RFC3246
     Ef = 0b1011_1000,
-
     /// Capacity-Admitted Traffic, RFC5865
     VoiceAdmit = 0b1011_0000,
-
     /// Lower-Effort, RFC8622
     Le = 0b0000_0100,
 }
@@ -146,32 +116,7 @@ impl From<IpTosDscp> for u8 {
 
 impl From<u8> for IpTosDscp {
     fn from(v: u8) -> Self {
-        match v & 0b1111_1100 {
-            0b0000_0000 => Self::Cs0,
-            0b0010_0000 => Self::Cs1,
-            0b0100_0000 => Self::Cs2,
-            0b0110_0000 => Self::Cs3,
-            0b1000_0000 => Self::Cs4,
-            0b1010_0000 => Self::Cs5,
-            0b1100_0000 => Self::Cs6,
-            0b1110_0000 => Self::Cs7,
-            0b0010_1000 => Self::Af11,
-            0b0011_0000 => Self::Af12,
-            0b0011_1000 => Self::Af13,
-            0b0100_1000 => Self::Af21,
-            0b0101_0000 => Self::Af22,
-            0b0101_1000 => Self::Af23,
-            0b0110_1000 => Self::Af31,
-            0b0111_0000 => Self::Af32,
-            0b0111_1000 => Self::Af33,
-            0b1000_1000 => Self::Af41,
-            0b1001_0000 => Self::Af42,
-            0b1001_1000 => Self::Af43,
-            0b1011_1000 => Self::Ef,
-            0b1011_0000 => Self::VoiceAdmit,
-            0b0000_0100 => Self::Le,
-            _ => unreachable!(),
-        }
+        Self::from_repr(v & 0b1111_1100).expect("all DCSP values are covered")
     }
 }

diff --git a/neqo-crypto/src/auth.rs b/neqo-crypto/src/auth.rs
--- a/neqo-crypto/src/auth.rs
+++ b/neqo-crypto/src/auth.rs
@@ -4,72 +4,42 @@
 // option. This file may not be copied, modified, or distributed
 // except according to those terms.
 
+use strum::FromRepr;
+
 use crate::err::{mozpkix, sec, ssl, PRErrorCode};
 
 /// The outcome of authentication.
-#[derive(Clone, Copy, Debug, PartialEq, Eq)]
+#[derive(Clone, Copy, Debug, PartialEq, Eq, FromRepr)]
+#[repr(i32)]
 pub enum AuthenticationStatus {
     Ok,
-    CaInvalid,
-    CaNotV3,
-    CertAlgorithmDisabled,
-    CertExpired,
-    CertInvalidTime,
-    CertIsCa,
-    CertKeyUsage,
-    CertMitm,
-    CertNotYetValid,
-    CertRevoked,
-    CertSelfSigned,
-    CertSubjectInvalid,
-    CertUntrusted,
-    CertWeakKey,
-    IssuerEmptyName,
-    IssuerExpired,
-    IssuerNotYetValid,
-    IssuerUnknown,
-    IssuerUntrusted,
-    PolicyRejection,
-    Unknown,
+    CaInvalid = sec::SEC_ERROR_CA_CERT_INVALID,
+    CaNotV3 = mozpkix::MOZILLA_PKIX_ERROR_V1_CERT_USED_AS_CA,
+    CertAlgorithmDisabled = sec::SEC_ERROR_CERT_SIGNATURE_ALGORITHM_DISABLED,
+    CertExpired = sec::SEC_ERROR_EXPIRED_CERTIFICATE,
+    CertInvalidTime = sec::SEC_ERROR_INVALID_TIME,
+    CertIsCa = mozpkix::MOZILLA_PKIX_ERROR_CA_CERT_USED_AS_END_ENTITY,
+    CertKeyUsage = sec::SEC_ERROR_INADEQUATE_KEY_USAGE,
+    CertMitm = mozpkix::MOZILLA_PKIX_ERROR_MITM_DETECTED,
+    CertNotYetValid = mozpkix::MOZILLA_PKIX_ERROR_NOT_YET_VALID_CERTIFICATE,
+    CertRevoked = sec::SEC_ERROR_REVOKED_CERTIFICATE,
+    CertSelfSigned = mozpkix::MOZILLA_PKIX_ERROR_SELF_SIGNED_CERT,
+    CertSubjectInvalid = ssl::SSL_ERROR_BAD_CERT_DOMAIN,
+    CertUntrusted = sec::SEC_ERROR_UNTRUSTED_CERT,
+    CertWeakKey = mozpkix::MOZILLA_PKIX_ERROR_INADEQUATE_KEY_SIZE,
+    IssuerEmptyName = mozpkix::MOZILLA_PKIX_ERROR_EMPTY_ISSUER_NAME,
+    IssuerExpired = sec::SEC_ERROR_EXPIRED_ISSUER_CERTIFICATE,
+    IssuerNotYetValid = mozpkix::MOZILLA_PKIX_ERROR_NOT_YET_VALID_ISSUER_CERTIFICATE,
+    IssuerUnknown = sec::SEC_ERROR_UNKNOWN_ISSUER,
+    IssuerUntrusted = sec::SEC_ERROR_UNTRUSTED_ISSUER,
+    PolicyRejection = mozpkix::MOZILLA_PKIX_ERROR_ADDITIONAL_POLICY_CONSTRAINT_FAILED,
+    Unknown = sec::SEC_ERROR_LIBRARY_FAILURE,
 }
 
 impl From<AuthenticationStatus> for PRErrorCode {
     #[must_use]
     fn from(v: AuthenticationStatus) -> Self {
-        match v {
-            AuthenticationStatus::Ok => 0,
-            AuthenticationStatus::CaInvalid => sec::SEC_ERROR_CA_CERT_INVALID,
-            AuthenticationStatus::CaNotV3 => mozpkix::MOZILLA_PKIX_ERROR_V1_CERT_USED_AS_CA,
-            AuthenticationStatus::CertAlgorithmDisabled => {
-                sec::SEC_ERROR_CERT_SIGNATURE_ALGORITHM_DISABLED
-            }
-            AuthenticationStatus::CertExpired => sec::SEC_ERROR_EXPIRED_CERTIFICATE,
-            AuthenticationStatus::CertInvalidTime => sec::SEC_ERROR_INVALID_TIME,
-            AuthenticationStatus::CertIsCa => {
-                mozpkix::MOZILLA_PKIX_ERROR_CA_CERT_USED_AS_END_ENTITY
-            }
-            AuthenticationStatus::CertKeyUsage => sec::SEC_ERROR_INADEQUATE_KEY_USAGE,
-            AuthenticationStatus::CertMitm => mozpkix::MOZILLA_PKIX_ERROR_MITM_DETECTED,
-            AuthenticationStatus::CertNotYetValid => {
-                mozpkix::MOZILLA_PKIX_ERROR_NOT_YET_VALID_CERTIFICATE
-            }
-            AuthenticationStatus::CertRevoked => sec::SEC_ERROR_REVOKED_CERTIFICATE,
-            AuthenticationStatus::CertSelfSigned => mozpkix::MOZILLA_PKIX_ERROR_SELF_SIGNED_CERT,
-            AuthenticationStatus::CertSubjectInvalid => ssl::SSL_ERROR_BAD_CERT_DOMAIN,
-            AuthenticationStatus::CertUntrusted => sec::SEC_ERROR_UNTRUSTED_CERT,
-            AuthenticationStatus::CertWeakKey => mozpkix::MOZILLA_PKIX_ERROR_INADEQUATE_KEY_SIZE,
-            AuthenticationStatus::IssuerEmptyName => mozpkix::MOZILLA_PKIX_ERROR_EMPTY_ISSUER_NAME,
-            AuthenticationStatus::IssuerExpired => sec::SEC_ERROR_EXPIRED_ISSUER_CERTIFICATE,
-            AuthenticationStatus::IssuerNotYetValid => {
-                mozpkix::MOZILLA_PKIX_ERROR_NOT_YET_VALID_ISSUER_CERTIFICATE
-            }
-            AuthenticationStatus::IssuerUnknown => sec::SEC_ERROR_UNKNOWN_ISSUER,
-            AuthenticationStatus::IssuerUntrusted => sec::SEC_ERROR_UNTRUSTED_ISSUER,
-            AuthenticationStatus::PolicyRejection => {
-                mozpkix::MOZILLA_PKIX_ERROR_ADDITIONAL_POLICY_CONSTRAINT_FAILED
-            }
-            AuthenticationStatus::Unknown => sec::SEC_ERROR_LIBRARY_FAILURE,
-        }
+        v as Self
     }
 }
 
@@ -78,31 +48,6 @@ impl From<AuthenticationStatus> for PRErrorCode {
 impl From<PRErrorCode> for AuthenticationStatus {
     #[must_use]
     fn from(v: PRErrorCode) -> Self {
-        match v {
-            0 => Self::Ok,
-            sec::SEC_ERROR_CA_CERT_INVALID => Self::CaInvalid,
-            mozpkix::MOZILLA_PKIX_ERROR_V1_CERT_USED_AS_CA => Self::CaNotV3,
-            sec::SEC_ERROR_CERT_SIGNATURE_ALGORITHM_DISABLED => Self::CertAlgorithmDisabled,
-            sec::SEC_ERROR_EXPIRED_CERTIFICATE => Self::CertExpired,
-            sec::SEC_ERROR_INVALID_TIME => Self::CertInvalidTime,
-            mozpkix::MOZILLA_PKIX_ERROR_CA_CERT_USED_AS_END_ENTITY => Self::CertIsCa,
-            sec::SEC_ERROR_INADEQUATE_KEY_USAGE => Self::CertKeyUsage,
-            mozpkix::MOZILLA_PKIX_ERROR_MITM_DETECTED => Self::CertMitm,
-            mozpkix::MOZILLA_PKIX_ERROR_NOT_YET_VALID_CERTIFICATE => Self::CertNotYetValid,
-            sec::SEC_ERROR_REVOKED_CERTIFICATE => Self::CertRevoked,
-            mozpkix::MOZILLA_PKIX_ERROR_SELF_SIGNED_CERT => Self::CertSelfSigned,
-            ssl::SSL_ERROR_BAD_CERT_DOMAIN => Self::CertSubjectInvalid,
-            sec::SEC_ERROR_UNTRUSTED_CERT => Self::CertUntrusted,
-            mozpkix::MOZILLA_PKIX_ERROR_INADEQUATE_KEY_SIZE => Self::CertWeakKey,
-            mozpkix::MOZILLA_PKIX_ERROR_EMPTY_ISSUER_NAME => Self::IssuerEmptyName,
-            sec::SEC_ERROR_EXPIRED_ISSUER_CERTIFICATE => Self::IssuerExpired,
-            mozpkix::MOZILLA_PKIX_ERROR_NOT_YET_VALID_ISSUER_CERTIFICATE => Self::IssuerNotYetValid,
-            sec::SEC_ERROR_UNKNOWN_ISSUER => Self::IssuerUnknown,
-            sec::SEC_ERROR_UNTRUSTED_ISSUER => Self::IssuerUntrusted,
-            mozpkix::MOZILLA_PKIX_ERROR_ADDITIONAL_POLICY_CONSTRAINT_FAILED => {
-                Self::PolicyRejection
-            }
-            _ => Self::Unknown,
-        }
+        Self::from_repr(v).unwrap_or(Self::Unknown)
     }
 }

diff --git a/neqo-crypto/src/constants.rs b/neqo-crypto/src/constants.rs
--- a/neqo-crypto/src/constants.rs
+++ b/neqo-crypto/src/constants.rs
@@ -5,6 +5,7 @@
 // except according to those terms.
 
 use enum_map::Enum;
+use strum::FromRepr;
 
 use crate::{ssl, Error};
 
@@ -13,7 +14,8 @@ use crate::{ssl, Error};
 
 pub type Alert = u8;
 
-#[derive(Default, Debug, Enum, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
+#[derive(Default, Debug, Enum, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, FromRepr)]
+#[repr(u16)]
 pub enum Epoch {
     // TLS doesn't really have an "initial" concept that maps to QUIC so directly,
     // but this should be clear enough.
@@ -29,24 +31,13 @@ impl TryFrom<u16> for Epoch {
     type Error = Error;
 
     fn try_from(value: u16) -> Result<Self, Self::Error> {
-        match value {
-            0 => Ok(Self::Initial),
-            1 => Ok(Self::ZeroRtt),
-            2 => Ok(Self::Handshake),
-            3 => Ok(Self::ApplicationData),
-            _ => Err(Error::InvalidEpoch),
-        }
+        Self::from_repr(value).ok_or(Error::InvalidEpoch)
     }
 }
 
 impl From<Epoch> for usize {
     fn from(e: Epoch) -> Self {
-        match e {
-            Epoch::Initial => 0,
-            Epoch::ZeroRtt => 1,
-            Epoch::Handshake => 2,
-            Epoch::ApplicationData => 3,
-        }
+        e as Self
     }
 }

diff --git a/neqo-crypto/src/secrets.rs b/neqo-crypto/src/secrets.rs
--- a/neqo-crypto/src/secrets.rs
+++ b/neqo-crypto/src/secrets.rs
@@ -10,6 +10,7 @@ use std::{mem, os::raw::c_void, pin::Pin};
 
 use enum_map::EnumMap;
 use neqo_common::qdebug;
+use strum::FromRepr;
 
 use crate::{
     agentio::as_c_void,
@@ -25,20 +26,18 @@ experimental_api!(SSL_SecretCallback(
     arg: *mut c_void,
 ));
 
-#[derive(Clone, Copy, Debug)]
+#[derive(Clone, Copy, Debug, FromRepr)]
+#[cfg_attr(windows, repr(i32))] // Windows has to be different, of coourse.
+#[cfg_attr(not(windows), repr(u32))]
 pub enum SecretDirection {
-    Read,
-    Write,
+    Read = SSLSecretDirection::ssl_secret_read,
+    Write = SSLSecretDirection::ssl_secret_write,
 }
 
 impl From<SSLSecretDirection::Type> for SecretDirection {
     #[must_use]
     fn from(dir: SSLSecretDirection::Type) -> Self {
-        match dir {
-            SSLSecretDirection::ssl_secret_read => Self::Read,
-            SSLSecretDirection::ssl_secret_write => Self::Write,
-            _ => unreachable!(),
-        }
+        Self::from_repr(dir).expect("Invalid secret direction")
     }
 }

diff --git a/neqo-crypto/src/ssl.rs b/neqo-crypto/src/ssl.rs
--- a/neqo-crypto/src/ssl.rs
+++ b/neqo-crypto/src/ssl.rs
@@ -28,43 +28,27 @@ pub const SECSuccess: SECStatus = _SECStatus_SECSuccess;
 pub const SECFailure: SECStatus = _SECStatus_SECFailure;
 
 #[derive(Debug, Copy, Clone)]
+#[repr(u32)]
 pub enum Opt {
-    Locking,
-    Tickets,
-    OcspStapling,
-    Alpn,
-    ExtendedMasterSecret,
-    SignedCertificateTimestamps,
-    EarlyData,
-    RecordSizeLimit,
-    Tls13CompatMode,
-    HelloDowngradeCheck,
-    SuppressEndOfEarlyData,
-    Grease,
-    EnableChExtensionPermutation,
+    Locking = SSLOption::SSL_NO_LOCKS,
+    Tickets = SSLOption::SSL_ENABLE_SESSION_TICKETS,
+    OcspStapling = SSLOption::SSL_ENABLE_OCSP_STAPLING,
+    Alpn = SSLOption::SSL_ENABLE_ALPN,
+    ExtendedMasterSecret = SSLOption::SSL_ENABLE_EXTENDED_MASTER_SECRET,
+    SignedCertificateTimestamps = SSLOption::SSL_ENABLE_SIGNED_CERT_TIMESTAMPS,
+    EarlyData = SSLOption::SSL_ENABLE_0RTT_DATA,
+    RecordSizeLimit = SSLOption::SSL_RECORD_SIZE_LIMIT,
+    Tls13CompatMode = SSLOption::SSL_ENABLE_TLS13_COMPAT_MODE,
+    HelloDowngradeCheck = SSLOption::SSL_ENABLE_HELLO_DOWNGRADE_CHECK,
+    SuppressEndOfEarlyData = SSLOption::SSL_SUPPRESS_END_OF_EARLY_DATA,
+    Grease = SSLOption::SSL_ENABLE_GREASE,
+    EnableChExtensionPermutation = SSLOption::SSL_ENABLE_CH_EXTENSION_PERMUTATION,
 }
 
 impl Opt {
-    // Cast is safe here because SSLOptions are within the i32 range
-    #[allow(clippy::cast_possible_wrap)]
     #[must_use]
     pub const fn as_int(self) -> PRInt32 {
-        let i = match self {
-            Self::Locking => SSLOption::SSL_NO_LOCKS,
-            Self::Tickets => SSLOption::SSL_ENABLE_SESSION_TICKETS,
-            Self::OcspStapling => SSLOption::SSL_ENABLE_OCSP_STAPLING,
-            Self::Alpn => SSLOption::SSL_ENABLE_ALPN,
-            Self::ExtendedMasterSecret => SSLOption::SSL_ENABLE_EXTENDED_MASTER_SECRET,
-            Self::SignedCertificateTimestamps => SSLOption::SSL_ENABLE_SIGNED_CERT_TIMESTAMPS,
-            Self::EarlyData => SSLOption::SSL_ENABLE_0RTT_DATA,
-            Self::RecordSizeLimit => SSLOption::SSL_RECORD_SIZE_LIMIT,
-            Self::Tls13CompatMode => SSLOption::SSL_ENABLE_TLS13_COMPAT_MODE,
-            Self::HelloDowngradeCheck => SSLOption::SSL_ENABLE_HELLO_DOWNGRADE_CHECK,
-            Self::SuppressEndOfEarlyData => SSLOption::SSL_SUPPRESS_END_OF_EARLY_DATA,
-            Self::Grease => SSLOption::SSL_ENABLE_GREASE,
-            Self::EnableChExtensionPermutation => SSLOption::SSL_ENABLE_CH_EXTENSION_PERMUTATION,
-        };
-        i as PRInt32
+        self as PRInt32
     }
 
     // Some options are backwards, like SSL_NO_LOCKS, so use this to manage that.

diff --git a/neqo-transport/src/connection/mod.rs b/neqo-transport/src/connection/mod.rs
--- a/neqo-transport/src/connection/mod.rs
+++ b/neqo-transport/src/connection/mod.rs
@@ -30,6 +30,7 @@ use neqo_crypto::{
     Server, ZeroRttChecker,
 };
 use smallvec::SmallVec;
+use strum::IntoEnumIterator as _;
 
 use crate::{
     addr_valid::{AddressValidation, NewTokenState},
@@ -2399,7 +2400,7 @@ impl Connection {
         let mut encoder = Encoder::with_capacity(profile.limit());
         for space in PacketNumberSpace::iter() {
             // Ensure we have tx crypto state for this epoch, or skip it.
-            let Some((epoch, tx)) = self.crypto.states.select_tx_mut(self.version, *space) else {
+            let Some((epoch, tx)) = self.crypto.states.select_tx_mut(self.version, space) else {
                 continue;
             };
 
@@ -2416,7 +2417,7 @@ impl Connection {
             let pn = Self::add_packet_number(
                 &mut builder,
                 tx,
-                self.loss_recovery.largest_acknowledged_pn(*space),
+                self.loss_recovery.largest_acknowledged_pn(space),
             );
             // The builder will set the limit to 0 if there isn't enough space for the header.
             if builder.is_full() {
@@ -2445,10 +2446,10 @@ impl Connection {
             let payload_start = builder.len();
             let (mut tokens, mut ack_eliciting, mut padded) = (Vec::new(), false, false);
             if let Some(close) = closing_frame {
-                self.write_closing_frames(close, &mut builder, *space, now, path, &mut tokens);
+                self.write_closing_frames(close, &mut builder, space, now, path, &mut tokens);
             } else {
                 (tokens, ack_eliciting, padded) =
-                    self.write_frames(path, *space, &profile, &mut builder, header_start != 0, now);
+                    self.write_frames(path, space, &profile, &mut builder, header_start != 0, now);
             }
             if builder.packet_empty() {
                 // Nothing to include in this packet.
@@ -2503,7 +2504,7 @@ impl Connection {
                 self.loss_recovery.on_packet_sent(path, sent, now);
             }
 
-            if *space == PacketNumberSpace::Handshake
+            if space == PacketNumberSpace::Handshake
                 && self.role == Role::Server
                 && self.state == State::Confirmed
             {
@@ -2518,8 +2519,8 @@ impl Connection {
             // do not support, because they may not save packets they can't
             // decrypt yet.
             if self.role == Role::Client
-                && *space == PacketNumberSpace::Initial
-                && !self.crypto.streams.is_empty(*space)
+                && space == PacketNumberSpace::Initial
+                && !self.crypto.streams.is_empty(space)
             {
                 break;
             }

diff --git a/neqo-transport/src/frame.rs b/neqo-transport/src/frame.rs
--- a/neqo-transport/src/frame.rs
+++ b/neqo-transport/src/frame.rs
@@ -9,6 +9,7 @@
 use std::ops::RangeInclusive;
 
 use neqo_common::{qtrace, Decoder, Encoder};
+use strum::FromRepr;
 
 use crate::{
     cid::MAX_CONNECTION_ID_LEN,
@@ -19,7 +20,7 @@ use crate::{
 };
 
 #[repr(u64)]
-#[derive(Debug, Clone, Copy, PartialEq, Eq)]
+#[derive(Debug, Clone, Copy, PartialEq, Eq, FromRepr)]
 pub enum FrameType {
     Padding = 0x0,
     Ping = 0x1,
@@ -75,43 +76,7 @@ impl TryFrom<u64> for FrameType {
     type Error = Error;
 
     fn try_from(value: u64) -> Result<Self, Self::Error> {
-        match value {
-            0x0 => Ok(Self::Padding),
-            0x1 => Ok(Self::Ping),
-            0x2 => Ok(Self::Ack),
-            0x3 => Ok(Self::AckEcn),
-            0x4 => Ok(Self::ResetStream),
-            0x5 => Ok(Self::StopSending),
-            0x6 => Ok(Self::Crypto),
-            0x7 => Ok(Self::NewToken),
-            0x8 => Ok(Self::Stream),
-            0x9 => Ok(Self::StreamWithFin),
-            0xa => Ok(Self::StreamWithLen),
-            0xb => Ok(Self::StreamWithLenFin),
-            0xc => Ok(Self::StreamWithOff),
-            0xd => Ok(Self::StreamWithOffFin),
-            0xe => Ok(Self::StreamWithOffLen),
-            0xf => Ok(Self::StreamWithOffLenFin),
-            0x10 => Ok(Self::MaxData),
-            0x11 => Ok(Self::MaxStreamData),
-            0x12 => Ok(Self::MaxStreamsBiDi),
-            0x13 => Ok(Self::MaxStreamsUniDi),
-            0x14 => Ok(Self::DataBlocked),
-            0x15 => Ok(Self::StreamDataBlocked),
-            0x16 => Ok(Self::StreamsBlockedBiDi),
-            0x17 => Ok(Self::StreamsBlockedUniDi),
-            0x18 => Ok(Self::NewConnectionId),
-            0x19 => Ok(Self::RetireConnectionId),
-            0x1a => Ok(Self::PathChallenge),
-            0x1b => Ok(Self::PathResponse),
-            0x1c => Ok(Self::ConnectionCloseTransport),
-            0x1d => Ok(Self::ConnectionCloseApplication),
-            0x1e => Ok(Self::HandshakeDone),
-            0xaf => Ok(Self::AckFrequency),
-            0x30 => Ok(Self::Datagram),
-            0x31 => Ok(Self::DatagramWithLen),
-            _ => Err(Error::UnknownFrameType),
-        }
+        Self::from_repr(value).ok_or(Error::UnknownFrameType)
     }
 }

diff --git a/neqo-transport/src/recovery/mod.rs b/neqo-transport/src/recovery/mod.rs
--- a/neqo-transport/src/recovery/mod.rs
+++ b/neqo-transport/src/recovery/mod.rs
@@ -24,6 +24,7 @@ use enum_map::{enum_map, EnumMap};
 use neqo_common::{qdebug, qinfo, qlog::NeqoQlog, qtrace, qwarn};
 pub use sent::SentPacket;
 use sent::SentPackets;
+use strum::IntoEnumIterator as _;
 pub use token::{RecoveryToken, StreamRecoveryToken};
 
 use crate::{
@@ -825,17 +826,17 @@ impl LossRecovery {
         // The spaces in which we will allow probing.
         let mut allow_probes = PacketNumberSpaceSet::default();
         for pn_space in PacketNumberSpace::iter() {
-            if let Some(t) = self.pto_time(rtt, *pn_space) {
-                allow_probes[*pn_space] = true;
+            if let Some(t) = self.pto_time(rtt, pn_space) {
+                allow_probes[pn_space] = true;
                 if t <= now {
                     qdebug!("[{self}] PTO timer fired for {pn_space}");
-                    if let Some(space) = self.spaces.get_mut(*pn_space) {
+                    if let Some(space) = self.spaces.get_mut(pn_space) {
                         lost.extend(
                             space
-                                .pto_packets(PtoState::pto_packet_count(*pn_space))
+                                .pto_packets(PtoState::pto_packet_count(pn_space))
                                 .cloned(),
                         );
-                        pto_space = pto_space.or(Some(*pn_space));
+                        pto_space = pto_space.or(Some(pn_space));
                     }
                 }
             }

diff --git a/neqo-transport/src/tparams.rs b/neqo-transport/src/tparams.rs
--- a/neqo-transport/src/tparams.rs
+++ b/neqo-transport/src/tparams.rs
@@ -20,6 +20,7 @@ use neqo_crypto::{
     ext::{ExtensionHandler, ExtensionHandlerResult, ExtensionWriterResult},
     random, HandshakeMessage, ZeroRttCheckResult, ZeroRttChecker,
 };
+use strum::FromRepr;
 use TransportParameterId::{
     AckDelayExponent, ActiveConnectionIdLimit, DisableMigration, GreaseQuicBit, IdleTimeout,
     InitialMaxData, InitialMaxStreamDataBidiLocal, InitialMaxStreamDataBidiRemote,
@@ -36,7 +37,7 @@ use crate::{
     Error, Res,
 };
 
-#[derive(Debug, Clone, Enum, PartialEq, Eq, Copy)]
+#[derive(Debug, Clone, Enum, PartialEq, Eq, Copy, FromRepr)]
 #[repr(u64)]
 pub enum TransportParameterId {
     OriginalDestinationConnectionId = 0x00,
@@ -80,32 +81,7 @@ impl TryFrom<u64> for TransportParameterId {
     type Error = Error;
 
     fn try_from(value: u64) -> Result<Self, Self::Error> {
-        match value {
-            0x00 => Ok(Self::OriginalDestinationConnectionId),
-            0x01 => Ok(Self::IdleTimeout),
-            0x02 => Ok(Self::StatelessResetToken),
-            0x03 => Ok(Self::MaxUdpPayloadSize),
-            0x04 => Ok(Self::InitialMaxData),
-            0x05 => Ok(Self::InitialMaxStreamDataBidiLocal),
-            0x06 => Ok(Self::InitialMaxStreamDataBidiRemote),
-            0x07 => Ok(Self::InitialMaxStreamDataUni),
-            0x08 => Ok(Self::InitialMaxStreamsBidi),
-            0x09 => Ok(Self::InitialMaxStreamsUni),
-            0x0a => Ok(Self::AckDelayExponent),
-            0x0b => Ok(Self::MaxAckDelay),
-            0x0c => Ok(Self::DisableMigration),
-            0x0d => Ok(Self::PreferredAddress),
-            0x0e => Ok(Self::ActiveConnectionIdLimit),
-            0x0f => Ok(Self::InitialSourceConnectionId),
-            0x10 => Ok(Self::RetrySourceConnectionId),
-            0x11 => Ok(Self::VersionInformation),
-            0x2ab2 => Ok(Self::GreaseQuicBit),
-            0xff02_de1a => Ok(Self::MinAckDelay),
-            0x0020 => Ok(Self::MaxDatagramFrameSize),
-            #[cfg(test)]
-            0xce16 => Ok(Self::TestTransportParameter),
-            _ => Err(Error::UnknownTransportParameter),
-        }
+        Self::from_repr(value).ok_or(Error::UnknownTransportParameter)
     }
 }

diff --git a/neqo-transport/src/tracking.rs b/neqo-transport/src/tracking.rs
--- a/neqo-transport/src/tracking.rs
+++ b/neqo-transport/src/tracking.rs
@@ -16,6 +16,7 @@ use std::{
 use enum_map::{enum_map, Enum, EnumMap};
 use neqo_common::{qdebug, qinfo, qtrace, qwarn, IpTosEcn};
 use neqo_crypto::Epoch;
+use strum::{EnumIter, IntoEnumIterator as _};
 
 use crate::{
     ecn,
@@ -26,24 +27,13 @@ use crate::{
     Error, Res,
 };
 
-#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Ord, Eq, Enum)]
+#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Ord, Eq, Enum, EnumIter)]
 pub enum PacketNumberSpace {
     Initial,
     Handshake,
     ApplicationData,
 }
 
-impl PacketNumberSpace {
-    pub fn iter() -> impl Iterator<Item = &'static Self> {
-        const SPACES: &[PacketNumberSpace] = &[
-            PacketNumberSpace::Initial,
-            PacketNumberSpace::Handshake,
-            PacketNumberSpace::ApplicationData,
-        ];
-        SPACES.iter()
-    }
-}
-
 impl From<Epoch> for PacketNumberSpace {
     fn from(epoch: Epoch) -> Self {
         match epoch {
@@ -122,12 +112,12 @@ impl std::fmt::Debug for PacketNumberSpaceSet {
         let mut first = true;
         f.write_str("(")?;
         for sp in PacketNumberSpace::iter() {
-            if self[*sp] {
+            if self[sp] {
                 if !first {
                     f.write_str("+")?;
                     first = false;
                 }
-                std::fmt::Display::fmt(sp, f)?;
+                std::fmt::Display::fmt(&sp, f)?;
             }
         }
         f.write_str(")")


</patch>

Function signatures
<Signatures>

</Signatures>

You are a software tester at neqo and your are reviewing the above <patch> for the above <issue>
Identify whether a unit test is needed.
If there is no test needed, return <NO>.
If a test is needed, your task is:
1. Write exactly one rust test `#[test]fn test_...(){...}` block. Do NOT wrap the test inside a 'mod tests' block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. All 'use' declarations must be inside a <imports>...</imports> block.
 Use `use super::<function name> for the function under test.
.If multiple 'use' statements are needed, list each on a separate line.
5. To help you write the test, <Signatures> contains all modified function's:
- name
- parameters
- Return type (assume '()' if empty)
6. Return only the absolute filename as it is in the <patch> block, the use statements, and rust test (no comments or explanations).

Here is an example structure:
<Filename> ... </Filename>
<imports> ... </imports>
<Rust>
#[test]
fn test_<describe_behavior>() {
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
}</Rust>

