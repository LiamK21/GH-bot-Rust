<think>
Okay, so I'm trying to figure out how to write a regression test for this patch in the Neqo project. Let me start by understanding the issue and the patch.

The bug in question is Bug 1727148. From the provided link, it seems that the problem was related to the `rtt.update` method being called with a negative sample when `send_time` is in the future relative to `now`. That would cause the `sample` to be negative, which doesn't make sense for an RTT measurement.

Looking at the patch, the code before was calculating `sample` as `now - send_time` and then directly calling `rtt.update`. The patch changes this by first checking if `send_time` is before `now` using `checked_duration_since`, which returns `None` if `send_time` is in the future. So, the `rtt.update` is now only called when `sample` is a valid positive duration.

Now, I need to determine if a unit test is necessary. Since this is a bug fix, a test is definitely needed to ensure the issue is resolved. The test should verify that when `send_time` is after `now`, `rtt.update` isn't called, preventing negative samples.

I'll structure the test by setting up a scenario where `send_time` is in the future. I'll create a `LossRecovery` instance and call `on_ack` with these times. I'll also need a mock or a way to check if `rtt.update` was called. Since the code uses `rtt.update`, perhaps I can use a boolean flag in the test to track if it's called.

Wait, but in Rust, functions are called, so maybe I can use a test double or a spy to track calls to `rtt.update`. Alternatively, I can check the state of `rtt` after the call. Hmm, perhaps for simplicity, since the test is about not calling `update` when `send_time` is in the future, I can have a flag that's set when `update` is called and assert that it remains false.

But wait, in the code, `rtt` is a field in `LossRecovery`, so I can't easily mock it. Maybe I can create a test `Rtt` struct that logs when `update` is called. Let me think about how to do that.

Alternatively, since the test is about ensuring `update` isn't called, perhaps I can have a test where `send_time` is after `now`, and then check that `update` wasn't called. But without a way to track calls, maybe I can check the state of `rtt` before and after. But that might be complicated.

Wait, perhaps the `Rtt` struct has some public fields or methods that can be inspected. If not, maybe I can create a test `Rtt` that just counts the number of times `update` is called. So, in the test setup, I can create an `Rtt` instance that, when `update` is called, increments a counter. Then, in the test, I can assert that the counter remains zero when `send_time` is in the future.

So, the plan is:

1. Create a `TestRtt` struct that implements the same traits as `Rtt` (or has the same methods) and tracks whether `update` was called.
2. In the test, set `send_time` to a time after `now`.
3. Call `on_ack` with these times.
4. Assert that `update` was not called by checking the counter in `TestRtt`.

But looking at the code, the `rtt` is of type `Rtt`, which is a struct in the same module. So, perhaps I can create a mock `Rtt` for testing purposes.

Wait, but in the test, I can create a struct that implements the necessary traits. Alternatively, since `Rtt` is a struct, perhaps I can create a test double that just records whether `update` was called.

Let me outline the steps:

- Import necessary modules, including `Duration` and `SystemTime` for time handling.
- Define a `TestRtt` struct that has a `called` boolean.
- Implement the `update` method for `TestRtt` to set `called` to true.
- In the test, create a `LossRecovery` instance with this `TestRtt`.
- Set `send_time` to a future time, say 1 second after `now`.
- Call `on_ack` with `send_time` and `now` being the current time.
- After the call, check that `TestRtt`'s `called` is still false.

Wait, but in the code, `on_ack` is a method of `LossRecovery`, which takes `send_time` and `now` as parameters. So, in the test, I can set `send_time` to be after `now`, and then call `on_ack`.

So, the test setup would be:

- Let `now` be the current time.
- Let `send_time` be `now + 1 second`.
- Create a `LossRecovery` instance, initializing `rtt` with `TestRtt`.
- Call `on_ack` with `send_time` and `now`.
- Assert that `TestRtt`'s `called` is false.

This would test that when `send_time` is in the future, `rtt.update` isn't called, thus avoiding the bug.

I also need to make sure that the test fails before the patch and passes after. So, without the patch, when `send_time` is in the future, `rtt.update` would be called with a negative sample, which is incorrect. The test would catch that because `called` would be true, making the test fail. After the patch, `called` remains false, so the test passes.

I think that's a solid approach. Now, I need to write the Rust code for this test.

First, I'll define `TestRtt` as a struct with a `called` flag. Then, implement the `update` method to set this flag. In the test, I'll create an instance of `LossRecovery` with this `TestRtt`, set up the times, call `on_ack`, and assert that `called` is false.

I should also handle the `qlog` parameter, which is a mutable reference. Since it's not used in the test, I can pass a dummy value, perhaps an empty slice or a mock.

Wait, looking at the `on_ack` method signature, it's:

fn on_ack(&mut self, send_time: SystemTime, ack_delay: Duration, now: SystemTime)

So, in the test, I need to provide `send_time`, `ack_delay`, and `now`. `ack_delay` can be a zero duration for the test.

Putting it all together, the test will:

1. Import necessary items.
2. Define `TestRtt` and implement `update` to track calls.
3. In the test function, create a `LossRecovery` instance with `TestRtt`.
4. Set `send_time` to a future time.
5. Call `on_ack` with these parameters.
6. Assert that `TestRtt`'s `called` is false.

I think that's the correct approach. Now, I'll write the code accordingly.
</think>

<Filename>neqo-transport/src/recovery.rs</Filename>
<imports>
use std::time::{Duration, SystemTime};
use super::recovery::LossRecovery;
</imports>
<Rust>
struct TestRtt {
    called: bool,
}

impl TestRtt {
    fn new() -> Self {
        Self { called: false }
    }
}

impl TestRtt {
    fn update(&mut self, _qlog: &mut dyn crate::qlog::QLog, _sample: Duration, _ack_delay: Duration, _confirmed: bool, _now: SystemTime) {
        self.called = true;
    }
}

#[test]
fn test_rtt_update_not_called_when_send_time_is_future() {
    let mut loss_recovery = LossRecovery {
        // Initialize other fields as needed, assuming default or mock values
        rtt: TestRtt::new(),
        ..Default::default()
    };
    
    let now = SystemTime::now();
    let send_time = now + Duration::from_secs(1);
    let ack_delay = Duration::from_secs(0);
    
    loss_recovery.on_ack(send_time, ack_delay, now);
    
    assert!(!loss_recovery.rtt.called, "rtt.update should not be called when send_time is in the future");
}
</Rust>