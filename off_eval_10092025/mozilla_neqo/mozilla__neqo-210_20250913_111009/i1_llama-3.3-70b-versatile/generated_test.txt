#[test]
fn test_aead_impl() {
  let p = [1, 2, 3];
  let version: u32 = 1;
  let cipher: u32 = 2;
  let secret = [4, 5, 6];
  let mut ctx: u32 = 0;
  let len = p.len() as u32;

  let result_before_patch: i32 = unsafe { 
    let ptr_i8 = p.as_ptr() as *const i8;
    let secret_ptr = secret.as_ptr();
    let ctx_ptr = &mut ctx as *mut u32;
    // simulate the before patch scenario
    let result = std::mem::transmute::<*const i8, extern "C" fn (*const i8, u32, *const u8, u32, *mut u32) -> i32>(0x0)(ptr_i8, version, secret_ptr, len, ctx_ptr);
    result
  };

  let result_after_patch: i32 = unsafe { 
    let ptr_c_char = p.as_ptr() as *const c_char;
    let secret_ptr = secret.as_ptr();
    let ctx_ptr = &mut ctx as *mut u32;
    // simulate the after patch scenario
    let result = std::mem::transmute::<*const c_char, extern "C" fn (*const c_char, u32, *const u8, u32, *mut u32) -> i32>(0x0)(ptr_c_char, version, secret_ptr, len, ctx_ptr);
    result
  };

  assert_ne!(result_before_patch, result_after_patch);
}