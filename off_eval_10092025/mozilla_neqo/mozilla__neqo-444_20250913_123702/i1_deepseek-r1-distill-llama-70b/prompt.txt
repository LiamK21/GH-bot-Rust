Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Changing how we read headers
The current implementation reads HEADER frame only up to its length and leas the rest on the stream. This was implemented in this way thinking about hot necko reads data. I think this can be make simpler by reading the complete header.
Also we should supply headers in the HeaderReady event instead of letting app pick it up, again this is make this way because the way necko streams work, but I think I can make it work in necko even if HeaderReady event supplies the header block and I think the code will be not too terrible.

</issue>

Patch:
<patch>
diff --git a/neqo-http3/src/connection_client.rs b/neqo-http3/src/connection_client.rs
--- a/neqo-http3/src/connection_client.rs
+++ b/neqo-http3/src/connection_client.rs
@@ -709,6 +709,18 @@ mod tests {
         0x43, 0xd3, 0xc1,
     ];
 
+    const HTTP_HEADER_FRAME_0: &[u8] = &[0x01, 0x06, 0x00, 0x00, 0xd9, 0x54, 0x01, 0x30];
+
+    // The response header from HTTP_HEADER_FRAME (0x01, 0x06, 0x00, 0x00, 0xd9, 0x54, 0x01, 0x30) are
+    // decoded into:
+    fn check_response_header_0(header: Vec<Header>) {
+        let expected_response_header_1 = vec![
+            (String::from(":status"), String::from("200")),
+            (String::from("content-length"), String::from("0")),
+        ];
+        assert_eq!(header, expected_response_header_1);
+    }
+
     const HTTP_RESPONSE_1: &[u8] = &[
         // headers
         0x01, 0x06, 0x00, 0x00, 0xd9, 0x54, 0x01, 0x37, // the first data frame
@@ -2317,11 +2329,10 @@ mod tests {
             .encoder
             .encode_header_block(&headers, request_stream_id);
         let hframe = HFrame::Headers {
-            len: encoded_headers.len() as u64,
+            header_block: encoded_headers.to_vec(),
         };
         let mut d = Encoder::default();
         hframe.encode(&mut d);
-        d.encode(&encoded_headers);
         let d_frame = HFrame::Data { len: 3 };
         d_frame.encode(&mut d);
         d.encode(&[0x61, 0x62, 0x63]);
@@ -2364,6 +2375,60 @@ mod tests {
         assert!(recv_header && recv_data);
     }
 
+    #[test]
+    fn test_read_frames_header_blocked_with_fin_after_headers() {
+        let (mut hconn, mut server, request_stream_id) = connect_and_send_request(true);
+
+        server.encoder.set_max_capacity(100).unwrap();
+        server.encoder.set_max_blocked_streams(100).unwrap();
+
+        let headers = vec![
+            (String::from(":status"), String::from("200")),
+            (String::from("my-header"), String::from("my-header")),
+            (String::from("content-length"), String::from("0")),
+        ];
+        let encoded_headers = server
+            .encoder
+            .encode_header_block(&headers, request_stream_id);
+        let hframe = HFrame::Headers {
+            header_block: encoded_headers.to_vec(),
+        };
+        let mut d = Encoder::default();
+        hframe.encode(&mut d);
+
+        let _ = server.conn.stream_send(request_stream_id, &d[..]);
+        server.conn.stream_close_send(request_stream_id).unwrap();
+
+        // Send response before sending encoder instructions.
+        let out = server.conn.process(None, now());
+        let _out = hconn.process(out.dgram(), now());
+
+        let header_ready_event = |e| matches!(e, Http3ClientEvent::HeaderReady { .. });
+        assert!(!hconn.events().any(header_ready_event));
+
+        // Send encoder instructions to unblock the stream.
+        server.encoder.send(&mut server.conn).unwrap();
+
+        let out = server.conn.process(None, now());
+        let _out = hconn.process(out.dgram(), now());
+        let _out = hconn.process(None, now());
+
+        let mut recv_header = false;
+        // Now the stream is unblocked. After headers we will receive a fin.
+        while let Some(e) = hconn.next_event() {
+            if let Http3ClientEvent::HeaderReady { stream_id } = e {
+                assert_eq!(stream_id, request_stream_id);
+                let (h, fin) = hconn.read_response_headers(stream_id).unwrap();
+                assert_eq!(h, headers);
+                assert_eq!(fin, true);
+                recv_header = true;
+            } else {
+                panic!("event {:?}", e);
+            }
+        }
+        assert!(recv_header);
+    }
+
     fn check_control_qpack_request_streams_resumption(
         server: &mut Connection,
         expect_encoder_stream_data: &[u8],
@@ -2907,4 +2972,171 @@ mod tests {
             ENCODER_STREAM_DATA_WITH_CAP_INSTRUCTION,
         );
     }
+
+    #[test]
+    fn test_trailers_with_fin_after_headers() {
+        // Make a new connection.
+        let (mut client, mut server, request_stream_id) = connect_and_send_request(true);
+
+        // Send HEADER frame.
+        let _ = server
+            .conn
+            .stream_send(request_stream_id, HTTP_HEADER_FRAME_0);
+
+        let out = server.conn.process(None, now());
+        client.process(out.dgram(), now());
+
+        // Check response headers.
+        let mut response_headers = false;
+        while let Some(e) = client.next_event() {
+            if let Http3ClientEvent::HeaderReady { stream_id } = e {
+                assert_eq!(stream_id, request_stream_id);
+                let (h, fin) = client.read_response_headers(stream_id).unwrap();
+                check_response_header_0(h);
+                assert_eq!(fin, false);
+                response_headers = true;
+            }
+        }
+        assert!(response_headers);
+
+        // Send trailers
+        let _ = server
+            .conn
+            .stream_send(request_stream_id, HTTP_HEADER_FRAME_0);
+        server.conn.stream_close_send(request_stream_id).unwrap();
+
+        let out = server.conn.process(None, now());
+        client.process(out.dgram(), now());
+
+        let events: Vec<Http3ClientEvent> = client.events().collect();
+
+        // We already had HeaderReady
+        let header_ready: fn(&Http3ClientEvent) -> _ =
+            |e| matches!(*e, Http3ClientEvent::HeaderReady { .. });
+        assert!(!events.clone().iter().any(header_ready));
+
+        // Check that we have a DataReady event. Reading from the stream will return fin=true.
+        let data_readable: fn(&Http3ClientEvent) -> _ =
+            |e| matches!(*e, Http3ClientEvent::DataReadable { .. });
+        assert!(events.iter().any(data_readable));
+        let mut buf = [0u8; 100];
+        let (len, fin) = client
+            .read_response_data(now(), request_stream_id, &mut buf)
+            .unwrap();
+        assert_eq!(0, len);
+        assert_eq!(fin, true)
+    }
+
+    #[test]
+    fn test_trailers_with_later_fin_after_headers() {
+        // Make a new connection.
+        let (mut client, mut server, request_stream_id) = connect_and_send_request(true);
+
+        // Send HEADER frame.
+        let _ = server
+            .conn
+            .stream_send(request_stream_id, HTTP_HEADER_FRAME_0);
+
+        let out = server.conn.process(None, now());
+        client.process(out.dgram(), now());
+
+        // Check response headers.
+        let mut response_headers = false;
+        while let Some(e) = client.next_event() {
+            if let Http3ClientEvent::HeaderReady { stream_id } = e {
+                assert_eq!(stream_id, request_stream_id);
+                let (h, fin) = client.read_response_headers(stream_id).unwrap();
+                check_response_header_0(h);
+                assert_eq!(fin, false);
+                response_headers = true;
+            }
+        }
+        assert!(response_headers);
+
+        // Send trailers
+        let _ = server
+            .conn
+            .stream_send(request_stream_id, HTTP_HEADER_FRAME_0);
+
+        let out = server.conn.process(None, now());
+        client.process(out.dgram(), now());
+
+        // Check that we do not have a DataReady event.
+        let data_readable = |e| matches!(e, Http3ClientEvent::DataReadable { .. });
+        assert!(!client.events().any(data_readable));
+
+        server.conn.stream_close_send(request_stream_id).unwrap();
+
+        let out = server.conn.process(None, now());
+        client.process(out.dgram(), now());
+
+        let events: Vec<Http3ClientEvent> = client.events().collect();
+
+        // We already had HeaderReady
+        let header_ready: fn(&Http3ClientEvent) -> _ =
+            |e| matches!(*e, Http3ClientEvent::HeaderReady { .. });
+        assert!(!events.clone().iter().any(header_ready));
+
+        // Check that we have a DataReady event. Reading from the stream will return fin=true.
+        let data_readable: fn(&Http3ClientEvent) -> _ =
+            |e| matches!(*e, Http3ClientEvent::DataReadable { .. });
+        assert!(events.iter().any(data_readable));
+        let mut buf = [0u8; 100];
+        let (len, fin) = client
+            .read_response_data(now(), request_stream_id, &mut buf)
+            .unwrap();
+        assert_eq!(0, len);
+        assert_eq!(fin, true);
+    }
+
+    #[test]
+    fn test_data_after_trailers_after_headers() {
+        // Make a new connection.
+        let (mut client, mut server, request_stream_id) = connect_and_send_request(true);
+
+        // Send HEADER frame.
+        let _ = server
+            .conn
+            .stream_send(request_stream_id, HTTP_HEADER_FRAME_0);
+
+        let out = server.conn.process(None, now());
+        client.process(out.dgram(), now());
+
+        // Check response headers.
+        let mut response_headers = false;
+        while let Some(e) = client.next_event() {
+            if let Http3ClientEvent::HeaderReady { stream_id } = e {
+                assert_eq!(stream_id, request_stream_id);
+                let (h, fin) = client.read_response_headers(stream_id).unwrap();
+                check_response_header_0(h);
+                assert_eq!(fin, false);
+                response_headers = true;
+            }
+        }
+        assert!(response_headers);
+
+        // Send trailers
+        let _ = server
+            .conn
+            .stream_send(request_stream_id, HTTP_HEADER_FRAME_0);
+
+        let out = server.conn.process(None, now());
+        client.process(out.dgram(), now());
+        // Check that we do not have a DataReady event.
+        let data_readable = |e| matches!(e, Http3ClientEvent::DataReadable { .. });
+        assert!(!client.events().any(data_readable));
+
+        // Send Data frame.
+        let _ = server.conn.stream_send(
+            request_stream_id,
+            &[
+                // data frame
+                0x0, 0x3, 0x61, 0x62, 0x63,
+            ],
+        );
+
+        let out = server.conn.process(None, now());
+        client.process(out.dgram(), now());
+        assert_closed(&client, Error::HttpFrameUnexpected);
+    }
 }

diff --git a/neqo-http3/src/hframe.rs b/neqo-http3/src/hframe.rs
--- a/neqo-http3/src/hframe.rs
+++ b/neqo-http3/src/hframe.rs
@@ -32,14 +32,14 @@ pub enum HStreamType {
     Push,
 }
 
-// data for DATA and header blocks for HEADERS anf PUSH_PROMISE are not read into HFrame.
+// data for DATA frame is not read into HFrame::Data.
 #[derive(PartialEq, Debug)]
 pub enum HFrame {
     Data {
         len: u64, // length of the data
     },
     Headers {
-        len: u64, // length of the header block
+        header_block: Vec<u8>,
     },
     CancelPush {
         push_id: u64,
@@ -80,10 +80,13 @@ impl HFrame {
         enc.encode_varint(self.get_type());
 
         match self {
-            Self::Data { len } | Self::Headers { len } => {
-                // DATA and HEADERS frames only encode the length here.
+            Self::Data { len } => {
+                // DATA frame only encode the length here.
                 enc.encode_varint(*len);
             }
+            Self::Headers { header_block } => {
+                enc.encode_vvec(header_block);
+            }
             Self::CancelPush { push_id } => {
                 enc.encode_vvec_with(|enc_inner| {
                     enc_inner.encode_varint(*push_id);
@@ -235,10 +238,8 @@ impl HFrameReader {
                             );
                             self.hframe_len = len;
                             self.state = match self.hframe_type {
-                                // DATA and HEADERS payload are left on the quic stream and picked up separately
-                                H3_FRAME_TYPE_DATA | H3_FRAME_TYPE_HEADERS => {
-                                    HFrameReaderState::Done
-                                }
+                                // DATA payload are left on the quic stream and picked up separately
+                                H3_FRAME_TYPE_DATA => HFrameReaderState::Done,
 
                                 // for other frames get all data before decoding.
                                 H3_FRAME_TYPE_CANCEL_PUSH
@@ -246,7 +247,8 @@ impl HFrameReader {
                                 | H3_FRAME_TYPE_GOAWAY
                                 | H3_FRAME_TYPE_MAX_PUSH_ID
                                 | H3_FRAME_TYPE_DUPLICATE_PUSH
-                                | H3_FRAME_TYPE_PUSH_PROMISE => {
+                                | H3_FRAME_TYPE_PUSH_PROMISE
+                                | H3_FRAME_TYPE_HEADERS => {
                                     if len == 0 {
                                         HFrameReaderState::Done
                                     } else {
@@ -329,7 +331,7 @@ impl HFrameReader {
                 len: self.hframe_len,
             },
             H3_FRAME_TYPE_HEADERS => HFrame::Headers {
-                len: self.hframe_len,
+                header_block: dec.decode_remainder().to_vec(),
             },
             H3_FRAME_TYPE_CANCEL_PUSH => HFrame::CancelPush {
                 push_id: match dec.decode_varint() {
@@ -448,8 +450,10 @@ mod tests {
 
     #[test]
     fn test_headers_frame() {
-        let f = HFrame::Headers { len: 3 };
-        enc_dec(&f, "0103010203", 3);
+        let f = HFrame::Headers {
+            header_block: vec![0x01, 0x02, 0x03],
+        };
+        enc_dec(&f, "0103010203", 0);
     }
 
     #[test]
@@ -493,10 +497,9 @@ mod tests {
         enc_dec(&f, "0e0105", 0);
     }
 
-    // We have 3 code paths in frame_reader:
-    // 1) All frames except DATA, HEADERES and PUSH_PROMISE (here we test SETTING and SETTINGS with larger varints)
-    // 2) PUSH_PROMISE and
-    // 1) DATA and HEADERS frame (for this we will test DATA)
+    // We have 2 code paths in frame_reader:
+    // 1) All frames except DATA (here we test SETTING and SETTINGS with larger varints and PUSH_PROMISE)
+    // 1) DATA
 
     // Test SETTINGS
     #[test]
@@ -914,6 +917,7 @@ mod tests {
     #[test]
     fn test_complete_and_incomplete_frames() {
         const FRAME_LEN: usize = 10;
+        const HEADER_BLOCK: &[u8] = &[0x01, 0x02, 0x03, 0x04];
 
         // H3_FRAME_TYPE_DATA len=0
         let f = HFrame::Data { len: 0 };
@@ -932,22 +936,23 @@ mod tests {
         buf.resize(FRAME_LEN + buf.len(), 0);
         test_complete_and_incomplete_frame(&buf, 2);
 
-        // H3_FRAME_TYPE_HEADERS len=0
-        let f = HFrame::Data { len: 0 };
-        let mut enc = Encoder::with_capacity(2);
+        // H3_FRAME_TYPE_HEADERS empty header block
+        let f = HFrame::Headers {
+            header_block: Vec::new(),
+        };
+        let mut enc = Encoder::default();
         f.encode(&mut enc);
         let buf: Vec<_> = enc.into();
         test_complete_and_incomplete_frame(&buf, 2);
 
-        // H3_FRAME_TYPE_HEADERS len=FRAME_LEN
+        // H3_FRAME_TYPE_HEADERS
         let f = HFrame::Headers {
-            len: FRAME_LEN as u64,
+            header_block: HEADER_BLOCK.to_vec(),
         };
-        let mut enc = Encoder::with_capacity(2);
+        let mut enc = Encoder::default();
         f.encode(&mut enc);
-        let mut buf: Vec<_> = enc.into();
-        buf.resize(FRAME_LEN + buf.len(), 0);
-        test_complete_and_incomplete_frame(&buf, 2);
+        let buf: Vec<_> = enc.into();
+        test_complete_and_incomplete_frame(&buf, buf.len());
 
         // H3_FRAME_TYPE_CANCEL_PUSH
         let f = HFrame::CancelPush { push_id: 5 };
@@ -968,7 +973,7 @@ mod tests {
         // H3_FRAME_TYPE_PUSH_PROMISE
         let f = HFrame::PushPromise {
             push_id: 4,
-            header_block: vec![0x01, 0x02, 0x03, 0x04],
+            header_block: HEADER_BLOCK.to_vec(),
         };
         let mut enc = Encoder::default();
         f.encode(&mut enc);

diff --git a/neqo-http3/src/lib.rs b/neqo-http3/src/lib.rs
--- a/neqo-http3/src/lib.rs
+++ b/neqo-http3/src/lib.rs
@@ -15,6 +15,7 @@ mod control_stream_local;
 mod control_stream_remote;
 pub mod hframe;
 mod hsettings_frame;
+mod response_stream;
 pub mod server;
 mod server_connection_events;
 mod server_events;

diff --git a/neqo-http3/src/response_stream.rs b/neqo-http3/src/response_stream.rs
--- a/neqo-http3/src/response_stream.rs
+++ b/neqo-http3/src/response_stream.rs
@@ -0,0 +1,300 @@
+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
+// option. This file may not be copied, modified, or distributed
+// except according to those terms.
+
+use crate::client_events::Http3ClientEvents;
+use crate::hframe::{HFrame, HFrameReader};
+use crate::{Error, Header, Res};
+use neqo_common::{matches, qdebug, qinfo, qtrace};
+use neqo_qpack::decoder::QPackDecoder;
+use neqo_transport::Connection;
+use std::cmp::min;
+use std::mem;
+
+/*
+ * Response stream state:
+ *    WaitingForResponseHeaders : we wait for headers. in this state we can
+ *                                also get a PUSH_PROMISE frame.
+ *    DecodingHeaders : In this step the headers will be decoded. The stream
+ *                      may be blocked in this state on encoder instructions.
+ *    WaitingForData : we got HEADERS, we are waiting for one or more data
+ *                     frames. In this state we can receive one or more
+ *                     PUSH_PROMIS frames or a HEADERS frame carrying trailers.
+ *    ReadingData : we got a DATA frame, now we letting the app read payload.
+ *                  From here we will go back to WaitingForData state to wait
+ *                  for more data frames or to CLosed state
+ *    ClosePending : waiting for app to pick up data, after that we can delete
+ * the TransactionClient.
+ *    Closed
+ */
+#[derive(PartialEq, Debug)]
+enum ResponseStreamState {
+    WaitingForResponseHeaders,
+    DecodingHeaders { header_block: Vec<u8>, fin: bool },
+    WaitingForData,
+    ReadingData { remaining_data_len: usize },
+    WaitingForFinAfterTrailers,
+    ClosePending, // Close must first be read by application
+    Closed,
+}
+
+#[derive(Debug, PartialEq)]
+enum ResponseHeadersState {
+    NoHeaders,
+    Ready(Option<Vec<Header>>),
+    Read,
+}
+
+#[derive(Debug)]
+pub(crate) struct ResponseStream {
+    state: ResponseStreamState,
+    frame_reader: HFrameReader,
+    response_headers_state: ResponseHeadersState,
+    conn_events: Http3ClientEvents,
+    stream_id: u64,
+}
+
+impl ::std::fmt::Display for ResponseStream {
+    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
+        write!(f, "ResponseStream stream_id:{}", self.stream_id)
+    }
+}
+
+impl ResponseStream {
+    pub fn new(stream_id: u64, conn_events: Http3ClientEvents) -> Self {
+        Self {
+            state: ResponseStreamState::WaitingForResponseHeaders,
+            frame_reader: HFrameReader::new(),
+            response_headers_state: ResponseHeadersState::NoHeaders,
+            conn_events,
+            stream_id,
+        }
+    }
+
+    fn handle_headers_frame(&mut self, header_block: Vec<u8>, fin: bool) -> Res<()> {
+        match self.state {
+            ResponseStreamState::WaitingForResponseHeaders => {
+                if header_block.is_empty() {
+                    self.add_headers(None)?;
+                } else {
+                    self.state = ResponseStreamState::DecodingHeaders { header_block, fin };
+                }
+             }
+            ResponseStreamState::WaitingForData => {
+                // TODO implement trailers, for now just ignore them.
+                self.state = ResponseStreamState::WaitingForFinAfterTrailers;
+            }
+            ResponseStreamState::WaitingForFinAfterTrailers => {
+                return Err(Error::HttpFrameUnexpected);
+            }
+            _ => unreachable!("This functions is only called in WaitingForResponseHeaders | WaitingForData | WaitingForFinAfterTrailers state.")
+         }
+        Ok(())
+    }
+
+    fn handle_data_frame(&mut self, len: u64, fin: bool) -> Res<()> {
+        match self.state {
+            ResponseStreamState::WaitingForResponseHeaders | ResponseStreamState::WaitingForFinAfterTrailers => {
+                return Err(Error::HttpFrameUnexpected);
+            }
+            ResponseStreamState::WaitingForData => {
+                if len > 0 {
+                    if fin {
+                        return Err(Error::HttpFrameError);
+                    }
+                    self.state = ResponseStreamState::ReadingData {
+                        remaining_data_len: len as usize,
+                    };
+                }
+            }
+            _ => unreachable!("This functions is only called in WaitingForResponseHeaders | WaitingForData | WaitingForFinAfterTrailers state.")
+        }
+        Ok(())
+    }
+
+    fn add_headers(&mut self, headers: Option<Vec<Header>>) -> Res<()> {
+        if self.response_headers_state != ResponseHeadersState::NoHeaders {
+            debug_assert!(
+                false,
+                "self.response_headers_state must be in state ResponseHeadersState::NoHeaders."
+            );
+            return Err(Error::HttpInternalError);
+        }
+        self.response_headers_state = ResponseHeadersState::Ready(headers);
+        self.conn_events.header_ready(self.stream_id);
+        self.state = ResponseStreamState::WaitingForData;
+        Ok(())
+    }
+
+    fn set_state_to_close_pending(&mut self) {
+        // Stream has received fin. Depending on headers state set header_ready
+        // or data_readable event so that app can pick up the fin.
+        qtrace!(
+            [self],
+            "set_state_to_close_pending:  response_headers_state={:?}",
+            self.response_headers_state
+        );
+        match self.response_headers_state {
+            ResponseHeadersState::NoHeaders => {
+                self.conn_events.header_ready(self.stream_id);
+                self.response_headers_state = ResponseHeadersState::Ready(None);
+            }
+            // In Ready state we are already waiting for app to pick up headers
+            // it can also pick up fin, so we do not need a new event.
+            ResponseHeadersState::Ready(..) => {}
+            ResponseHeadersState::Read => self.conn_events.data_readable(self.stream_id),
+        }
+        self.state = ResponseStreamState::ClosePending;
+    }
+
+    fn recv_frame(&mut self, conn: &mut Connection) -> Res<(Option<HFrame>, bool)> {
+        qtrace!([self], "receiving frame header");
+        let fin = self.frame_reader.receive(conn, self.stream_id)?;
+        if !self.frame_reader.done() {
+            Ok((None, fin))
+        } else {
+            qdebug!([self], "A new frame has been received.");
+            Ok((Some(self.frame_reader.get_frame()?), fin))
+        }
+    }
+
+    pub fn read_response_headers(&mut self) -> Res<(Vec<Header>, bool)> {
+        if let ResponseHeadersState::Ready(ref mut headers) = self.response_headers_state {
+            let hdrs = if let Some(ref mut hdrs) = headers {
+                mem::replace(hdrs, Vec::new())
+            } else {
+                Vec::new()
+            };
+
+            self.response_headers_state = ResponseHeadersState::Read;
+
+            let fin = if self.state == ResponseStreamState::ClosePending {
+                self.state = ResponseStreamState::Closed;
+                true
+            } else {
+                false
+            };
+            Ok((hdrs, fin))
+        } else {
+            Err(Error::Unavailable)
+        }
+    }
+
+    pub fn read_response_data(
+        &mut self,
+        conn: &mut Connection,
+        buf: &mut [u8],
+    ) -> Res<(usize, bool)> {
+        match self.state {
+            ResponseStreamState::ReadingData {
+                ref mut remaining_data_len,
+            } => {
+                let to_read = min(*remaining_data_len, buf.len());
+                let (amount, fin) = conn.stream_recv(self.stream_id, &mut buf[..to_read])?;
+                debug_assert!(amount <= to_read);
+                *remaining_data_len -= amount;
+
+                if fin {
+                    if *remaining_data_len > 0 {
+                        return Err(Error::HttpFrameError);
+                    }
+                    self.state = ResponseStreamState::Closed;
+                } else if *remaining_data_len == 0 {
+                    self.state = ResponseStreamState::WaitingForData;
+                }
+
+                Ok((amount, fin))
+            }
+            ResponseStreamState::ClosePending => {
+                self.state = ResponseStreamState::Closed;
+                Ok((0, true))
+            }
+            _ => Ok((0, false)),
+        }
+    }
+
+    pub fn receive(&mut self, conn: &mut Connection, decoder: &mut QPackDecoder) -> Res<()> {
+        let label = if ::log::log_enabled!(::log::Level::Debug) {
+            format!("{}", self)
+        } else {
+            String::new()
+        };
+        loop {
+            qdebug!([label], "state={:?}.", self.state);
+            match self.state {
+                // In the following 3 states we need to read frames.
+                ResponseStreamState::WaitingForResponseHeaders
+                | ResponseStreamState::WaitingForData
+                | ResponseStreamState::WaitingForFinAfterTrailers => {
+                    match self.recv_frame(conn)? {
+                        (None, true) => {
+                            self.set_state_to_close_pending();
+                            break Ok(());
+                        }
+                        (None, false) => break Ok(()),
+                        (Some(frame), fin) => {
+                            qinfo!(
+                                [self],
+                                "A new frame has been received: {:?}; state={:?}",
+                                frame,
+                                self.state
+                            );
+                            match frame {
+                                HFrame::Headers { header_block } => {
+                                    self.handle_headers_frame(header_block, fin)?
+                                }
+                                HFrame::Data { len } => self.handle_data_frame(len, fin)?,
+                                HFrame::PushPromise { .. } | HFrame::DuplicatePush { .. } => {
+                                    break Err(Error::HttpIdError)
+                                }
+                                _ => break Err(Error::HttpFrameUnexpected),
+                            }
+                            if fin
+                                && !matches!(self.state, ResponseStreamState::DecodingHeaders{..})
+                            {
+                                self.set_state_to_close_pending();
+                                break Ok(());
+                            }
+                        }
+                    };
+                }
+                ResponseStreamState::DecodingHeaders {
+                    ref header_block,
+                    fin,
+                } => match decoder.decode_header_block(header_block, self.stream_id)? {
+                    Some(headers) => {
+                        self.add_headers(Some(headers))?;
+                        if fin {
+                            self.set_state_to_close_pending();
+                            break Ok(());
+                        }
+                    }
+                    None => {
+                        qinfo!([self], "decoding header is blocked.");
+                        break Ok(());
+                    }
+                },
+                ResponseStreamState::ReadingData { .. } => {
+                    self.conn_events.data_readable(self.stream_id);
+                    break Ok(());
+                }
+                ResponseStreamState::ClosePending => {
+                    panic!("Stream readable after being closed!");
+                }
+                ResponseStreamState::Closed => {
+                    panic!("Stream readable after being closed!");
+                }
+            };
+        }
+    }
+
+    pub fn is_closed(&self) -> bool {
+        self.state == ResponseStreamState::Closed
+    }
+
+    pub fn close(&mut self) {
+        self.state = ResponseStreamState::Closed;
+    }
+}

diff --git a/neqo-http3/src/transaction_client.rs b/neqo-http3/src/transaction_client.rs
--- a/neqo-http3/src/transaction_client.rs
+++ b/neqo-http3/src/transaction_client.rs
@@ -4,19 +4,19 @@
 // option. This file may not be copied, modified, or distributed
 // except according to those terms.
 
-use crate::hframe::{HFrame, HFrameReader};
+use crate::hframe::HFrame;
 
 use crate::client_events::Http3ClientEvents;
 use crate::connection::Http3Transaction;
+use crate::response_stream::ResponseStream;
 use crate::Header;
-use neqo_common::{qdebug, qinfo, qtrace, qwarn, Encoder};
+use neqo_common::{qinfo, Encoder};
 use neqo_qpack::decoder::QPackDecoder;
 use neqo_qpack::encoder::QPackEncoder;
 use neqo_transport::Connection;
 
 use crate::{Error, Res};
 use std::cmp::min;
-use std::mem;
 
 const MAX_DATA_HEADER_SIZE_2: usize = (1 << 6) - 1; // Maximal amount of data with DATA frame header size 2
 const MAX_DATA_HEADER_SIZE_2_LIMIT: usize = MAX_DATA_HEADER_SIZE_2 + 3; // 63 + 3 (size of the next buffer data frame header)
@@ -59,13 +59,12 @@ impl Request {
         }
 
         qinfo!([self], "Encoding headers for {}/{}", self.host, self.path);
-        let encoded_headers = encoder.encode_header_block(&self.headers, stream_id);
+        let header_block = encoder.encode_header_block(&self.headers, stream_id);
         let f = HFrame::Headers {
-            len: encoded_headers.len() as u64,
+            header_block: header_block.to_vec(),
         };
         let mut d = Encoder::default();
         f.encode(&mut d);
-        d.encode(&encoded_headers[..]);
         self.buf = Some(d.into());
     }
 
@@ -121,53 +120,12 @@ enum TransactionSendState {
     Closed,
 }
 
-/*
- * Transaction receive state:
- *    WaitingForResponseHeaders : we wait for headers. in this state we can
- *                                also get a PUSH_PROMISE frame.
- *    ReadingHeaders : we have HEADERS frame and now we are reading header
- *                     block. This may block on encoder instructions. In this
- *                     state we do no read from the stream.
- *    BlockedDecodingHeaders : Decoding headers is blocked on encoder
- *                             instructions.
- *    WaitingForData : we got HEADERS, we are waiting for one or more data
- *                     frames. In this state we can receive one or more
- *                     PUSH_PROMIS frames or a HEADERS frame carrying trailers.
- *    ReadingData : we got a DATA frame, now we letting the app read payload.
- *                  From here we will go back to WaitingForData state to wait
- *                  for more data frames or to CLosed state
- *    ReadingTrailers : reading trailers.
- *    ClosePending : waiting for app to pick up data, after that we can delete
- * the TransactionClient.
- *    Closed
- */
-#[derive(PartialEq, Debug)]
-enum TransactionRecvState {
-    WaitingForResponseHeaders,
-    ReadingHeaders { buf: Vec<u8>, offset: usize },
-    BlockedDecodingHeaders { buf: Vec<u8>, fin: bool },
-    WaitingForData,
-    ReadingData { remaining_data_len: usize },
-    //    ReadingTrailers,
-    ClosePending, // Close must first be read by application
-    Closed,
-}
-
-#[derive(Debug, PartialEq)]
-enum ResponseHeadersState {
-    NoHeaders,
-    Ready(Option<Vec<Header>>),
-    Read,
-}
-
 //  This is used for normal request/responses.
 #[derive(Debug)]
 pub struct TransactionClient {
     send_state: TransactionSendState,
-    recv_state: TransactionRecvState,
+    response_stream: ResponseStream,
     stream_id: u64,
-    frame_reader: HFrameReader,
-    response_headers_state: ResponseHeadersState,
     conn_events: Http3ClientEvents,
 }
 
@@ -187,10 +145,8 @@ impl TransactionClient {
                 request: Request::new(method, scheme, host, path, headers),
                 fin: false,
             },
-            recv_state: TransactionRecvState::WaitingForResponseHeaders,
+            response_stream: ResponseStream::new(stream_id, conn_events.clone()),
             stream_id,
-            response_headers_state: ResponseHeadersState::NoHeaders,
-            frame_reader: HFrameReader::new(),
             conn_events,
         }
     }
@@ -250,167 +206,6 @@ impl TransactionClient {
         }
     }
 
-    fn handle_frame_in_state_waiting_for_headers(&mut self, frame: HFrame, fin: bool) -> Res<()> {
-        qinfo!(
-            [self],
-            "A new frame has been received: {:?}; state={:?}",
-            frame,
-            self.recv_state
-        );
-        match frame {
-            HFrame::Headers { len } => self.handle_headers_frame(len, fin),
-            HFrame::PushPromise { .. } => Err(Error::HttpIdError),
-            _ => Err(Error::HttpFrameUnexpected),
-        }
-    }
-
-    fn handle_headers_frame(&mut self, len: u64, fin: bool) -> Res<()> {
-        if len == 0 {
-            self.add_headers(None)
-        } else {
-            if fin {
-                return Err(Error::HttpFrameError);
-            }
-            self.recv_state = TransactionRecvState::ReadingHeaders {
-                buf: vec![0; len as usize],
-                offset: 0,
-            };
-            Ok(())
-        }
-    }
-
-    fn handle_frame_in_state_waiting_for_data(&mut self, frame: HFrame, fin: bool) -> Res<()> {
-        qinfo!(
-            [self],
-            "A new frame has been received: {:?}; state={:?}",
-            frame,
-            self.recv_state
-        );
-        match frame {
-            HFrame::Data { len } => self.handle_data_frame(len, fin),
-            HFrame::PushPromise { .. } => Err(Error::HttpIdError),
-            HFrame::Headers { .. } => {
-                // TODO implement trailers!
-                qwarn!([self], "Received trailers");
-                Err(Error::HttpFrameUnexpected)
-            }
-            _ => Err(Error::HttpFrameUnexpected),
-        }
-    }
-
-    fn handle_data_frame(&mut self, len: u64, fin: bool) -> Res<()> {
-        if len > 0 {
-            if fin {
-                return Err(Error::HttpFrameError);
-            }
-            self.recv_state = TransactionRecvState::ReadingData {
-                remaining_data_len: len as usize,
-            };
-        }
-        Ok(())
-    }
-
-    fn add_headers(&mut self, headers: Option<Vec<Header>>) -> Res<()> {
-        if self.response_headers_state != ResponseHeadersState::NoHeaders {
-            return Err(Error::HttpInternalError);
-        }
-        self.response_headers_state = ResponseHeadersState::Ready(headers);
-        self.conn_events.header_ready(self.stream_id);
-        self.recv_state = TransactionRecvState::WaitingForData;
-        Ok(())
-    }
-
-    fn set_state_to_close_pending(&mut self) {
-        // Stream has received fin. Depending on headers state set header_ready
-        // or data_readable event so that app can pick up the fin.
-        qdebug!(
-            [self],
-            "set_state_to_close_pending:  response_headers_state={:?}",
-            self.response_headers_state
-        );
-        match self.response_headers_state {
-            ResponseHeadersState::NoHeaders => {
-                self.conn_events.header_ready(self.stream_id);
-                self.response_headers_state = ResponseHeadersState::Ready(None);
-            }
-            // In Ready state we are already waiting for app to pick up headers
-            // it can also pick up fin, so we do not need a new event.
-            ResponseHeadersState::Ready(..) => {}
-            ResponseHeadersState::Read => self.conn_events.data_readable(self.stream_id),
-        }
-        self.recv_state = TransactionRecvState::ClosePending;
-    }
-
-    fn recv_frame_header(&mut self, conn: &mut Connection) -> Res<Option<(HFrame, bool)>> {
-        qtrace!([self], "receiving frame header");
-        let fin = self.frame_reader.receive(conn, self.stream_id)?;
-        if !self.frame_reader.done() {
-            if fin {
-                //we have received stream fin while waiting for a frame.
-                // !self.frame_reader.done() means that we do not have a new
-                // frame at all. Set state to ClosePending and waith for app
-                // to pick up fin.
-                self.set_state_to_close_pending();
-            }
-            Ok(None)
-        } else {
-            qdebug!([self], "A new frame has been received.");
-            Ok(Some((self.frame_reader.get_frame()?, fin)))
-        }
-    }
-
-    fn read_headers_frame_body(
-        &mut self,
-        conn: &mut Connection,
-        decoder: &mut QPackDecoder,
-    ) -> Res<bool> {
-        let label = if ::log::log_enabled!(::log::Level::Debug) {
-            format!("{}", self)
-        } else {
-            String::new()
-        };
-        if let TransactionRecvState::ReadingHeaders {
-            ref mut buf,
-            ref mut offset,
-        } = self.recv_state
-        {
-            let (amount, fin) = conn.stream_recv(self.stream_id, &mut buf[*offset..])?;
-            qdebug!([label], "read_headers: read {} bytes fin={}.", amount, fin);
-            *offset += amount as usize;
-            if *offset < buf.len() {
-                if fin {
-                    // Malformated frame
-                    return Err(Error::HttpFrameError);
-                }
-                return Ok(true);
-            }
-
-            // we have read the headers, try decoding them.
-            qinfo!(
-                [label],
-                "read_headers: read all headers, try decoding them."
-            );
-            match decoder.decode_header_block(buf, self.stream_id)? {
-                Some(headers) => {
-                    self.add_headers(Some(headers))?;
-                    if fin {
-                        self.set_state_to_close_pending();
-                    }
-                    Ok(fin)
-                }
-                None => {
-                    let mut tmp: Vec<u8> = Vec::new();
-                    mem::swap(&mut tmp, buf);
-                    self.recv_state =
-                        TransactionRecvState::BlockedDecodingHeaders { buf: tmp, fin };
-                    Ok(true)
-                }
-            }
-        } else {
-            panic!("This is only called when recv_state is ReadingHeaders.");
-        }
-    }
-
     pub fn is_sending_closed(&self) -> bool {
         match self.send_state {
             TransactionSendState::SendingHeaders { fin, .. } => fin,
@@ -420,21 +215,7 @@ impl TransactionClient {
     }
 
     pub fn read_response_headers(&mut self) -> Res<(Vec<Header>, bool)> {
-        if let ResponseHeadersState::Ready(ref mut headers) = self.response_headers_state {
-            let mut tmp = Vec::new();
-            if let Some(ref mut hdrs) = headers {
-                mem::swap(&mut tmp, hdrs);
-            }
-            self.response_headers_state = ResponseHeadersState::Read;
-            let mut fin = false;
-            if self.recv_state == TransactionRecvState::ClosePending {
-                fin = true;
-                self.recv_state = TransactionRecvState::Closed;
-            }
-            Ok((tmp, fin))
-        } else {
-            Err(Error::Unavailable)
-        }
+        self.response_stream.read_response_headers()
     }
 
     pub fn read_response_data(
@@ -442,36 +223,7 @@ impl TransactionClient {
         conn: &mut Connection,
         buf: &mut [u8],
     ) -> Res<(usize, bool)> {
-        match self.recv_state {
-            TransactionRecvState::ReadingData {
-                ref mut remaining_data_len,
-            } => {
-                let to_read = if *remaining_data_len > buf.len() {
-                    buf.len()
-                } else {
-                    *remaining_data_len
-                };
-                let (amount, fin) = conn.stream_recv(self.stream_id, &mut buf[..to_read])?;
-                debug_assert!(amount <= to_read);
-                *remaining_data_len -= amount;
-
-                if fin {
-                    if *remaining_data_len > 0 {
-                        return Err(Error::HttpFrameError);
-                    }
-                    self.recv_state = TransactionRecvState::Closed;
-                } else if *remaining_data_len == 0 {
-                    self.recv_state = TransactionRecvState::WaitingForData;
-                }
-
-                Ok((amount, fin))
-            }
-            TransactionRecvState::ClosePending => {
-                self.recv_state = TransactionRecvState::Closed;
-                Ok((0, true))
-            }
-            _ => Ok((0, false)),
-        }
+        self.response_stream.read_response_data(conn, buf)
     }
 
     pub fn is_state_sending_data(&self) -> bool {
@@ -513,76 +265,7 @@ impl Http3Transaction for TransactionClient {
     }
 
     fn receive(&mut self, conn: &mut Connection, decoder: &mut QPackDecoder) -> Res<()> {
-        let label = if ::log::log_enabled!(::log::Level::Debug) {
-            format!("{}", self)
-        } else {
-            String::new()
-        };
-        loop {
-            qdebug!(
-                [label],
-                "send_state={:?} recv_state={:?}.",
-                self.send_state,
-                self.recv_state
-            );
-            match self.recv_state {
-                TransactionRecvState::WaitingForResponseHeaders => {
-                    match self.recv_frame_header(conn)? {
-                        None => break Ok(()),
-                        Some((f, fin)) => {
-                            self.handle_frame_in_state_waiting_for_headers(f, fin)?;
-                            if fin {
-                                self.set_state_to_close_pending();
-                                break Ok(());
-                            }
-                        }
-                    };
-                }
-                TransactionRecvState::ReadingHeaders { .. } => {
-                    if self.read_headers_frame_body(conn, decoder)? {
-                        break Ok(());
-                    }
-                }
-                TransactionRecvState::BlockedDecodingHeaders { ref buf, fin } => {
-                    match decoder.decode_header_block(buf, self.stream_id)? {
-                        Some(headers) => {
-                            self.add_headers(Some(headers))?;
-                            if fin {
-                                self.set_state_to_close_pending();
-                                break Ok(());
-                            }
-                        }
-                        None => {
-                            qinfo!([self], "decoding header is blocked.");
-                            break Ok(());
-                        }
-                    }
-                }
-                TransactionRecvState::WaitingForData => {
-                    match self.recv_frame_header(conn)? {
-                        None => break Ok(()),
-                        Some((f, fin)) => {
-                            self.handle_frame_in_state_waiting_for_data(f, fin)?;
-                            if fin {
-                                self.set_state_to_close_pending();
-                                break Ok(());
-                            }
-                        }
-                    };
-                }
-                TransactionRecvState::ReadingData { .. } => {
-                    self.conn_events.data_readable(self.stream_id);
-                    break Ok(());
-                }
-                // TransactionRecvState::ReadingTrailers => break Ok(()),
-                TransactionRecvState::ClosePending => {
-                    panic!("Stream readable after being closed!");
-                }
-                TransactionRecvState::Closed => {
-                    panic!("Stream readable after being closed!");
-                }
-            };
-        }
+        self.response_stream.receive(conn, decoder)
     }
 
     fn has_data_to_send(&self) -> bool {
@@ -594,7 +277,7 @@ impl Http3Transaction for TransactionClient {
     }
 
     fn reset_receiving_side(&mut self) {
-        self.recv_state = TransactionRecvState::Closed;
+        self.response_stream.close();
     }
 
     fn stop_sending(&mut self) {
@@ -602,8 +285,7 @@ impl Http3Transaction for TransactionClient {
     }
 
     fn done(&self) -> bool {
-        self.send_state == TransactionSendState::Closed
-            && self.recv_state == TransactionRecvState::Closed
+        self.send_state == TransactionSendState::Closed && self.response_stream.is_closed()
     }
 
     fn close_send(&mut self, conn: &mut Connection) -> Res<()> {

diff --git a/neqo-http3/src/transaction_server.rs b/neqo-http3/src/transaction_server.rs
--- a/neqo-http3/src/transaction_server.rs
+++ b/neqo-http3/src/transaction_server.rs
@@ -18,8 +18,7 @@ use std::mem;
 #[derive(PartialEq, Debug)]
 enum TransactionRecvState {
     WaitingForHeaders,
-    ReadingHeaders { buf: Vec<u8>, offset: usize },
-    BlockedDecodingHeaders { buf: Vec<u8>, fin: bool },
+    DecodingHeaders { header_block: Vec<u8>, fin: bool },
     WaitingForData,
     ReadingData { remaining_data_len: usize },
     Closed,
@@ -55,13 +54,12 @@ impl TransactionServer {
 
     pub fn set_response(&mut self, headers: &[Header], data: Vec<u8>, encoder: &mut QPackEncoder) {
         qdebug!([self], "Encoding headers");
-        let encoded_headers = encoder.encode_header_block(&headers, self.stream_id);
+        let header_block = encoder.encode_header_block(&headers, self.stream_id);
         let hframe = HFrame::Headers {
-            len: encoded_headers.len() as u64,
+            header_block: header_block.to_vec(),
         };
         let mut d = Encoder::default();
         hframe.encode(&mut d);
-        d.encode(&encoded_headers);
         if !data.is_empty() {
             qdebug!([self], "Encoding data");
             let d_frame = HFrame::Data {
@@ -74,8 +72,8 @@ impl TransactionServer {
         self.send_state = TransactionSendState::SendingResponse { buf: d.into() };
     }
 
-    fn recv_frame_header(&mut self, conn: &mut Connection) -> Res<(Option<HFrame>, bool)> {
-        qtrace!([self], "receiving frame header");
+    fn recv_frame(&mut self, conn: &mut Connection) -> Res<(Option<HFrame>, bool)> {
+        qtrace!([self], "receiving a frame");
         let fin = self.frame_reader.receive(conn, self.stream_id)?;
         if !self.frame_reader.done() {
             Ok((None, fin))
@@ -85,92 +83,6 @@ impl TransactionServer {
         }
     }
 
-    fn read_headers_frame_body(
-        &mut self,
-        conn: &mut Connection,
-        decoder: &mut QPackDecoder,
-    ) -> Res<bool> {
-        let label = if ::log::log_enabled!(::log::Level::Debug) {
-            format!("{}", self)
-        } else {
-            String::new()
-        };
-        if let TransactionRecvState::ReadingHeaders {
-            ref mut buf,
-            ref mut offset,
-        } = self.recv_state
-        {
-            let (amount, fin) = conn.stream_recv(self.stream_id, &mut buf[*offset..])?;
-            qdebug!([label], "read_headers: read {} bytes fin={}.", amount, fin);
-            *offset += amount as usize;
-            if *offset < buf.len() {
-                if fin {
-                    // Malformed frame
-                    return Err(Error::HttpFrameError);
-                }
-                return Ok(true);
-            }
-
-            // we have read the headers, try decoding them.
-            qinfo!(
-                [label],
-                "read_headers: read all headers, try decoding them."
-            );
-            match decoder.decode_header_block(buf, self.stream_id)? {
-                Some(headers) => {
-                    self.conn_events.headers(self.stream_id, headers, fin);
-                    if fin {
-                        self.recv_state = TransactionRecvState::Closed;
-                    } else {
-                        self.recv_state = TransactionRecvState::WaitingForData;
-                    }
-                    Ok(fin)
-                }
-                None => {
-                    let mut tmp: Vec<u8> = Vec::new();
-                    mem::swap(&mut tmp, buf);
-                    self.recv_state =
-                        TransactionRecvState::BlockedDecodingHeaders { buf: tmp, fin };
-                    Ok(true)
-                }
-            }
-        } else {
-            panic!("This is only called when recv_state is ReadingHeaders.");
-        }
-    }
-
-    fn handle_frame_in_state_waiting_for_headers(&mut self, frame: HFrame, fin: bool) -> Res<()> {
-        qdebug!([self], "A new frame has been received: {:?}", frame);
-        match frame {
-            HFrame::Headers { len } => self.handle_headers_frame(len, fin),
-            _ => Err(Error::HttpFrameUnexpected),
-        }
-    }
-
-    fn handle_frame_in_state_waiting_for_data(&mut self, frame: HFrame, fin: bool) -> Res<()> {
-        qdebug!([self], "A new frame has been received: {:?}", frame);
-        match frame {
-            HFrame::Data { len } => self.handle_data_frame(len, fin),
-            _ => Err(Error::HttpFrameUnexpected),
-        }
-    }
-
-    fn handle_headers_frame(&mut self, len: u64, fin: bool) -> Res<()> {
-        qinfo!([self], "A new header frame len={} fin={}", len, fin);
-        if len == 0 {
-            self.conn_events.headers(self.stream_id, Vec::new(), fin);
-        } else {
-            if fin {
-                return Err(Error::HttpFrameError);
-            }
-            self.recv_state = TransactionRecvState::ReadingHeaders {
-                buf: vec![0; len as usize],
-                offset: 0,
-            };
-        }
-        Ok(())
-    }
-
     fn handle_data_frame(&mut self, len: u64, fin: bool) -> Res<()> {
         qinfo!([self], "A new data frame len={} fin={}", len, fin);
         if len > 0 {
@@ -233,58 +145,76 @@ impl Http3Transaction for TransactionServer {
             );
             match self.recv_state {
                 TransactionRecvState::WaitingForHeaders => {
-                    let (f, fin) = self.recv_frame_header(conn)?;
-                    match f {
-                        None => {
-                            if fin {
-                                self.conn_events.headers(self.stream_id, Vec::new(), true);
-                                self.recv_state = TransactionRecvState::Closed;
-                            }
+                    match self.recv_frame(conn)? {
+                        (None, true) => {
+                            // Stream has been closed without any data, just ignore it.
+                            self.recv_state = TransactionRecvState::Closed;
                             return Ok(());
                         }
-                        Some(new_f) => {
-                            self.handle_frame_in_state_waiting_for_headers(new_f, fin)?;
-                            if fin {
-                                self.recv_state = TransactionRecvState::Closed;
-                                return Ok(());
+                        (None, false) => {
+                            // We do not have a complete frame.
+                            return Ok(());
+                        }
+                        (Some(HFrame::Headers { header_block }), fin) => {
+                            if !header_block.is_empty() {
+                                // Next step decoding headers.
+                                self.recv_state =
+                                    TransactionRecvState::DecodingHeaders { header_block, fin };
+                            } else {
+                                self.conn_events.headers(self.stream_id, Vec::new(), fin);
+                                if fin {
+                                    self.recv_state = TransactionRecvState::Closed;
+                                    return Ok(());
+                                } else {
+                                    self.recv_state = TransactionRecvState::WaitingForData;
+                                }
                             }
                         }
+                        // server can only receive a Header frame at this point.
+                        _ => {
+                            return Err(Error::HttpFrameUnexpected);
+                        }
                     }
                 }
-                TransactionRecvState::ReadingHeaders { .. } => {
-                    if self.read_headers_frame_body(conn, decoder)? {
-                        break Ok(());
-                    }
-                }
-                TransactionRecvState::BlockedDecodingHeaders { ref mut buf, fin } => {
-                    match decoder.decode_header_block(buf, self.stream_id)? {
-                        Some(headers) => {
-                            self.conn_events.headers(self.stream_id, headers, fin);
-                            if fin {
-                                return Ok(());
-                            }
-                        }
-                        None => {
-                            qinfo!([self], "decoding header is blocked.");
+                TransactionRecvState::DecodingHeaders {
+                    ref mut header_block,
+                    fin,
+                } => match decoder.decode_header_block(header_block, self.stream_id)? {
+                    Some(headers) => {
+                        self.conn_events.headers(self.stream_id, headers, fin);
+                        if fin {
+                            self.recv_state = TransactionRecvState::Closed;
                             return Ok(());
+                        } else {
+                            self.recv_state = TransactionRecvState::WaitingForData;
                         }
                     }
-                }
+                    None => {
+                        qinfo!([self], "decoding header is blocked.");
+                        return Ok(());
+                    }
+                },
                 TransactionRecvState::WaitingForData => {
-                    let (f, fin) = self.recv_frame_header(conn)?;
-                    match f {
-                        None => {
-                            if fin {
-                                self.conn_events.data(self.stream_id, Vec::new(), true);
-                            }
+                    match self.recv_frame(conn)? {
+                        (None, true) => {
+                            // Inform the app tthat tthe stream is done.
+                            self.conn_events.data(self.stream_id, Vec::new(), true);
+                            self.recv_state = TransactionRecvState::Closed;
                             return Ok(());
                         }
-                        Some(new_f) => {
-                            self.handle_frame_in_state_waiting_for_data(new_f, fin)?;
+                        (None, false) => {
+                            // Still reading a frame.
+                            return Ok(());
+                        }
+                        (Some(HFrame::Data { len }), fin) => {
+                            self.handle_data_frame(len, fin)?;
                             if fin {
                                 return Ok(());
                             }
                         }
+                        _ => {
+                            return Err(Error::HttpFrameUnexpected);
+                        }
                     };
                 }
                 TransactionRecvState::ReadingData {


</patch>

Function signatures
<Signatures>

</Signatures>

You are a software tester at neqo and your are reviewing the above <patch> for the above <issue>
Identify whether a unit test is needed.
If there is no test needed, return <NO>.
If a test is needed, your task is:
1. Write exactly one rust test `#[test]fn test_...(){...}` block. Do NOT wrap the test inside a 'mod tests' block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. All 'use' declarations must be inside a <imports>...</imports> block.
 Use `use super::<function name> for the function under test.
.If multiple 'use' statements are needed, list each on a separate line.
5. To help you write the test, <Signatures> contains all modified function's:
- name
- parameters
- Return type (assume '()' if empty)
6. Return only the absolute filename as it is in the <patch> block, the use statements, and rust test (no comments or explanations).

Here is an example structure:
<Filename> ... </Filename>
<imports> ... </imports>
<Rust>
#[test]
fn test_<describe_behavior>() {
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
}</Rust>

