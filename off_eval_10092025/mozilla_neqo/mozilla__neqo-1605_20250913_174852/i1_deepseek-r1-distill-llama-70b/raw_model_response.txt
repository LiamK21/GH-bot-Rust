<think>
Okay, I need to figure out how to write a regression test for this issue. Let's start by understanding the problem. The issue is that the function `pto_period_inner` can return `0ns` when `pto_count` is 30 or 31. That's incorrect because those counts should produce valid PTO values, not zero. 

Looking at the patch provided, it changes the calculation in `pto_period_inner`. Before the patch, the code used `checked_shl` which might have caused overflow issues when `pto_count` was high, leading to `0ns`. The patch replaces this with a bitwise shift that's capped to prevent overflow.

So, the goal is to write a test that fails before the patch and passes after. The test should check the scenarios where `pto_count` is 30 and 31, as well as other values to ensure the fix works as intended.

I'll structure the test to cover three cases: pto_count = 29 (should work), 30, and 31. For each, I'll call `pto_period_inner` and check that the result is not zero. 

I need to import the necessary modules. Since `pto_period_inner` is part of `recovery.rs`, I'll use `super::pto_period_inner`. Also, I'll need `Duration` from the standard library.

In the test function, I'll set up a mock `rtt` and `pn_space` because the actual function might depend on them. For simplicity, I'll create a dummy `rtt` that returns a specific value when `pto` is called. 

Then, for each test case, I'll compute the expected and actual PTO periods. The expected value should not be zero for counts 30 and 31. I'll use assertions to check this.

I should ensure that the test is self-contained and doesn't rely on external state. Also, I'll make sure that the test accurately reflects the conditions under which the bug occurs.

Finally, I'll write the test code, making sure all imports are correctly included and the function is properly annotated with `#[test]`.
</think>

<Filename>neqo-transport/src/recovery.rs</Filename>
<imports>
use super::pto_period_inner;
use std::time::Duration;
</imports>
<Rust>
#[test]
fn test_pto_period_inner_nonzero_for_high_counts() {
    // Mock rtt and pn_space to return a base PTO value
    let mock_rtt = MockRtt {};
    let pn_space = 1; // arbitrary value
    
    // Test cases
    let test_cases = [
        (29, None),  // Should work as before
        (30, Some(Duration::from_secs(3600))),
        (31, Some(Duration::from_secs(3600))),
    ];

    for (pto_count, expected) in &test_cases {
        let actual = pto_period_inner(
            &mock_rtt,
            pn_space,
            *pto_count as u32,
        );
        assert!(
            actual != Duration::from_secs(0),
            "pto_count {} returned 0ns",
            pto_count
        );
    }
}

struct MockRtt {}
impl MockRtt {
    fn pto(&self, _pn_space: u32) -> Option<u32> {
        Some(1000) // Return a fixed PTO value for testing
    }
}
</Rust>