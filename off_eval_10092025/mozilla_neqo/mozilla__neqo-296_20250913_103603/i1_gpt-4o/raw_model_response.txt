<Filename>neqo-transport/src/connection.rs</Filename>
<imports>
use super::Connection;
use crate::events::ConnectionEvent;
use crate::frame::StreamType;
use crate::Error;
use neqo_common::matches;
use test_fixture::{self, now};
</imports>
<Rust>
#[test]
fn test_zero_rtt_rejection() {
    let mut client = Connection::new_client("example.com", &["hq-22"], &now()).unwrap();
    let mut server = Connection::new_server(&["hq-22"], &now()).unwrap();

    // Simulate 0-RTT rejection
    client.zero_rtt_state = ZeroRttState::Sending(CryptoDxState::new(CryptoDxDirection::Write, 1, vec![], vec![]));
    client.client_0rtt_rejected();

    // Check that the client stream is gone
    let stream_id = client.stream_create(StreamType::UniDi).unwrap();
    let msg = &[1, 2, 3];
    let res = client.stream_send(stream_id, msg);
    assert!(res.is_err());
    assert_eq!(res.unwrap_err(), Error::InvalidStreamId);

    // Open a new stream and send data. StreamId should start with 0.
    let stream_id_after_reject = client.stream_create(StreamType::UniDi).unwrap();
    assert_eq!(stream_id, stream_id_after_reject);
    client.stream_send(stream_id_after_reject, msg).unwrap();
    let client_after_reject = client.process(None, now());
    assert!(client_after_reject.as_dgram_ref().is_some());

    // The server should receive new stream
    let server_out = server.process(client_after_reject.dgram(), now());
    assert!(server_out.as_dgram_ref().is_some()); // an ack
    let recvd_stream_evt = |e| matches!(e, ConnectionEvent::NewStream { .. });
    assert!(server.events().any(recvd_stream_evt));
}
</Rust>