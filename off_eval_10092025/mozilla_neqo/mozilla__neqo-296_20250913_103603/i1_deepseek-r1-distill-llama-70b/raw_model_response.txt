<think>
Okay, so I need to figure out whether a unit test is needed for the given issue and patch. The issue is about not being able to send data after zero-RTT has been rejected. The patch makes several changes to handle zero-RTT states better and discharge keys properly.

First, I'll read through the issue description. The problem arises when zero-RTT is rejected, and the code tries to send data using zero-RTT keys, which causes a failure. The solution involves discharging these keys and not restarting stream IDs.

Looking at the patch, I see changes in multiple files. The main changes are in `connection.rs`, where the `ZeroRttState` enum is modified to include more states, and functions like `obtain_epoch_rx_crypto_state` and `get_zero_rtt_crypto` are added or modified. These changes ensure that after zero-RTT is rejected, the keys are discharged, and stream IDs aren't reset inappropriately.

Now, I need to determine if a test is needed. Since the patch modifies behavior related to zero-RTT handling, a test should verify that after rejection, data can't be sent with zero-RTT keys and that stream IDs are handled correctly. Without a test, we can't be sure the fix works as intended.

The next step is to write a test. The test should simulate a scenario where zero-RTT is rejected and then attempt to send data. It should check that the client correctly handles the rejection, doesn't send data with invalid keys, and that stream IDs are not restarted. 

I'll structure the test to set up a client and server, initiate a connection, and then trigger a zero-RTT rejection. After that, I'll try to send data and check if the stream IDs remain consistent and no data is sent erroneously. The test should fail before the patch is applied because the code would incorrectly attempt to send data, and pass after the patch ensures the keys are discharged.

I'll make sure the test is self-contained, uses appropriate imports, and clearly tests the specific behavior changes introduced by the patch.
</think>

<Filename> neqo-transport/src/connection.rs </Filename>
<Imports>
use super::connection::Connection;
use super::crypto::Crypto;
use super::events::ConnectionEvent;
use super::packet::PacketType;
use neqo_common::matches;
use std::result::Result;
</Imports>
<Rust>
#[test]
fn test_zero_rtt_rejected_cannot_send_data() {
    let mut client = Connection::new_client("localhost".into(), &["hq-22"]);
    let mut server = Connection::new_server(&["hq-22"]);
    
    // Simulate initial handshake and 0-RTT rejection
    let client_init = client.process(None, 0);
    let server_init = server.process(client_init.dgram(), 0);
    let client_hs = client.process(server_init.dgram(), 0);
    
    // Verify 0-RTT is rejected
    assert!(client.events().any(|e| matches!(e, ConnectionEvent::ZeroRttRejected)));
    
    // Attempt to send data after rejection
    let stream_id = client.stream_create(super::StreamType::BiDi).unwrap();
    let result = client.stream_send(stream_id, &[1, 2, 3]);
    assert!(result.is_err());
    
    // Verify no data is sent
    let client_out = client.process(None, 0);
    assert!(client_out.as_dgram_ref().is_none());
}
</Rust>