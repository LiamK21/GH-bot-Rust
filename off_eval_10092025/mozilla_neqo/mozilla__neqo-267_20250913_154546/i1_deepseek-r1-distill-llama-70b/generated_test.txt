#[test]
fn test_packet_retention_after_loss_declaration() {
    let mut recovery = LossRecovery::new();
    let pn_space = PNSpace::ApplicationData;
    let mut sent_packets = BTreeMap::new();

    // Create a sent packet
    let packet = SentPacket {
        ack_eliciting: true,
        time_sent: Instant::now(),
        tokens: vec![],
        time_declared_lost: None,
    };
    sent_packets.insert(1, packet);
    recovery.spaces[pn_space].sent_packets = sent_packets;

    // Declare packet as lost
    let now = Instant::now();
    let lost_pns = recovery.detect_lost_packets(pn_space, now);
    assert!(lost_pns.len() == 1);

    // Check if packet is still present after loss declaration
    let current_sent_packets = recovery.spaces[pn_space].sent_packets.clone();
    assert!(current_sent_packets.contains_key(&1));

    // Advance time by 2 RTT (assuming RTT is 100ms as per INITIAL_RTT)
    let rtt = Duration::from_millis(100);
    let two_rtt = rtt * 2;
    let later = now + two_rtt;

    // Detect lost packets again after 2 RTT
    let really_lost = recovery.detect_lost_packets(pn_space, later);
    assert!(really_lost.is_empty());

    // Check if packet is removed after 2 RTT
    let final_sent_packets = recovery.spaces[pn_space].sent_packets.clone();
    assert!(!final_sent_packets.contains_key(&1));
}