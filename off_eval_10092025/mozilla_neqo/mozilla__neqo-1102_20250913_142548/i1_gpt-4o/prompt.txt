Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Remove InternalError(19) it is not an error
https://github.com/mozilla/neqo/blob/879d82ddd987c323de65a2426e384308eecc2b26/neqo-transport/src/packet/mod.rs#L310
</issue>

Patch:
<patch>
diff --git a/neqo-transport/src/connection/mod.rs b/neqo-transport/src/connection/mod.rs
--- a/neqo-transport/src/connection/mod.rs
+++ b/neqo-transport/src/connection/mod.rs
@@ -1668,7 +1668,7 @@ impl Connection {
         address_validation: &AddressValidationInfo,
         quic_version: QuicVersion,
         grease_quic_bit: bool,
-    ) -> Res<(PacketType, PacketBuilder)> {
+    ) -> (PacketType, PacketBuilder) {
         let pt = PacketType::from(cspace);
         let mut builder = if pt == PacketType::Short {
             qdebug!("Building Short dcid {}", path.remote_cid());
@@ -1689,19 +1689,22 @@ impl Connection {
                 path.local_cid(),
             )
         };
-        builder.scramble(grease_quic_bit);
-        if pt == PacketType::Initial {
-            builder.initial_token(address_validation.token())?;
+        if builder.remaining() > 0 {
+            builder.scramble(grease_quic_bit);
+            if pt == PacketType::Initial {
+                builder.initial_token(address_validation.token());
+            }
         }
 
-        Ok((pt, builder))
+        (pt, builder)
     }
 
+    #[must_use]
     fn add_packet_number(
         builder: &mut PacketBuilder,
         tx: &CryptoDxState,
         largest_acknowledged: Option<PacketNumber>,
-    ) -> Res<PacketNumber> {
+    ) -> PacketNumber {
         // Get the packet number and work out how long it is.
         let pn = tx.next_pn();
         let unacked_range = if let Some(la) = largest_acknowledged {
@@ -1715,8 +1718,8 @@ impl Connection {
             - usize::try_from(unacked_range.leading_zeros() / 8).unwrap();
         // pn_len can't be zero (unacked_range is > 0)
         // TODO(mt) also use `4*path CWND/path MTU` to set a minimum length.
-        builder.pn(pn, pn_len)?;
-        Ok(pn)
+        builder.pn(pn, pn_len);
+        pn
     }
 
     fn can_grease_quic_bit(&self) -> bool {
@@ -1750,19 +1753,19 @@ impl Connection {
                 &AddressValidationInfo::None,
                 version,
                 grease_quic_bit,
-            )?;
-            builder.set_limit(min(path.amplification_limit(), path.mtu()) - tx.expansion());
-            if builder.limit() > 2048 {
-                return Err(Error::InternalError(9));
-            }
-            if builder.len() > builder.limit() {
-                return Err(Error::InternalError(25));
-            }
+            );
             let _ = Self::add_packet_number(
                 &mut builder,
                 tx,
                 self.loss_recovery.largest_acknowledged_pn(*space),
-            )?;
+            );
+            // The builder will set the limit to 0 if there isn't enough space for the header.
+            if builder.remaining() < 2 {
+                encoder = builder.abort();
+                break;
+            }
+            builder.set_limit(min(path.amplification_limit(), path.mtu()) - tx.expansion());
+            debug_assert!(builder.limit() <= 2048);
 
             // ConnectionError::Application is only allowed at 1RTT.
             let sanitized = if *space == PNSpace::ApplicationData {
@@ -1986,31 +1989,29 @@ impl Connection {
                 &self.address_validation,
                 version,
                 grease_quic_bit,
-            )?;
+            );
             let pn = Self::add_packet_number(
                 &mut builder,
                 tx,
                 self.loss_recovery.largest_acknowledged_pn(*space),
-            )?;
-            let payload_start = builder.len();
+            );
+            // The builder will set the limit to 0 if there isn't enough space for the header.
+            if builder.remaining() < 2 {
+                encoder = builder.abort();
+                break;
+            }
 
             // Work out if we have space left.
             let aead_expansion = tx.expansion();
-            if builder.len() + aead_expansion > profile.limit() {
-                // No space for a packet of this type.
+            builder.set_limit(profile.limit() - aead_expansion);
+            debug_assert!(builder.limit() <= 2048);
+            if builder.remaining() < 2 {
                 encoder = builder.abort();
-                continue;
-            }
-            let limit = profile.limit() - aead_expansion;
-            builder.set_limit(limit);
-            if builder.limit() > 2048 {
-                return Err(Error::InternalError(12));
-            }
-            if builder.len() > builder.limit() {
-                return Err(Error::InternalError(13));
+                break;
             }
 
             // Add frames to the packet.
+            let payload_start = builder.len();
             let (tokens, ack_eliciting, padded) =
                 self.write_frames(path, *space, &profile, &mut builder, needs_padding, now)?;

diff --git a/neqo-transport/src/crypto.rs b/neqo-transport/src/crypto.rs
--- a/neqo-transport/src/crypto.rs
+++ b/neqo-transport/src/crypto.rs
@@ -579,7 +579,10 @@ impl CryptoDxState {
             hex(body)
         );
         // The numbers in `Self::limit` assume a maximum packet size of 2^11.
-        assert!(body.len() <= 2048);
+        if body.len() > 2048 {
+            debug_assert!(false);
+            return Err(Error::InternalError(12));
+        }
         self.invoked()?;
 
         let size = body.len() + MAX_AUTH_TAG;

diff --git a/neqo-transport/src/packet/mod.rs b/neqo-transport/src/packet/mod.rs
--- a/neqo-transport/src/packet/mod.rs
+++ b/neqo-transport/src/packet/mod.rs
@@ -173,13 +173,28 @@ impl PacketBuilder {
     }
 
     /// Start building a short header packet.
+    ///
+    /// This doesn't fail if there isn't enough space; instead it returns a builder that
+    /// has no available space left.  This allows the caller to extract the encoder
+    /// and any packets that might have been added before as adding a packet header is
+    /// only likely to fail if there are other packets already written.
+    ///
+    /// If, after calling this method, `remaining()` returns 0, then call `abort()` to get
+    /// the encoder back.
     #[allow(clippy::unknown_clippy_lints)] // Until we require rust 1.45.
     #[allow(clippy::reversed_empty_ranges)]
     pub fn short(mut encoder: Encoder, key_phase: bool, dcid: impl AsRef<[u8]>) -> Self {
+        let mut limit = Self::infer_limit(&encoder);
         let header_start = encoder.len();
-        encoder.encode_byte(PACKET_BIT_SHORT | PACKET_BIT_FIXED_QUIC | (u8::from(key_phase) << 2));
-        encoder.encode(dcid.as_ref());
-        let limit = Self::infer_limit(&encoder);
+        // Check that there is enough space for the header.
+        // 5 = 1 (first byte) + 4 (packet number)
+        if limit > encoder.len() && 5 + dcid.as_ref().len() < limit - encoder.len() {
+            encoder
+                .encode_byte(PACKET_BIT_SHORT | PACKET_BIT_FIXED_QUIC | (u8::from(key_phase) << 2));
+            encoder.encode(dcid.as_ref());
+        } else {
+            limit = 0;
+        }
         Self {
             encoder,
             pn: u64::max_value(),
@@ -196,6 +211,8 @@ impl PacketBuilder {
     /// Start building a long header packet.
     /// For an Initial packet you will need to call initial_token(),
     /// even if the token is empty.
+    ///
+    /// See `short()` for more on how to handle this in cases where there is no space.
     #[allow(clippy::unknown_clippy_lints)] // Until we require rust 1.45.
     #[allow(clippy::reversed_empty_ranges)] // For initializing an empty range.
     pub fn long(
@@ -205,12 +222,21 @@ impl PacketBuilder {
         dcid: impl AsRef<[u8]>,
         scid: impl AsRef<[u8]>,
     ) -> Self {
+        let mut limit = Self::infer_limit(&encoder);
         let header_start = encoder.len();
-        encoder.encode_byte(PACKET_BIT_LONG | PACKET_BIT_FIXED_QUIC | pt.code() << 4);
-        encoder.encode_uint(4, quic_version.as_u32());
-        encoder.encode_vec(1, dcid.as_ref());
-        encoder.encode_vec(1, scid.as_ref());
-        let limit = Self::infer_limit(&encoder);
+        // Check that there is enough space for the header.
+        // 11 = 1 (first byte) + 4 (version) + 2 (dcid+scid length) + 4 (packet number)
+        if limit > encoder.len()
+            && 11 + dcid.as_ref().len() + scid.as_ref().len() < limit - encoder.len()
+        {
+            encoder.encode_byte(PACKET_BIT_LONG | PACKET_BIT_FIXED_QUIC | pt.code() << 4);
+            encoder.encode_uint(4, quic_version.as_u32());
+            encoder.encode_vec(1, dcid.as_ref());
+            encoder.encode_vec(1, scid.as_ref());
+        } else {
+            limit = 0;
+        }
+
         Self {
             encoder,
             pn: u64::max_value(),
@@ -242,7 +268,7 @@ impl PacketBuilder {
     /// How many bytes remain against the size limit for the builder.
     #[must_use]
     pub fn remaining(&self) -> usize {
-        self.limit - self.encoder.len()
+        self.limit.saturating_sub(self.encoder.len())
     }
 
     /// Pad with "PADDING" frames.
@@ -258,6 +284,7 @@ impl PacketBuilder {
 
     /// Add unpredictable values for unprotected parts of the packet.
     pub fn scramble(&mut self, quic_bit: bool) {
+        debug_assert!(self.len() > self.header.start);
         let mask = if quic_bit { PACKET_BIT_FIXED_QUIC } else { 0 }
             | if self.is_long() { 0 } else { PACKET_BIT_SPIN };
         let first = self.header.start;
@@ -266,25 +293,29 @@ impl PacketBuilder {
 
     /// For an Initial packet, encode the token.
     /// If you fail to do this, then you will not get a valid packet.
-    pub fn initial_token(&mut self, token: &[u8]) -> Res<()> {
+    pub fn initial_token(&mut self, token: &[u8]) {
         debug_assert_eq!(
             self.encoder[self.header.start] & 0xb0,
             PACKET_BIT_LONG | PACKET_TYPE_INITIAL << 4
         );
-        self.encoder.encode_vvec(token);
-
-        if self.len() > self.limit {
-            qwarn!("Packet contents are more than the limit");
-            debug_assert!(false);
-            return Err(Error::InternalError(18));
+        if Encoder::vvec_len(token.len()) < self.remaining() {
+            self.encoder.encode_vvec(token);
+        } else {
+            self.limit = 0;
         }
-        Ok(())
     }
 
     /// Add a packet number of the given size.
     /// For a long header packet, this also inserts a dummy length.
     /// The length is filled in after calling `build`.
-    pub fn pn(&mut self, pn: PacketNumber, pn_len: usize) -> Res<()> {
+    /// Does nothing if there isn't 4 bytes available other than render this builder
+    /// unusable; if `remaining()` returns 0 at any point, call `abort()`.
+    pub fn pn(&mut self, pn: PacketNumber, pn_len: usize) {
+        if self.remaining() < 4 {
+            self.limit = 0;
+            return;
+        }
+
         // Reserve space for a length in long headers.
         if self.is_long() {
             self.offsets.len = self.encoder.len();
@@ -303,13 +334,6 @@ impl PacketBuilder {
         self.encoder[self.header.start] |= u8::try_from(pn_len - 1).unwrap();
         self.header.end = self.encoder.len();
         self.pn = pn;
-
-        if self.len() > self.limit {
-            qwarn!("Packet contents are more than the limit");
-            debug_assert!(false);
-            return Err(Error::InternalError(19));
-        }
-        Ok(())
     }
 
     fn write_len(&mut self, expansion: usize) {
@@ -883,8 +907,8 @@ mod tests {
             &ConnectionId::from(&[][..]),
             &ConnectionId::from(SERVER_CID),
         );
-        builder.initial_token(&[]).unwrap();
-        builder.pn(1, 2).unwrap();
+        builder.initial_token(&[]);
+        builder.pn(1, 2);
         builder.encode(&SAMPLE_INITIAL_PAYLOAD);
         let packet = builder.build(&mut prot).expect("build");
         assert_eq!(&packet[..], SAMPLE_INITIAL);
@@ -945,7 +969,7 @@ mod tests {
         fixture_init();
         let mut builder =
             PacketBuilder::short(Encoder::new(), true, &ConnectionId::from(SERVER_CID));
-        builder.pn(0, 1).unwrap();
+        builder.pn(0, 1);
         builder.encode(SAMPLE_SHORT_PAYLOAD); // Enough payload for sampling.
         let packet = builder
             .build(&mut CryptoDxState::test_default())
@@ -961,7 +985,7 @@ mod tests {
             let mut builder =
                 PacketBuilder::short(Encoder::new(), true, &ConnectionId::from(SERVER_CID));
             builder.scramble(true);
-            builder.pn(0, 1).unwrap();
+            builder.pn(0, 1);
             firsts.push(builder[0]);
         }
         let is_set = |bit| move |v| v & bit == bit;
@@ -1024,14 +1048,14 @@ mod tests {
             &ConnectionId::from(SERVER_CID),
             &ConnectionId::from(CLIENT_CID),
         );
-        builder.pn(0, 1).unwrap();
+        builder.pn(0, 1);
         builder.encode(&[0; 3]);
         let encoder = builder.build(&mut prot).expect("build");
         assert_eq!(encoder.len(), 45);
         let first = encoder.clone();
 
         let mut builder = PacketBuilder::short(encoder, false, &ConnectionId::from(SERVER_CID));
-        builder.pn(1, 3).unwrap();
+        builder.pn(1, 3);
         builder.encode(&[0]); // Minimal size (packet number is big enough).
         let encoder = builder.build(&mut prot).expect("build");
         assert_eq!(
@@ -1058,7 +1082,7 @@ mod tests {
             &ConnectionId::from(&[][..]),
             &ConnectionId::from(&[][..]),
         );
-        builder.pn(0, 1).unwrap();
+        builder.pn(0, 1);
         builder.encode(&[1, 2, 3]);
         let packet = builder.build(&mut CryptoDxState::test_default()).unwrap();
         assert_eq!(&packet[..], EXPECTED);
@@ -1077,7 +1101,7 @@ mod tests {
                 &ConnectionId::from(&[][..]),
                 &ConnectionId::from(&[][..]),
             );
-            builder.pn(0, 1).unwrap();
+            builder.pn(0, 1);
             builder.scramble(true);
             if (builder[0] & PACKET_BIT_FIXED_QUIC) == 0 {
                 found_unset = true;
@@ -1098,12 +1122,43 @@ mod tests {
             &ConnectionId::from(&[][..]),
             &ConnectionId::from(SERVER_CID),
         );
-        builder.initial_token(&[]).unwrap();
-        builder.pn(1, 2).unwrap();
+        assert_ne!(builder.remaining(), 0);
+        builder.initial_token(&[]);
+        assert_ne!(builder.remaining(), 0);
+        builder.pn(1, 2);
+        assert_ne!(builder.remaining(), 0);
         let encoder = builder.abort();
         assert!(encoder.is_empty());
     }
 
+    #[test]
+    fn build_insufficient_space() {
+        fixture_init();
+
+        let mut builder = PacketBuilder::short(
+            Encoder::with_capacity(100),
+            true,
+            &ConnectionId::from(SERVER_CID),
+        );
+        builder.pn(0, 1);
+        // Pad, but not up to the full capacity. Leave enough space for the
+        // AEAD expansion and some extra, but not for an entire long header.
+        builder.set_limit(75);
+        builder.pad().unwrap();
+        let encoder = builder.build(&mut CryptoDxState::test_default()).unwrap();
+        let encoder_copy = encoder.clone();
+
+        let builder = PacketBuilder::long(
+            encoder,
+            PacketType::Initial,
+            QuicVersion::default(),
+            &ConnectionId::from(SERVER_CID),
+            &ConnectionId::from(SERVER_CID),
+        );
+        assert_eq!(builder.remaining(), 0);
+        assert_eq!(builder.abort(), encoder_copy);
+    }
+
     const SAMPLE_RETRY_V1: &[u8] = &[
         0xff, 0x00, 0x00, 0x00, 0x01, 0x00, 0x08, 0xf0, 0x67, 0xa5, 0x50, 0x2a, 0x42, 0x62, 0xb5,
         0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x04, 0xa2, 0x65, 0xba, 0x2e, 0xff, 0x4d, 0x82, 0x90, 0x58,


</patch>

Function signatures
<Signatures>

</Signatures>

You are a software tester at neqo and your are reviewing the above <patch> for the above <issue>
Identify whether a unit test is needed.
If there is no test needed, return <NO>.
If a test is needed, your task is:
1. Write exactly one rust test `#[test]fn test_...(){...}` block. Do NOT wrap the test inside a 'mod tests' block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. All 'use' declarations must be inside a <imports>...</imports> block.
 Use `use super::<function name> for the function under test.
.If multiple 'use' statements are needed, list each on a separate line.
5. To help you write the test, <Signatures> contains all modified function's:
- name
- parameters
- Return type (assume '()' if empty)
6. Return only the absolute filename as it is in the <patch> block, the use statements, and rust test (no comments or explanations).

Here is an example structure:
<Filename> ... </Filename>
<imports> ... </imports>
<Rust>
#[test]
fn test_<describe_behavior>() {
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
}</Rust>

