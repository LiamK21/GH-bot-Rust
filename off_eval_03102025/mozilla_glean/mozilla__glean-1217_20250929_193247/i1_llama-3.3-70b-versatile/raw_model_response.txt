<Filename> glean-core/src/upload/mod.rs </Filename>
<imports>
use glean_core::upload::policy::Policy;
use glean_core::upload::PingUploadManager;
use glean_core::testing::new_glean;
use std::path::PathBuf;
use std::sync::Arc;
use glean_core::Glean;
use glean_core::ping::PingType;
use glean_core::testing::new_server;
use std::collections::VecDeque;
use glean_core::upload::directory::PingDirectoryManager;
use glean_core::lifetime::Lifetime;
use glean_core::metrics::CounterMetric;
use glean_core::CommonMetricData;
use std::sync::RwLock;
use std::sync::RwLockWriteGuard;
</imports>
<Rust>
#[test]
fn test_pending_pings_metric_updates() {
    let (mut glean, _) = new_glean(None);
    let dir = PathBuf::from("/tmp/test-upload-manager");
    let mut upload_manager = PingUploadManager::new(dir.clone(), Arc::new(Policy::default()), &glean);
    upload_manager.upload_metrics.pending_pings.set(0);
    let ping_type = PingType::new("test", true, /* send_if_empty */ true, vec![]);
    glean.register_ping_type(&ping_type);
    glean.submit_ping(&ping_type, None).unwrap();
    let directory_manager = PingDirectoryManager::new(dir.path());
    let pending_pings = directory_manager.process_dirs().pending_pings;
    let mut pending_pings_count: u64 = 0;
    for _ in pending_pings {
        pending_pings_count += 1;
    }
    upload_manager.process_pending_pings(&glean).unwrap();
    assert_eq!(upload_manager.upload_metrics.pending_pings.get(), Some(pending_pings_count));
}
</Rust>