Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Compile-time detect target OS
Right now we hard-code the OS used in `client_info` in the corresponding wrappers: 
* [Swift](https://github.com/mozilla/glean/blob/f4845e96dbfc2b1645be215aab157cf49e0be19f/glean-core/ios/Glean/Glean.swift#L170)
* [Kotlin](https://github.com/mozilla/glean/blob/f4845e96dbfc2b1645be215aab157cf49e0be19f/glean-core/android/src/main/java/mozilla/telemetry/glean/Glean.kt#L436)

[Python](https://github.com/mozilla/glean/blob/f4845e96dbfc2b1645be215aab157cf49e0be19f/glean-core/python/glean/glean.py#L356) does it at runtime.

We know what target OS we're compiling for and thus we could just detect this at build time (like we already do for [glean-preview](https://github.com/mozilla/glean/blob/f4845e96dbfc2b1645be215aab157cf49e0be19f/glean-core/preview/src/system.rs#L10-L37)

We should do this in glean-core and save us the work in wrappers (and Project FOG)
</issue>

Patch:
<patch>
diff --git a/glean-core/preview/src/core_metrics.rs b/glean-core/preview/src/core_metrics.rs
--- a/glean-core/preview/src/core_metrics.rs
+++ b/glean-core/preview/src/core_metrics.rs
@@ -28,7 +28,6 @@ pub struct InternalMetrics {
     pub app_build: StringMetric,
     pub app_display_version: StringMetric,
     pub app_channel: StringMetric,
-    pub os: StringMetric,
     pub os_version: StringMetric,
     pub architecture: StringMetric,
     pub device_manufacturer: StringMetric,
@@ -62,14 +61,6 @@ impl InternalMetrics {
                 disabled: false,
                 dynamic_label: None,
             }),
-            os: StringMetric::new(CommonMetricData {
-                name: "os".into(),
-                category: "".into(),
-                send_in_pings: vec!["glean_client_info".into()],
-                lifetime: Lifetime::Application,
-                disabled: false,
-                dynamic_label: None,
-            }),
             os_version: StringMetric::new(CommonMetricData {
                 name: "os_version".into(),
                 category: "".into(),

diff --git a/glean-core/preview/src/lib.rs b/glean-core/preview/src/lib.rs
--- a/glean-core/preview/src/lib.rs
+++ b/glean-core/preview/src/lib.rs
@@ -140,7 +140,6 @@ fn initialize_core_metrics(
     if let Some(app_channel) = channel {
         core_metrics.app_channel.set(glean, app_channel);
     }
-    core_metrics.os.set(glean, system::OS.to_string());
     core_metrics.os_version.set(glean, "unknown".to_string());
     core_metrics
         .architecture

diff --git a/glean-core/preview/src/system.rs b/glean-core/preview/src/system.rs
--- a/glean-core/preview/src/system.rs
+++ b/glean-core/preview/src/system.rs
@@ -1,43 +1,33 @@
-// This Source Code Form is subject to the terms of the Mozilla Public
-// License, v. 2.0. If a copy of the MPL was not distributed with this
-// file, You can obtain one at https://mozilla.org/MPL/2.0/.
-
-// Detect and expose `target_os` as a constant.
-// Whether this is a good idea is somewhat debatable.
+// Copyright (c) 2017 The Rust Project Developers
+// Licensed under the MIT License.
+// Original license:
+// https://github.com/RustSec/platforms-crate/blob/ebbd3403243067ba3096f31684557285e352b639/LICENSE-MIT
 //
-// Code adopted from the "platforms" crate: <https://github.com/RustSec/platforms-crate>.
-
-#[cfg(target_os = "android")]
-/// `target_os` when building this crate: `android`
-pub const OS: &str = "Android";
-
-#[cfg(target_os = "ios")]
-/// `target_os` when building this crate: `ios`
-pub const OS: &str = "iOS";
-
-#[cfg(target_os = "linux")]
-/// `target_os` when building this crate: `linux`
-pub const OS: &str = "Linux";
-
-#[cfg(target_os = "macos")]
-/// `target_os` when building this crate: `macos`
-pub const OS: &str = "MacOS";
-
-#[cfg(target_os = "windows")]
-/// `target_os` when building this crate: `windows`
-pub const OS: &str = "Windows";
-
-#[cfg(not(any(
-    target_os = "android",
-    target_os = "ios",
-    target_os = "linux",
-    target_os = "macos",
-    target_os = "windows",
-)))]
-pub const OS: &str = "unknown";
-
-// Detect and expose `target_arch` as a constant
-// Whether this is a good idea is somewhat debatable
+// Permission is hereby granted, free of charge, to any
+// person obtaining a copy of this software and associated
+// documentation files (the "Software"), to deal in the
+// Software without restriction, including without
+// limitation the rights to use, copy, modify, merge,
+// publish, distribute, sublicense, and/or sell copies of
+// the Software, and to permit persons to whom the Software
+// is furnished to do so, subject to the following
+// conditions:
+//
+// The above copyright notice and this permission notice
+// shall be included in all copies or substantial portions
+// of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF
+// ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
+// TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
+// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT
+// SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
+// IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+// DEALINGS IN THE SOFTWARE.
+
+//! Detect and expose `target_arch` as a constant
 
 #[cfg(target_arch = "aarch64")]
 /// `target_arch` when building this crate: `aarch64`

diff --git a/glean-core/preview/src/test.rs b/glean-core/preview/src/test.rs
--- a/glean-core/preview/src/test.rs
+++ b/glean-core/preview/src/test.rs
@@ -66,7 +66,7 @@ fn client_info_reset_after_toggle() {
     // At start we should have a value.
     with_glean(|glean| {
         assert!(core_metrics
-            .os
+            .architecture
             .test_get_value(glean, "glean_client_info")
             .is_some());
     });
@@ -75,7 +75,7 @@ fn client_info_reset_after_toggle() {
     crate::set_upload_enabled(false);
     with_glean(|glean| {
         assert!(!core_metrics
-            .os
+            .architecture
             .test_get_value(glean, "glean_client_info")
             .is_some());
     });
@@ -84,7 +84,7 @@ fn client_info_reset_after_toggle() {
     crate::set_upload_enabled(true);
     with_glean(|glean| {
         assert!(core_metrics
-            .os
+            .architecture
             .test_get_value(glean, "glean_client_info")
             .is_some());
     });

diff --git a/glean-core/src/internal_metrics.rs b/glean-core/src/internal_metrics.rs
--- a/glean-core/src/internal_metrics.rs
+++ b/glean-core/src/internal_metrics.rs
@@ -8,6 +8,7 @@ use super::{metrics::*, CommonMetricData, Lifetime};
 pub struct CoreMetrics {
     pub client_id: UuidMetric,
     pub first_run_date: DatetimeMetric,
+    pub os: StringMetric,
 }
 
 impl CoreMetrics {
@@ -33,6 +34,15 @@ impl CoreMetrics {
                 },
                 TimeUnit::Day,
             ),
+
+            os: StringMetric::new(CommonMetricData {
+                name: "os".into(),
+                category: "".into(),
+                send_in_pings: vec!["glean_client_info".into()],
+                lifetime: Lifetime::Application,
+                disabled: false,
+                dynamic_label: None,
+            }),
         }
     }
 }

diff --git a/glean-core/src/lib.rs b/glean-core/src/lib.rs
--- a/glean-core/src/lib.rs
+++ b/glean-core/src/lib.rs
@@ -36,6 +36,7 @@ mod internal_pings;
 pub mod metrics;
 pub mod ping;
 pub mod storage;
+mod system;
 #[cfg(feature = "upload")]
 mod upload;
 mod util;
@@ -249,6 +250,8 @@ impl Glean {
             // time it is set, that's indeed our "first run".
             self.is_first_run = true;
         }
+
+        self.set_application_lifetime_core_metrics();
     }
 
     /// Called when Glean is initialized to the point where it can correctly
@@ -611,6 +614,11 @@ impl Glean {
         Ok(())
     }
 
+    /// Set internally-handled application lifetime metrics.
+    fn set_application_lifetime_core_metrics(&self) {
+        self.core_metrics.os.set(self, system::OS);
+    }
+
     /// ** This is not meant to be used directly.**
     ///
     /// Clear all the metrics that have `Lifetime::Application`.
@@ -619,6 +627,9 @@ impl Glean {
         if let Some(data) = self.data_store.as_ref() {
             data.clear_lifetime(Lifetime::Application);
         }
+
+        // Set internally handled app lifetime metrics again.
+        self.set_application_lifetime_core_metrics();
     }
 
     /// Return whether or not this is the first run on this profile.

diff --git a/glean-core/src/system.rs b/glean-core/src/system.rs
--- a/glean-core/src/system.rs
+++ b/glean-core/src/system.rs
@@ -0,0 +1,81 @@
+// Copyright (c) 2017 The Rust Project Developers
+// Licensed under the MIT License.
+// Original license:
+// https://github.com/RustSec/platforms-crate/blob/ebbd3403243067ba3096f31684557285e352b639/LICENSE-MIT
+//
+// Permission is hereby granted, free of charge, to any
+// person obtaining a copy of this software and associated
+// documentation files (the "Software"), to deal in the
+// Software without restriction, including without
+// limitation the rights to use, copy, modify, merge,
+// publish, distribute, sublicense, and/or sell copies of
+// the Software, and to permit persons to whom the Software
+// is furnished to do so, subject to the following
+// conditions:
+//
+// The above copyright notice and this permission notice
+// shall be included in all copies or substantial portions
+// of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF
+// ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
+// TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
+// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT
+// SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
+// IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+// DEALINGS IN THE SOFTWARE.
+
+//! Detect and expose `target_os` as a constant.
+//!
+//! Code adopted from the "platforms" crate: <https://github.com/RustSec/platforms-crate>.
+
+#[cfg(target_os = "android")]
+/// `target_os` when building this crate: `android`
+pub const OS: &str = "Android";
+
+#[cfg(target_os = "ios")]
+/// `target_os` when building this crate: `ios`
+pub const OS: &str = "iOS";
+
+#[cfg(target_os = "linux")]
+/// `target_os` when building this crate: `linux`
+pub const OS: &str = "Linux";
+
+#[cfg(target_os = "macos")]
+/// `target_os` when building this crate: `macos`
+pub const OS: &str = "Darwin";
+
+#[cfg(target_os = "windows")]
+/// `target_os` when building this crate: `windows`
+pub const OS: &str = "Windows";
+
+#[cfg(target_os = "freebsd")]
+/// `target_os` when building this crate: `freebsd`
+pub const OS: &str = "FreeBSD";
+
+#[cfg(target_os = "netbsd")]
+/// `target_os` when building this crate: `netbsd`
+pub const OS: &str = "NetBSD";
+
+#[cfg(target_os = "openbsd")]
+/// `target_os` when building this crate: `openbsd`
+pub const OS: &str = "OpenBSD";
+
+#[cfg(target_os = "solaris")]
+/// `target_os` when building this crate: `solaris`
+pub const OS: &str = "Solaris";
+
+#[cfg(not(any(
+    target_os = "android",
+    target_os = "ios",
+    target_os = "linux",
+    target_os = "macos",
+    target_os = "windows",
+    target_os = "freebsd",
+    target_os = "netbsd",
+    target_os = "openbsd",
+    target_os = "solaris",
+)))]
+pub const OS: &str = "unknown";


</patch>

Function signatures
<Signatures>
fn initialize_core_metrics(
glean: &Glean,
client_info: &ClientInfoMetrics,
channel: Option<String>) -> ()

fn client_info_reset_after_toggle() -> ()
</Signatures>

You are a software tester at glean and your are reviewing the above <patch> for the above <issue>
Identify whether a unit test is needed.
If there is no test needed or you believe you need additional testing resources beyond the Rust standard library (e.g., mocking libraries) to write a useful unit test, return <NO>.
If a test is needed, your task is:
1. Write exactly one rust test `#[test]fn test_...(){...}` block. Do NOT wrap the test inside a 'mod tests' block.
If the file you are adding the test already contains a test in the <patch>, ensure that the test name is unique.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. All 'use' declarations must be inside a <imports>...</imports> block. Additionally:
   - Do not use group imports.
  - Import only what is necessary for the test to run and make sure not to have colliding imports.
  - If the <patch> contains a 'mod tests' block with useful imports, do not add them to the <imports> block.
  - Use `use super::<function name> for the function under test.
.  - If multiple 'use' statements are needed, list each on a separate line.
5. To help you write the test, <Signatures> contains all modified function's:
  - name
  - parameters
  - Return type (assume '()' if empty)
6. Return only the absolute filename as it is in the <patch> block, the use statements, and rust test (no comments or explanations).

Here is an example structure:
<Filename> ... </Filename>
<imports> ... </imports>
<Rust>
#[test]
fn test_<describe_behavior>() {
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
}</Rust>

