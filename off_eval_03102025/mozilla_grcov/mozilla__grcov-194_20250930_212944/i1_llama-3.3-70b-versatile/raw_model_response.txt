<Filename> src/path_rewriting.rs </Filename>
<imports> 
use super::rewrite_paths;
use std::path::PathBuf;
use std::collections::HashMap;
use serde_json::Value;
use std::io;
</imports>
<Rust>
#[test]
fn test_apply_mapping_and_get_abs_path() {
  let path_mapping = Some(serde_json::json!({
    "path1": "new_path1",
    "path2": "new_path2"
  }));
  let source_dir = Some(PathBuf::from("src"));
  let prefix_dir = None;
  let result_map: HashMap<String, ()> = HashMap::new();
  let to_ignore_dirs = Vec::new();
  let filter_option = None;
  let ignore_not_existing = false;

  let results = rewrite_paths(
    result_map,
    path_mapping.clone(),
    source_dir.clone(),
    prefix_dir.clone(),
    ignore_not_existing,
    to_ignore_dirs.clone(),
    filter_option.clone(),
  );

  let mut expected_result = Vec::new();
  for (path, _) in result_map {
    let rel_path = apply_mapping(&path_mapping, &path);
    let (abs_path, rel_path) = get_abs_path(&source_dir, rel_path);
    if !rel_path.to_str().unwrap().starts_with("new_") {
      continue;
    }
    expected_result.push((abs_path, rel_path, ()));
  }

  let mut actual_result = Vec::new();
  for result in results {
    if let Some((abs_path, rel_path, _)) = result {
      actual_result.push((abs_path, rel_path));
    }
  }

  assert_eq!(expected_result.len(), actual_result.len());
  for ((abs_path, rel_path), (actual_abs_path, actual_rel_path)) in expected_result.iter().zip(actual_result) {
    assert_eq!(abs_path, actual_abs_path);
    assert_eq!(rel_path, actual_rel_path);
  }
}
</Rust>