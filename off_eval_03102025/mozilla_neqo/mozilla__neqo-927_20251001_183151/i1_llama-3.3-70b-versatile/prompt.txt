Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Fix persistent congestion shortcuts
This is a little tricky for us, but we took two shortcuts in implementing persistent congestion:

1. We just look for first and last lost.  If there are acknowledged packets in between, we shouldn't be declaring persistent congestion, but we do anyway.  The rationale for this is a little sketchy, but the basic idea is that lack of acknowledgment for the whole period indicates that there is some sort of congestion condition.  However, this might be return path congestion, so it's not a good approximation for the forward path.

2. We only look at packets in the same packet number space.  Crossing packet number spaces is somewhat more complicated, but we should be able to do this.  Note that the only time we are able to do this properly is on a timeout, because the handling of ACK frames across packet number spaces is so completely disjoint that fusing that code would be awful.
</issue>

Patch:
<patch>
diff --git a/neqo-transport/src/cc.rs b/neqo-transport/src/cc.rs
--- a/neqo-transport/src/cc.rs
+++ b/neqo-transport/src/cc.rs
@@ -164,6 +164,47 @@ impl CongestionControl {
         );
     }
 
+    fn detect_persistent_congestion(
+        &mut self,
+        prev_largest_acked_sent: Option<Instant>,
+        pto: Duration,
+        lost_packets: &[SentPacket],
+    ) {
+        let pc_period = pto * PERSISTENT_CONG_THRESH;
+
+        let mut last_pn = 1 << 62; // Impossibly large, but not enough to overflow.
+        let mut start = None;
+        for p in lost_packets
+            .iter()
+            .skip_while(|p| Some(p.time_sent) <= prev_largest_acked_sent)
+        {
+            if p.pn != last_pn + 1 {
+                // Not a contiguous range of lost packets, start over.
+                start = None;
+            }
+            last_pn = p.pn;
+            if !p.ack_eliciting() {
+                // Not interesting, keep looking.
+                continue;
+            }
+            if let Some(t) = start {
+                if p.time_sent.duration_since(t) > pc_period {
+                    // In persistent congestion.  Stop.
+                    self.congestion_window = MIN_CONG_WINDOW;
+                    self.acked_bytes = 0;
+                    qlog::metrics_updated(
+                        &mut self.qlog,
+                        &[QlogMetric::CongestionWindow(self.congestion_window)],
+                    );
+                    qinfo!([self], "persistent congestion");
+                    return;
+                }
+            } else {
+                start = Some(p.time_sent);
+            }
+        }
+    }
+
     pub fn on_packets_lost(
         &mut self,
         now: Instant,
@@ -189,23 +230,7 @@ impl CongestionControl {
         let last_lost_pkt = lost_packets.last().unwrap();
         self.on_congestion_event(now, last_lost_pkt.time_sent);
 
-        let congestion_period = pto * PERSISTENT_CONG_THRESH;
-
-        // Simpler to ignore any acked pkts in between first and last lost pkts
-        if let Some(first) = lost_packets
-            .iter()
-            .find(|p| Some(p.time_sent) > prev_largest_acked_sent)
-        {
-            if last_lost_pkt.time_sent.duration_since(first.time_sent) > congestion_period {
-                self.congestion_window = MIN_CONG_WINDOW;
-                self.acked_bytes = 0;
-                qlog::metrics_updated(
-                    &mut self.qlog,
-                    &[QlogMetric::CongestionWindow(self.congestion_window)],
-                );
-                qinfo!([self], "persistent congestion");
-            }
-        }
+        self.detect_persistent_congestion(prev_largest_acked_sent, pto, lost_packets);
     }
 
     pub fn discard(&mut self, pkt: &SentPacket) {
@@ -317,15 +342,26 @@ impl CongestionControl {
 
 #[cfg(test)]
 mod tests {
-    use super::*;
-    use crate::packet::PacketType;
+    use super::{CongestionControl, INITIAL_WINDOW, MIN_CONG_WINDOW, PERSISTENT_CONG_THRESH};
+    use crate::packet::{PacketNumber, PacketType};
+    use crate::tracking::SentPacket;
     use std::rc::Rc;
+    use std::time::Duration;
     use test_fixture::now;
 
+    const PTO: Duration = Duration::from_millis(100);
+    const RTT: Duration = Duration::from_millis(98);
+    const ZERO: Duration = Duration::from_secs(0);
+    const EPSILON: Duration = Duration::from_nanos(1);
+    const GAP: Duration = Duration::from_secs(1);
+    /// The largest time between packets without causing persistent congestion.
+    const SUB_PC: Duration = Duration::from_millis(100 * PERSISTENT_CONG_THRESH as u64);
+    /// The minimum time between packets to cause persistent congestion.
+    /// Uses an odd expression because `Duration` arithmetic isn't `const`.
+    const PC: Duration = Duration::from_nanos(100_000_000 * (PERSISTENT_CONG_THRESH as u64) + 1);
+
     #[test]
     fn issue_876() {
-        const PTO: Duration = Duration::from_millis(100);
-        const RTT: Duration = Duration::from_millis(98);
         let mut cc = CongestionControl::default();
         let time_now = now();
         let time_before = time_now - Duration::from_millis(100);
@@ -403,4 +439,158 @@ mod tests {
         assert_eq!(cc.ssthresh(), INITIAL_WINDOW / 2);
         assert_eq!(cc.bif(), 0);
     }
+
+    fn lost(pn: PacketNumber, ack_eliciting: bool, t: Duration) -> SentPacket {
+        SentPacket::new(
+            PacketType::Short,
+            pn,
+            now() + t,
+            ack_eliciting,
+            Rc::default(),
+            100,
+        )
+    }
+
+    fn persistent_congestion(lost_packets: &[SentPacket]) -> bool {
+        let mut cc = CongestionControl::default();
+        cc.start_pacer(now());
+        for p in lost_packets {
+            cc.on_packet_sent(p, RTT);
+        }
+
+        cc.on_packets_lost(now(), None, PTO, lost_packets);
+        if cc.cwnd() == INITIAL_WINDOW / 2 {
+            false
+        } else if cc.cwnd() == MIN_CONG_WINDOW {
+            true
+        } else {
+            panic!("unexpected cwnd");
+        }
+    }
+
+    /// A span of exactly the PC threshold only reduces the window on loss.
+    #[test]
+    fn persistent_congestion_none() {
+        assert!(!persistent_congestion(&[
+            lost(1, true, ZERO),
+            lost(2, true, SUB_PC),
+        ]));
+    }
+
+    /// A span of just more than the PC threshold causes persistent congestion.
+    #[test]
+    fn persistent_congestion_simple() {
+        assert!(persistent_congestion(&[
+            lost(1, true, ZERO),
+            lost(2, true, PC),
+        ]));
+    }
+
+    /// Both packets need to be ack-eliciting.
+    #[test]
+    fn persistent_congestion_non_ack_eliciting() {
+        assert!(!persistent_congestion(&[
+            lost(1, false, ZERO),
+            lost(2, true, PC),
+        ]));
+        assert!(!persistent_congestion(&[
+            lost(1, true, ZERO),
+            lost(2, false, PC),
+        ]));
+    }
+
+    /// Packets in the middle, of any type, are OK.
+    #[test]
+    fn persistent_congestion_middle() {
+        assert!(persistent_congestion(&[
+            lost(1, true, ZERO),
+            lost(2, false, RTT),
+            lost(3, true, PC),
+        ]));
+        assert!(persistent_congestion(&[
+            lost(1, true, ZERO),
+            lost(2, true, RTT),
+            lost(3, true, PC),
+        ]));
+    }
+
+    /// Leading non-ack-eliciting packets are skipped.
+    #[test]
+    fn persistent_congestion_leading_non_ack_eliciting() {
+        assert!(!persistent_congestion(&[
+            lost(1, false, ZERO),
+            lost(2, true, RTT),
+            lost(3, true, PC),
+        ]));
+        assert!(persistent_congestion(&[
+            lost(1, false, ZERO),
+            lost(2, true, RTT),
+            lost(3, true, RTT + PC),
+        ]));
+    }
+
+    /// Trailing non-ack-eliciting packets aren't relevant.
+    #[test]
+    fn persistent_congestion_trailing_non_ack_eliciting() {
+        assert!(persistent_congestion(&[
+            lost(1, true, ZERO),
+            lost(2, true, PC),
+            lost(3, false, PC + EPSILON),
+        ]));
+        assert!(!persistent_congestion(&[
+            lost(1, true, ZERO),
+            lost(2, true, SUB_PC),
+            lost(3, false, PC),
+        ]));
+    }
+
+    /// Gaps in the middle, of any type, restart the count.
+    #[test]
+    fn persistent_congestion_gap_reset() {
+        assert!(!persistent_congestion(&[
+            lost(1, true, ZERO),
+            lost(3, true, PC),
+        ]));
+        assert!(!persistent_congestion(&[
+            lost(1, true, ZERO),
+            lost(2, true, RTT),
+            lost(4, true, GAP),
+            lost(5, true, GAP + PTO * PERSISTENT_CONG_THRESH),
+        ]));
+    }
+
+    /// A span either side of a gap will cause persistent congestion.
+    #[test]
+    fn persistent_congestion_gap_or() {
+        assert!(persistent_congestion(&[
+            lost(1, true, ZERO),
+            lost(2, true, PC),
+            lost(4, true, GAP),
+            lost(5, true, GAP + PTO),
+        ]));
+        assert!(persistent_congestion(&[
+            lost(1, true, ZERO),
+            lost(2, true, PTO),
+            lost(4, true, GAP),
+            lost(5, true, GAP + PC),
+        ]));
+    }
+
+    /// A gap only restarts after an ack-eliciting packet.
+    #[test]
+    fn persistent_congestion_gap_non_ack_eliciting() {
+        assert!(!persistent_congestion(&[
+            lost(1, true, ZERO),
+            lost(2, true, PTO),
+            lost(4, false, GAP),
+            lost(5, true, GAP + PC),
+        ]));
+        assert!(persistent_congestion(&[
+            lost(1, true, ZERO),
+            lost(2, true, PTO),
+            lost(4, false, GAP),
+            lost(5, true, GAP + RTT),
+            lost(6, true, GAP + RTT + PC),
+        ]));
+    }
 }

diff --git a/neqo-transport/src/tracking.rs b/neqo-transport/src/tracking.rs
--- a/neqo-transport/src/tracking.rs
+++ b/neqo-transport/src/tracking.rs
@@ -123,7 +123,7 @@ impl std::fmt::Debug for PNSpaceSet {
 #[derive(Debug, Clone)]
 pub struct SentPacket {
     pub pt: PacketType,
-    pub pn: u64,
+    pub pn: PacketNumber,
     ack_eliciting: bool,
     pub time_sent: Instant,
     pub tokens: Rc<Vec<RecoveryToken>>,
@@ -138,7 +138,7 @@ pub struct SentPacket {
 impl SentPacket {
     pub fn new(
         pt: PacketType,
-        pn: u64,
+        pn: PacketNumber,
         time_sent: Instant,
         ack_eliciting: bool,
         tokens: Rc<Vec<RecoveryToken>>,
@@ -405,7 +405,7 @@ impl RecvdPackets {
     }
 
     /// Add the packet to the tracked set.
-    pub fn set_received(&mut self, now: Instant, pn: u64, ack_eliciting: bool) {
+    pub fn set_received(&mut self, now: Instant, pn: PacketNumber, ack_eliciting: bool) {
         let next_in_order_pn = self.ranges.front().map_or(0, |pr| pr.largest + 1);
         qdebug!(
             [self],


</patch>

Function signatures
<Signatures>

</Signatures>

You are a software tester at neqo and your are reviewing the above <patch> for the above <issue>
Identify whether a unit test is needed.
If there is no test needed or you believe you need additional testing resources beyond the Rust standard library (e.g., mocking libraries) to write a useful unit test, return <NO>.
If a test is needed, your task is:
1. Write exactly one rust test `#[test]fn test_...(){...}` block. Do NOT wrap the test inside a 'mod tests' block.
If the file you are adding the test already contains a test in the <patch>, ensure that the test name is unique.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. All 'use' declarations must be inside a <imports>...</imports> block. Additionally:
   - Do not use group imports.
  - Import only what is necessary for the test to run and make sure not to have colliding imports.
  - If the <patch> contains a 'mod tests' block with useful imports, do not add them to the <imports> block.
  - Use `use super::<function name> for the function under test.
.  - If multiple 'use' statements are needed, list each on a separate line.
5. To help you write the test, <Signatures> contains all modified function's:
  - name
  - parameters
  - Return type (assume '()' if empty)
6. Return only the absolute filename as it is in the <patch> block, the use statements, and rust test (no comments or explanations).

Here is an example structure:
<Filename> ... </Filename>
<imports> ... </imports>
<Rust>
#[test]
fn test_<describe_behavior>() {
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
}</Rust>

