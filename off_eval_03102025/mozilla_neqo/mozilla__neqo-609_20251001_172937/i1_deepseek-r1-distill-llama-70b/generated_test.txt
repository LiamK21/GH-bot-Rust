#[test]
fn ack_after_pto() {
    let mut client = default_client();
    let mut server = default_server();
    connect_force_idle(&mut client, &mut server);

    let mut now = now();

    // The client sends and is forced into a PTO.
    let _ = send_something(&mut client, now);

    // Jump forward to the PTO and drain the PTO packets.
    now += Duration::from_secs(1);
    for _ in 0..PTO_PACKET_COUNT {
        let dgram = client.process(None, now).dgram();
        assert!(dgram.is_some());
    }
    assert!(client.process(None, now).dgram().is_none());

    // The server now needs to send something that will cause the
    // client to want to acknowledge it.  A little out of order
    // delivery is just the thing.
    // Note: The server can't ACK anything here, but none of what
    // the client has sent so far has been transferred.
    let _ = send_something(&mut server, now);
    let dgram = send_something(&mut server, now);

    // The client is now after a PTO, but if it receives something
    // that demands acknowledgment, it will send just the ACK.
    let ack = client.process(Some(dgram), now).dgram();
    assert!(ack.is_some());

    // Make sure that the packet only contained ACK frames.
    let frames = server.test_process_input(ack.unwrap(), now);
    assert_eq!(frames.len(), 1);
    for (frame, space) in frames {
        assert_eq!(space, PNSpace::ApplicationData);
        assert!(matches!(frame, Frame::Ack { .. }));
    }
}