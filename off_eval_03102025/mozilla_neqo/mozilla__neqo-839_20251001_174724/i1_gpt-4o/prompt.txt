Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Corrupted packet crashes server
```
server          | Server waiting for connection on: V4(0.0.0.0:443)
sim             | Corrupting byte 18 (0xf8 -> 0x15) of the UDP payload (total: 1252)
server          | 0s  0ms INFO Logging initialized
server          | 0s  0ms INFO [Server] Accept connection AttemptKey { remote_address: V4(193.167.0.100:33650), odcid: CID [15]: c79539ca6a17e1c837045be415a0ba }
sim             | Corrupting byte 0 (0xc1 -> 0x33) of the UDP payload (total: 1252)
server          | 0s  5ms INFO Qlog output to /logs/qlog/c79539ca6a17e1c837045be415a0ba.qlog
server          | 0s  6ms INFO [Server 0x563f39f466e8] Received valid Initial packet with scid CID [0]:  dcid CID [15]: c79539ca6a17e1c837045be415a0ba
server          | 0s  6ms INFO [Server 0x563f39f466e8] State change from Init -> WaitInitial
server          | 0s  6ms INFO [CryptoStates] Creating initial cipher state role=Server dcid=c79539ca6a17e1c837045be415a0ba
server          | 0s  6ms INFO Making Write 0 CryptoDxState, cipher=4865
server          | 0s  6ms INFO Making Read 0 CryptoDxState, cipher=4865
server          | 0s  6ms INFO Crypto operation failed NssError { name: "SEC_ERROR_BAD_DATA", code: -8190, desc: "security library: received bad data." }
server          | 0s  7ms WARN [Server 0x7ffd4b2fed70] Dropped received packet: Decryption failure; Total: 1
server          | 0s  7ms INFO [Server 0x563f39f466e8] Garbage packet: Transport error: InvalidPacket
server          | 0s  7ms WARN [Server 0x7ffd4b2fed70] Dropped received packet: Garbage packet; Total: 2
server          | thread 'main' panicked at 'assertion failed: !delays.is_empty()', neqo-transport/src/connection.rs:954:9
```

The problem here is that we are reporting no idle timeout prior to receiving a timeout from the peer.  That's something we can easily fix by using our own idle timeout on its own until we get something from a peer.

Note that this crash will occur in more cases than this, so we should get it fixed promptly.
</issue>

Patch:
<patch>
diff --git a/neqo-transport/src/connection.rs b/neqo-transport/src/connection.rs
--- a/neqo-transport/src/connection.rs
+++ b/neqo-transport/src/connection.rs
@@ -228,6 +228,7 @@ impl RetryInfo {
 /// -transport 10.2 ("Idle Timeout").
 enum IdleTimeoutState {
     Init,
+    New(Instant),
     PacketReceived(Instant),
     AckElicitingPacketSent(Instant),
 }
@@ -254,13 +255,17 @@ impl IdleTimeout {
         self.timeout = min(self.timeout, peer_timeout);
     }
 
-    pub fn expiry(&self, pto: Duration) -> Option<Instant> {
-        match self.state {
-            IdleTimeoutState::Init => None,
-            IdleTimeoutState::PacketReceived(t) | IdleTimeoutState::AckElicitingPacketSent(t) => {
-                Some(t + max(self.timeout, pto * 3))
+    pub fn expiry(&mut self, now: Instant, pto: Duration) -> Instant {
+        let start = match self.state {
+            IdleTimeoutState::Init => {
+                self.state = IdleTimeoutState::New(now);
+                now
             }
-        }
+            IdleTimeoutState::New(t)
+            | IdleTimeoutState::PacketReceived(t)
+            | IdleTimeoutState::AckElicitingPacketSent(t) => t,
+        };
+        start + max(self.timeout, pto * 3)
     }
 
     fn on_packet_sent(&mut self, now: Instant) {
@@ -268,7 +273,9 @@ impl IdleTimeout {
         // time we reset the timeout here.
         match self.state {
             IdleTimeoutState::AckElicitingPacketSent(_) => {}
-            IdleTimeoutState::Init | IdleTimeoutState::PacketReceived(_) => {
+            IdleTimeoutState::Init
+            | IdleTimeoutState::New(_)
+            | IdleTimeoutState::PacketReceived(_) => {
                 self.state = IdleTimeoutState::AckElicitingPacketSent(now);
             }
         }
@@ -278,12 +285,8 @@ impl IdleTimeout {
         self.state = IdleTimeoutState::PacketReceived(now);
     }
 
-    pub fn expired(&self, now: Instant, pto: Duration) -> bool {
-        if let Some(expiry) = self.expiry(pto) {
-            now >= expiry
-        } else {
-            false
-        }
+    pub fn expired(&mut self, now: Instant, pto: Duration) -> bool {
+        now >= self.expiry(now, pto)
     }
 }
 
@@ -930,10 +933,9 @@ impl Connection {
         }
 
         let pto = self.loss_recovery.pto_raw(PNSpace::ApplicationData);
-        if let Some(idle_time) = self.idle_timeout.expiry(pto) {
-            qtrace!([self], "Idle timer {:?}", idle_time);
-            delays.push(idle_time);
-        }
+        let idle_time = self.idle_timeout.expiry(now, pto);
+        qtrace!([self], "Idle timer {:?}", idle_time);
+        delays.push(idle_time);
 
         if let Some(lr_time) = self.loss_recovery.next_timeout() {
             qtrace!([self], "Loss recovery timer {:?}", lr_time);
@@ -952,10 +954,7 @@ impl Connection {
             }
         }
 
-        // Should always at least have idle timeout, once connected
-        assert!(!delays.is_empty());
         let earliest = delays.into_iter().min().unwrap();
-
         // TODO(agrover, mt) - need to analyze and fix #47
         // rather than just clamping to zero here.
         qdebug!(
@@ -1149,6 +1148,7 @@ impl Connection {
 
         // Handle each packet in the datagram
         while !slc.is_empty() {
+            self.stats.packets_rx += 1;
             let (packet, remainder) =
                 match PublicPacket::decode(slc, self.cid_manager.borrow().as_decoder()) {
                     Ok((packet, remainder)) => (packet, remainder),
@@ -1159,7 +1159,6 @@ impl Connection {
                         break;
                     }
                 };
-            self.stats.packets_rx += 1;
             match (packet.packet_type(), &self.state, &self.role) {
                 (PacketType::Initial, State::Init, Role::Server) => {
                     if !packet.is_valid_initial() {
@@ -5782,4 +5781,25 @@ mod tests {
 				   if *maximum_stream_data == RECV_BUFFER_SIZE as u64)
         ));
     }
+
+    #[test]
+    fn corrupted_initial() {
+        let mut client = default_client();
+        let mut server = default_server();
+        let d = client.process(None, now()).dgram().unwrap();
+        let mut corrupted = Vec::from(&d[..]);
+        // Find the last non-zero value and corrupt that.
+        let (idx, _) = corrupted
+            .iter()
+            .enumerate()
+            .rev()
+            .find(|(_, &v)| v != 0)
+            .unwrap();
+        corrupted[idx] ^= 0x76;
+        let dgram = Datagram::new(d.source(), d.destination(), corrupted);
+        server.process_input(dgram, now());
+        // The server should have received some packets, but dropped all of them.
+        assert_ne!(server.stats().packets_rx, 0);
+        assert_eq!(server.stats().packets_rx, server.stats().dropped_rx);
+    }
 }

diff --git a/neqo-transport/src/stats.rs b/neqo-transport/src/stats.rs
--- a/neqo-transport/src/stats.rs
+++ b/neqo-transport/src/stats.rs
@@ -13,15 +13,15 @@ use neqo_common::qwarn;
 pub struct Stats {
     conn_display_info: String,
 
-    /// Total packets received
+    /// Total packets received, including all the bad ones.
     pub packets_rx: usize,
-    /// Total packets sent
+    /// Total packets sent.
     pub packets_tx: usize,
-    /// Duplicate packets received
+    /// Duplicate packets received.
     pub dups_rx: usize,
-    /// Dropped datagrams, or parts thereof
+    /// Dropped packets or dropped garbage.
     pub dropped_rx: usize,
-    /// resumption used
+    /// Whether the connection was resumed successfully.
     pub resumed: bool,
 }


</patch>

Function signatures
<Signatures>

</Signatures>

You are a software tester at neqo and your are reviewing the above <patch> for the above <issue>
Identify whether a unit test is needed.
If there is no test needed or you believe you need additional testing resources beyond the Rust standard library (e.g., mocking libraries) to write a useful unit test, return <NO>.
If a test is needed, your task is:
1. Write exactly one rust test `#[test]fn test_...(){...}` block. Do NOT wrap the test inside a 'mod tests' block.
If the file you are adding the test already contains a test in the <patch>, ensure that the test name is unique.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. All 'use' declarations must be inside a <imports>...</imports> block. Additionally:
   - Do not use group imports.
  - Import only what is necessary for the test to run and make sure not to have colliding imports.
  - If the <patch> contains a 'mod tests' block with useful imports, do not add them to the <imports> block.
  - Use `use super::<function name> for the function under test.
.  - If multiple 'use' statements are needed, list each on a separate line.
5. To help you write the test, <Signatures> contains all modified function's:
  - name
  - parameters
  - Return type (assume '()' if empty)
6. Return only the absolute filename as it is in the <patch> block, the use statements, and rust test (no comments or explanations).

Here is an example structure:
<Filename> ... </Filename>
<imports> ... </imports>
<Rust>
#[test]
fn test_<describe_behavior>() {
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
}</Rust>

