Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Fold process_timer() into process_output()
see https://github.com/mozilla/neqo/issues/75#issuecomment-519387255

In thinking about this one, I think that all we need is two functions:

1.  absorb packet (called process_input today)
2.  do something that might trigger actions from the caller

The Output enum accurately captures those actions: nothing, wait, send a packet.

Now all you need to do as a caller is call 1 if you get a packet, or call 2 when you are done with the task neqo gave you. I think that's clean and simple. From a caller perspective, I don't see what is different in responding to a timeout as opposed to asking for more actions.

Internally, that means that we should be running timer hooks on process_output.
</issue>

Patch:
<patch>
diff --git a/neqo-client/src/main.rs b/neqo-client/src/main.rs
--- a/neqo-client/src/main.rs
+++ b/neqo-client/src/main.rs
@@ -153,10 +153,7 @@ fn process_loop(
         }
 
         match socket.recv(&mut buf[..]) {
-            Err(ref err) if err.kind() == ErrorKind::WouldBlock => {
-                // timer expired
-                client.process_timer(Instant::now());
-            }
+            Err(ref err) if err.kind() == ErrorKind::WouldBlock => {}
             Err(err) => {
                 eprintln!("UDP error: {}", err);
                 exit(1)

diff --git a/neqo-http3/src/connection_client.rs b/neqo-http3/src/connection_client.rs
--- a/neqo-http3/src/connection_client.rs
+++ b/neqo-http3/src/connection_client.rs
@@ -309,13 +309,6 @@ impl Http3Client {
         self.process_http3(now);
     }
 
-    /// This is called when timer expires.
-    pub fn process_timer(&mut self, now: Instant) {
-        qtrace!([self], "Process timer.");
-        self.conn.process_timer(now);
-        self.process_http3(now);
-    }
-
     // Only used by neqo-interop
     pub fn conn(&mut self) -> &mut Connection {
         &mut self.conn

diff --git a/neqo-interop/src/main.rs b/neqo-interop/src/main.rs
--- a/neqo-interop/src/main.rs
+++ b/neqo-interop/src/main.rs
@@ -108,7 +108,6 @@ fn process_loop(
             return Ok(client.state().clone());
         }
 
-        client.process_timer(Instant::now());
         loop {
             let output = client.process_output(Instant::now());
             match output {
@@ -267,7 +266,6 @@ fn process_loop_h3(nctx: &NetworkCtx, handler: &mut H3Handler) -> Result<State,
             return Ok(handler.h3.conn().state().clone());
         }
 
-        handler.h3.conn().process_timer(Instant::now());
         loop {
             let output = handler.h3.conn().process_output(Instant::now());
             match output {

diff --git a/neqo-transport/src/connection.rs b/neqo-transport/src/connection.rs
--- a/neqo-transport/src/connection.rs
+++ b/neqo-transport/src/connection.rs
@@ -746,6 +746,7 @@ impl Connection {
     /// Returns datagrams to send, and how long to wait before calling again
     /// even if no incoming packets.
     pub fn process_output(&mut self, now: Instant) -> Output {
+        self.process_timer(now);
         let pkt = match &self.state {
             State::Init => {
                 let res = self.client_start(now);
@@ -781,7 +782,6 @@ impl Connection {
         if let Some(d) = dgram {
             self.process_input(d, now);
         }
-        self.process_timer(now);
         self.process_output(now)
     }
 
@@ -2254,6 +2254,7 @@ mod tests {
     #[test]
     fn test_conn_stream_create() {
         let mut client = default_client();
+
         let out = client.process(None, now());
         let mut server = default_server();
         let out = server.process(out.dgram(), now());
@@ -2899,7 +2900,7 @@ mod tests {
         client.process(None, now + LOCAL_IDLE_TIMEOUT - Duration::from_secs(1));
         assert!(matches!(client.state(), State::Confirmed));
 
-        client.process_timer(now + LOCAL_IDLE_TIMEOUT);
+        client.process(None, now + LOCAL_IDLE_TIMEOUT);
 
         // Not connected after LOCAL_IDLE_TIMEOUT seconds.
         assert!(matches!(client.state(), State::Closed(_)));
@@ -3005,7 +3006,8 @@ mod tests {
         assert!(matches!(client.state(), State::Confirmed));
 
         // Not connected after 40 seconds.
-        client.process_timer(now + LOCAL_IDLE_TIMEOUT + Duration::from_secs(10));
+        client.process(None, now + LOCAL_IDLE_TIMEOUT + Duration::from_secs(10));
+
         assert!(matches!(client.state(), State::Closed(_)));
     }
 
@@ -3034,7 +3036,7 @@ mod tests {
 
         // Not connected after 40 seconds because timer not reset by second
         // outgoing packet
-        client.process_timer(now + LOCAL_IDLE_TIMEOUT + Duration::from_secs(10));
+        client.process(None, now + LOCAL_IDLE_TIMEOUT + Duration::from_secs(10));
         assert!(matches!(client.state(), State::Closed(_)));
     }
 
@@ -3064,11 +3066,12 @@ mod tests {
 
         // Still connected after 49 seconds because idle timer reset by received
         // packet
-        client.process_timer(now + LOCAL_IDLE_TIMEOUT + Duration::from_secs(19));
+        client.process(None, now + LOCAL_IDLE_TIMEOUT + Duration::from_secs(19));
         assert!(matches!(client.state(), State::Confirmed));
 
         // Not connected after 50 seconds.
-        client.process_timer(now + LOCAL_IDLE_TIMEOUT + Duration::from_secs(20));
+        client.process(None, now + LOCAL_IDLE_TIMEOUT + Duration::from_secs(20));
+
         assert!(matches!(client.state(), State::Closed(_)));
     }
 
@@ -3367,7 +3370,6 @@ mod tests {
 
         // Wait for the PTO.
         now += Duration::from_secs(1);
-        client.process_timer(now); // TODO merge process_timer into process_output.
         let dgrams = send_bytes(&mut client, 2, now);
         assert_eq!(dgrams.len(), 2); // Two packets in the PTO.
 
@@ -3792,7 +3794,7 @@ mod tests {
         stream: u64,
         in_dgrams: Vec<Datagram>,
         now: Instant,
-    ) -> (Datagram, Vec<Frame>) {
+    ) -> (Vec<Datagram>, Vec<Frame>) {
         let mut srv_buf = [0; 4_096];
         let mut recvd_frames = Vec::new();
 
@@ -3812,10 +3814,10 @@ mod tests {
             tx_dgrams.push(dg);
         }
 
-        assert_eq!(tx_dgrams.len(), 1);
+        assert!((tx_dgrams.len() == 1) || (tx_dgrams.len() == 2));
 
         (
-            tx_dgrams.pop().unwrap(),
+            tx_dgrams,
             recvd_frames.into_iter().map(|(f, _e)| f).collect(),
         )
     }
@@ -3899,20 +3901,22 @@ mod tests {
         let (s_tx_dgram, _recvd_frames) = ack_bytes(&mut server, 0, c_tx_dgrams, now);
 
         // Client: Process ack
-        let recvd_frames = client.test_process_input(s_tx_dgram, now);
+        for dgram in s_tx_dgram {
+            let recvd_frames = client.test_process_input(dgram, now);
 
-        // Verify that server-sent frame was what we thought.
-        if let (
-            Frame::Ack {
-                largest_acknowledged,
-                ..
-            },
-            PNSpace::ApplicationData,
-        ) = recvd_frames[0]
-        {
-            assert_eq!(largest_acknowledged, flight1_largest);
-        } else {
-            panic!("Expected an application ACK");
+            // Verify that server-sent frame was what we thought.
+            if let (
+                Frame::Ack {
+                    largest_acknowledged,
+                    ..
+                },
+                PNSpace::ApplicationData,
+            ) = recvd_frames[0]
+            {
+                assert_eq!(largest_acknowledged, flight1_largest);
+            } else {
+                panic!("Expected an application ACK");
+            }
         }
 
         // Client: send more
@@ -3925,20 +3929,22 @@ mod tests {
         let (s_tx_dgram, _recvd_frames) = ack_bytes(&mut server, 0, c_tx_dgrams, now);
 
         // Client: Process ack
-        let recvd_frames = client.test_process_input(s_tx_dgram, now);
+        for dgram in s_tx_dgram {
+            let recvd_frames = client.test_process_input(dgram, now);
 
-        // Verify that server-sent frame was what we thought.
-        if let (
-            Frame::Ack {
-                largest_acknowledged,
-                ..
-            },
-            PNSpace::ApplicationData,
-        ) = recvd_frames[0]
-        {
-            assert_eq!(largest_acknowledged, flight2_largest);
-        } else {
-            panic!("Expected an application ACK");
+            // Verify that server-sent frame was what we thought.
+            if let (
+                Frame::Ack {
+                    largest_acknowledged,
+                    ..
+                },
+                PNSpace::ApplicationData,
+            ) = recvd_frames[0]
+            {
+                assert_eq!(largest_acknowledged, flight2_largest);
+            } else {
+                panic!("Expected an application ACK");
+            }
         }
 
         // If we just triggered cong avoidance, these should be equal
@@ -3969,8 +3975,9 @@ mod tests {
 
         // Server: Receive and generate ack
         let (s_tx_dgram, _) = ack_bytes(&mut server, 0, c_tx_dgrams, now);
-
-        client.test_process_input(s_tx_dgram, now);
+        for dgram in s_tx_dgram {
+            client.test_process_input(dgram, now);
+        }
 
         // If we just triggered cong avoidance, these should be equal
         let cwnd1 = client.loss_recovery.cwnd();
@@ -3980,7 +3987,9 @@ mod tests {
         let (s_tx_dgram, _) = ack_bytes(&mut server, 0, c_tx_dgrams2, now);
 
         // ACK more packets but they were sent before end of recovery period
-        client.test_process_input(s_tx_dgram, now);
+        for dgram in s_tx_dgram {
+            client.test_process_input(dgram, now);
+        }
 
         // cwnd should not have changed since ACKed packets were sent before
         // recovery period expired
@@ -4011,12 +4020,14 @@ mod tests {
         let (s_tx_dgram, _) = ack_bytes(&mut server, 0, c_tx_dgrams, now);
 
         // Client: Process ack
-        client.test_process_input(s_tx_dgram, now);
+        for dgram in s_tx_dgram {
+            client.test_process_input(dgram, now);
+        }
 
         // Should be in CARP now.
         let cwnd1 = client.loss_recovery.cwnd();
 
-        now += Duration::from_secs(10); // Time passes. CARP -> CA
+        now += Duration::from_millis(10); // Time passes. CARP -> CA
 
         // Client: Send more data
         let mut c_tx_dgrams = send_bytes(&mut client, 0, now);
@@ -4028,13 +4039,16 @@ mod tests {
         // Generate ACK
         let (s_tx_dgram, _) = ack_bytes(&mut server, 0, c_tx_dgrams, now);
 
-        client.test_process_input(s_tx_dgram, now);
+        for dgram in s_tx_dgram {
+            client.test_process_input(dgram, now);
+        }
 
         // ACK of pkts sent after start of recovery period should have caused
         // exit from recovery period to just regular congestion avoidance. cwnd
         // should now be a little higher but not as high as acked pkts during
         // slow-start would cause it to be.
         let cwnd2 = client.loss_recovery.cwnd();
+
         assert!(cwnd2 > cwnd1);
         assert!(cwnd2 < cwnd1 + 500);
     }
@@ -4048,17 +4062,17 @@ mod tests {
         // timer. This is rather brittle.
         now += Duration::from_secs(1);
 
-        client.process_timer(now); // Should enter PTO mode
+        // Should enter PTO mode
         let c_tx_dgrams = send_bytes(client, 0, now);
         assert_eq!(c_tx_dgrams.len(), 2); // Two PTO packets
 
         now += Duration::from_secs(2);
-        client.process_timer(now); // Should enter PTO mode
+        // Should enter PTO mode
         let c_tx_dgrams = send_bytes(client, 0, now);
         assert_eq!(c_tx_dgrams.len(), 2); // Two PTO packets
 
         now += Duration::from_secs(4);
-        client.process_timer(now); // Should enter PTO mode
+        // Should enter PTO mode
         let c_tx_dgrams = send_bytes(client, 0, now);
         assert_eq!(c_tx_dgrams.len(), 2); // Two PTO packets
 
@@ -4066,7 +4080,9 @@ mod tests {
         let (s_tx_dgram, _) = ack_bytes(server, 0, c_tx_dgrams, now);
 
         // In PC now.
-        client.test_process_input(s_tx_dgram, now);
+        for dgram in s_tx_dgram {
+            client.test_process_input(dgram, now);
+        }
 
         assert_eq!(client.loss_recovery.cwnd(), MIN_CONG_WINDOW);
         now
@@ -4118,13 +4134,13 @@ mod tests {
         let (s_tx_dgram, _) = ack_bytes(&mut server, 0, c_tx_dgrams, now);
 
         now += Duration::from_millis(100);
-        client.test_process_input(s_tx_dgram, now);
+        for dgram in s_tx_dgram {
+            client.test_process_input(dgram, now);
+        }
 
         // send bytes that will be lost
         let _c_tx_dgrams = send_bytes(&mut client, 0, now);
         now += Duration::from_millis(100);
-        // Not received.
-        // let (s_tx_dgram, _) = ack_bytes(&mut server, 0, c_tx_dgrams, now);
 
         induce_persistent_congestion(&mut client, &mut server, now);
     }
@@ -4147,7 +4163,7 @@ mod tests {
         assert_full_cwnd(&c_tx_dgrams, POST_HANDSHAKE_CWND);
 
         // Server: Receive and generate ack
-        now += Duration::from_millis(100);
+        now += Duration::from_millis(10);
         let (_s_tx_dgram, _) = ack_bytes(&mut server, 0, c_tx_dgrams, now);
 
         // ACK lost.
@@ -4156,19 +4172,21 @@ mod tests {
 
         // New part of test starts here
 
-        now += Duration::from_millis(100);
+        now += Duration::from_millis(10);
 
         // Send packets from after start of CARP
         let c_tx_dgrams = send_bytes(&mut client, 0, now);
         assert_eq!(c_tx_dgrams.len(), 2);
 
         // Server: Receive and generate ack
-        now += Duration::from_millis(100);
+        now += Duration::from_millis(10);
         let (s_tx_dgram, _) = ack_bytes(&mut server, 0, c_tx_dgrams, now);
 
         // No longer in CARP. (pkts acked from after start of CARP)
         // Should be in slow start now.
-        client.test_process_input(s_tx_dgram, now);
+        for dgram in s_tx_dgram {
+            client.test_process_input(dgram, now);
+        }
 
         // ACKing 2 packets should let client send 4.
         let c_tx_dgrams = send_bytes(&mut client, 0, now);
@@ -4259,24 +4277,13 @@ mod tests {
         connect_force_idle(&mut client, &mut server);
         let mut now = now();
 
-        // Both client and server should be idle now.
-        assert_eq!(
-            Output::Callback(LOCAL_IDLE_TIMEOUT),
-            client.process(None, now)
-        );
-        assert_eq!(
-            Output::Callback(LOCAL_IDLE_TIMEOUT),
-            server.process(None, now)
-        );
         assert_eq!(client.get_epochs(), (Some(3), Some(3))); // (write, read)
         assert_eq!(server.get_epochs(), (Some(3), Some(3)));
 
         // TODO(mt) this needs to wait for handshake confirmation,
         // but for now, we can do this immediately.
-        let res = client.initiate_key_update();
-        assert!(res.is_ok());
-        let res = client.initiate_key_update();
-        assert!(res.is_err());
+        assert!(client.initiate_key_update().is_ok());
+        assert!(client.initiate_key_update().is_err());
 
         // Initiating an update should only increase the write epoch.
         assert_eq!(
@@ -4307,15 +4314,16 @@ mod tests {
         // But at this point the client hasn't received a key update from the server.
         // It will be stuck with old keys.
         now += Duration::from_secs(1);
-        client.process_timer(now);
+        client.process(None, now);
         assert_eq!(client.get_epochs(), (Some(4), Some(3)));
-        server.process_timer(now);
+        server.process(None, now);
         assert_eq!(server.get_epochs(), (Some(4), Some(4)));
 
         // Even though the server has updated, it hasn't received an ACK yet.
         assert!(server.initiate_key_update().is_err());
 
-        // Now get an ACK from the server.
+        // Now get an ACK from the server. We needt o send 2 packets to get a ACK because of ACK_DELAY.
+        assert!(send_and_receive(&mut client, &mut server, now).is_none());
         let dgram = send_and_receive(&mut client, &mut server, now);
         assert!(dgram.is_some());
         let res = client.process(dgram, now);
@@ -4333,7 +4341,7 @@ mod tests {
         assert!(server.initiate_key_update().is_err());
 
         now += Duration::from_secs(1);
-        client.process_timer(now);
+        client.process(None, now);
         assert_eq!(client.get_epochs(), (Some(4), Some(4)));
     }
 
@@ -4361,7 +4369,7 @@ mod tests {
             assert_eq!(server.get_epochs(), (Some(4), Some(3)));
             // Now move the server temporarily into the future so that it
             // rotates the keys.  Don't do this at home folks.
-            server.process_timer(now + Duration::from_secs(1));
+            server.process(None, now + Duration::from_secs(1));
             assert_eq!(server.get_epochs(), (Some(4), Some(4)));
         } else {
             panic!("server should have a timer set");


</patch>

Function signatures
<Signatures>
fn process_loop(
local_addr: &SocketAddr,
remote_addr: &SocketAddr,
socket: &UdpSocket,
client: &mut Http3Client,
handler: &mut dyn Handler,
args: &Args) -> Res<neqo_http3::Http3State>

fn process_loop_h3(nctx: &NetworkCtx, handler: &mut H3Handler) -> Result<State, String>

fn process_loop(
nctx: &NetworkCtx,
client: &mut Connection,
handler: &mut dyn Handler) -> Result<State, String>
</Signatures>

You are a software tester at neqo and your are reviewing the above <patch> for the above <issue>
Identify whether a unit test is needed.
If there is no test needed or you believe you need additional testing resources beyond the Rust standard library (e.g., mocking libraries) to write a useful unit test, return <NO>.
If a test is needed, your task is:
1. Write exactly one rust test `#[test]fn test_...(){...}` block. Do NOT wrap the test inside a 'mod tests' block.
If the file you are adding the test already contains a test in the <patch>, ensure that the test name is unique.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. All 'use' declarations must be inside a <imports>...</imports> block. Additionally:
   - Do not use group imports.
  - Import only what is necessary for the test to run and make sure not to have colliding imports.
  - If the <patch> contains a 'mod tests' block with useful imports, do not add them to the <imports> block.
  - Use `use super::<function name> for the function under test.
.  - If multiple 'use' statements are needed, list each on a separate line.
5. To help you write the test, <Signatures> contains all modified function's:
  - name
  - parameters
  - Return type (assume '()' if empty)
6. Return only the absolute filename as it is in the <patch> block, the use statements, and rust test (no comments or explanations).

Here is an example structure:
<Filename> ... </Filename>
<imports> ... </imports>
<Rust>
#[test]
fn test_<describe_behavior>() {
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
}</Rust>

