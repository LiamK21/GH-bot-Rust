#[test]
fn test_multiple_ack_ranges() {
    let mut cc = ClassicCongestionControl::new(NewReno::default());
    let mut now = now();
    let mut next_pn = 0;

    // Simulate sending initial packets to fill the congestion window
    let mut sent_packets = Vec::new();
    for _ in 0..CWND_INITIAL_PKTS {
        let p = SentPacket::new(
            PacketType::Short,
            next_pn,
            now,
            true,
            Vec::new(),
            MAX_DATAGRAM_SIZE,
        );
        next_pn += 1;
        cc.on_packet_sent(&p);
        sent_packets.push(p);
    }

    // Receive multiple ACK ranges
    for i in 0..3 {
        let acked_range = &sent_packets[i..i+1];
        now += RTT;
        cc.on_packets_acked(acked_range, RTT, now);

        assert_eq!(cc.bytes_in_flight(), (CWND_INITIAL_PKTS - i - 1) * MAX_DATAGRAM_SIZE);
        assert_eq!(cc.acked_bytes, (i + 1) * MAX_DATAGRAM_SIZE);
        assert_eq!(cc.congestion_window, (CWND_INITIAL_PKTS + i + 1) * MAX_DATAGRAM_SIZE);
    }

    // Verify final state after all ACKs
    assert_eq!(cc.bytes_in_flight(), 0);
    assert_eq!(cc.acked_bytes, CWND_INITIAL_PKTS * MAX_DATAGRAM_SIZE);
    assert_eq!(cc.congestion_window, (CWND_INITIAL_PKTS + CWND_INITIAL_PKTS) * MAX_DATAGRAM_SIZE);
}