Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Read data frames as well after a stream has been unblocked
Currently we only read header frame after a stream has been unblock and data frame will be only read when a new packet arrives.  This is not ideal because a new packet may not arrive. We should start reading data frame after the stream has been unblocked.
</issue>

Patch:
<patch>
diff --git a/neqo-http3/src/connection.rs b/neqo-http3/src/connection.rs
--- a/neqo-http3/src/connection.rs
+++ b/neqo-http3/src/connection.rs
@@ -511,9 +511,9 @@ impl Http3Connection {
         };
         let mut unblocked_streams: Vec<u64> = Vec::new();
 
-        if self.read_stream_client(stream_id, false)? {
+        if self.read_stream_client(stream_id)? {
             qdebug!([label] "Request/response stream {} read.", stream_id);
-        } else if self.read_stream_server(stream_id, false)? {
+        } else if self.read_stream_server(stream_id)? {
         } else if self
             .control_stream_remote
             .receive_if_this_stream(&mut self.conn, stream_id)?
@@ -567,9 +567,9 @@ impl Http3Connection {
         for stream_id in unblocked_streams {
             qdebug!([self] "Stream {} is unblocked", stream_id);
             if self.role() == Role::Client {
-                self.read_stream_client(stream_id, true)?;
+                self.read_stream_client(stream_id)?;
             } else {
-                self.read_stream_server(stream_id, true)?;
+                self.read_stream_server(stream_id)?;
             }
         }
         Ok(())
@@ -664,7 +664,7 @@ impl Http3Connection {
         Ok(())
     }
 
-    fn read_stream_client(&mut self, stream_id: u64, unblocked: bool) -> Res<bool> {
+    fn read_stream_client(&mut self, stream_id: u64) -> Res<bool> {
         if self.role() != Role::Client {
             return Ok(false);
         }
@@ -679,11 +679,7 @@ impl Http3Connection {
         if let Some(transaction) = &mut self.transactions_client.get_mut(&stream_id) {
             qdebug!([label] "Request/response stream {} is readable.", stream_id);
             found = true;
-            let res = if unblocked {
-                transaction.unblock(&mut self.qpack_decoder)
-            } else {
-                transaction.receive(&mut self.conn, &mut self.qpack_decoder)
-            };
+            let res = transaction.receive(&mut self.conn, &mut self.qpack_decoder);
             if let Err(e) = res {
                 qdebug!([label] "Error {} ocurred", e);
                 if e.is_stream_error() {
@@ -699,7 +695,7 @@ impl Http3Connection {
         Ok(found)
     }
 
-    fn read_stream_server(&mut self, stream_id: u64, unblocked: bool) -> Res<bool> {
+    fn read_stream_server(&mut self, stream_id: u64) -> Res<bool> {
         if self.role() != Role::Server {
             return Ok(false);
         }
@@ -714,11 +710,7 @@ impl Http3Connection {
         if let Some(transaction) = &mut self.transactions_server.get_mut(&stream_id) {
             qdebug!([label] "Request/response stream {} is readable.", stream_id);
             found = true;
-            let res = if unblocked {
-                transaction.unblock(&mut self.qpack_decoder)
-            } else {
-                transaction.receive(&mut self.conn, &mut self.qpack_decoder)
-            };
+            let res = transaction.receive(&mut self.conn, &mut self.qpack_decoder);
             if let Err(e) = res {
                 qdebug!([label] "Error {} ocurred", e);
                 if e.is_stream_error() {
@@ -1264,7 +1256,9 @@ mod tests {
         let _ = connect(false);
     }
 
-    fn connect_and_receive_control_stream(client: bool) -> (Http3Connection, Connection, u64) {
+    fn connect_and_receive_control_stream(
+        client: bool,
+    ) -> (Http3Connection, Connection, u64, QPackEncoder) {
         let (mut hconn, mut neqo_trans_conn) = connect(client);
         let control_stream = neqo_trans_conn.stream_create(StreamType::UniDi).unwrap();
         let mut sent = neqo_trans_conn.stream_send(
@@ -1272,9 +1266,9 @@ mod tests {
             &[0x0, 0x4, 0x6, 0x1, 0x40, 0x64, 0x7, 0x40, 0x64],
         );
         assert_eq!(sent, Ok(9));
-        let encoder_stream = neqo_trans_conn.stream_create(StreamType::UniDi).unwrap();
-        sent = neqo_trans_conn.stream_send(encoder_stream, &[0x2]);
-        assert_eq!(sent, Ok(1));
+        let mut encoder = QPackEncoder::new(true);
+        encoder.add_send_stream(neqo_trans_conn.stream_create(StreamType::UniDi).unwrap());
+        encoder.send(&mut neqo_trans_conn).unwrap();
         let decoder_stream = neqo_trans_conn.stream_create(StreamType::UniDi).unwrap();
         sent = neqo_trans_conn.stream_send(decoder_stream, &[0x3]);
         assert_eq!(sent, Ok(1));
@@ -1283,7 +1277,7 @@ mod tests {
 
         // assert no error occured.
         assert_eq!(hconn.state(), Http3State::Connected);
-        (hconn, neqo_trans_conn, control_stream)
+        (hconn, neqo_trans_conn, control_stream, encoder)
     }
 
     // Client: Test receiving a new control stream and a SETTINGS frame.
@@ -1302,7 +1296,7 @@ mod tests {
     // has been closed.
     #[test]
     fn test_client_close_control_stream() {
-        let (mut hconn, mut neqo_trans_conn, _) = connect_and_receive_control_stream(true);
+        let (mut hconn, mut neqo_trans_conn, _, _) = connect_and_receive_control_stream(true);
         neqo_trans_conn.stream_close_send(3).unwrap();
         let out = neqo_trans_conn.process(None, now());
         hconn.process(out.dgram(), now());
@@ -1313,7 +1307,7 @@ mod tests {
     // has been closed.
     #[test]
     fn test_server_close_control_stream() {
-        let (mut hconn, mut neqo_trans_conn, _) = connect_and_receive_control_stream(false);
+        let (mut hconn, mut neqo_trans_conn, _, _) = connect_and_receive_control_stream(false);
         neqo_trans_conn.stream_close_send(2).unwrap();
         let out = neqo_trans_conn.process(None, now());
         hconn.process(out.dgram(), now());
@@ -1354,7 +1348,7 @@ mod tests {
     // with error HTTP_UNEXPECTED_FRAME.
     #[test]
     fn test_client_receive_settings_twice() {
-        let (mut hconn, mut neqo_trans_conn, _) = connect_and_receive_control_stream(true);
+        let (mut hconn, mut neqo_trans_conn, _, _) = connect_and_receive_control_stream(true);
         // send the second SETTINGS frame.
         let sent = neqo_trans_conn.stream_send(3, &[0x4, 0x6, 0x1, 0x40, 0x64, 0x7, 0x40, 0x64]);
         assert_eq!(sent, Ok(8));
@@ -1367,7 +1361,7 @@ mod tests {
     // with error HTTP_UNEXPECTED_FRAME.
     #[test]
     fn test_server_receive_settings_twice() {
-        let (mut hconn, mut neqo_trans_conn, _) = connect_and_receive_control_stream(false);
+        let (mut hconn, mut neqo_trans_conn, _, _) = connect_and_receive_control_stream(false);
         // send the second SETTINGS frame.
         let sent = neqo_trans_conn.stream_send(2, &[0x4, 0x6, 0x1, 0x40, 0x64, 0x7, 0x40, 0x64]);
         assert_eq!(sent, Ok(8));
@@ -1377,7 +1371,7 @@ mod tests {
     }
 
     fn test_wrong_frame_on_control_stream(client: bool, v: &[u8]) {
-        let (mut hconn, mut neqo_trans_conn, _) = connect_and_receive_control_stream(client);
+        let (mut hconn, mut neqo_trans_conn, _, _) = connect_and_receive_control_stream(client);
 
         // receive a frame that is not allowed on the control stream.
         if client {
@@ -1424,7 +1418,7 @@ mod tests {
     // This function also tests getting stream id that does not fit into a single byte.
     #[test]
     fn test_client_received_unknown_stream() {
-        let (mut hconn, mut neqo_trans_conn, _) = connect_and_receive_control_stream(true);
+        let (mut hconn, mut neqo_trans_conn, _, _) = connect_and_receive_control_stream(true);
 
         // create a stream with unknown type.
         let new_stream_id = neqo_trans_conn.stream_create(StreamType::UniDi).unwrap();
@@ -1456,7 +1450,7 @@ mod tests {
     // also test getting stream id that does not fit into a single byte.
     #[test]
     fn test_server_received_unknown_stream() {
-        let (mut hconn, mut neqo_trans_conn, _) = connect_and_receive_control_stream(false);
+        let (mut hconn, mut neqo_trans_conn, _, _) = connect_and_receive_control_stream(false);
 
         // create a stream with unknown type.
         let new_stream_id = neqo_trans_conn.stream_create(StreamType::UniDi).unwrap();
@@ -1487,7 +1481,7 @@ mod tests {
     // Client: receive a push stream
     #[test]
     fn test_client_received_push_stream() {
-        let (mut hconn, mut neqo_trans_conn, _) = connect_and_receive_control_stream(true);
+        let (mut hconn, mut neqo_trans_conn, _, _) = connect_and_receive_control_stream(true);
 
         // create a push stream.
         let push_stream_id = neqo_trans_conn.stream_create(StreamType::UniDi).unwrap();
@@ -1517,7 +1511,7 @@ mod tests {
     // Server: receiving a push stream on a server should cause WrongStreamDirection
     #[test]
     fn test_server_received_push_stream() {
-        let (mut hconn, mut neqo_trans_conn, _) = connect_and_receive_control_stream(false);
+        let (mut hconn, mut neqo_trans_conn, _, _) = connect_and_receive_control_stream(false);
 
         // create a push stream.
         let push_stream_id = neqo_trans_conn.stream_create(StreamType::UniDi).unwrap();
@@ -1546,7 +1540,7 @@ mod tests {
 
     // Test wrong frame on req/rec stream
     fn test_wrong_frame_on_request_stream(v: &[u8], err: Error) {
-        let (mut hconn, mut neqo_trans_conn, _) = connect_and_receive_control_stream(true);
+        let (mut hconn, mut neqo_trans_conn, _, _) = connect_and_receive_control_stream(true);
 
         assert_eq!(
             hconn.fetch("GET", "https", "something.com", "/", &[]),
@@ -1693,7 +1687,7 @@ mod tests {
     #[test]
     #[allow(clippy::cognitive_complexity)]
     fn fetch_basic() {
-        let (mut hconn, mut neqo_trans_conn, _) = connect_and_receive_control_stream(true);
+        let (mut hconn, mut neqo_trans_conn, _, _) = connect_and_receive_control_stream(true);
         let request_stream_id = hconn
             .fetch("GET", "https", "something.com", "/", &[])
             .unwrap();
@@ -1865,7 +1859,7 @@ mod tests {
     // Send a request with the request body.
     #[test]
     fn fetch_with_data() {
-        let (mut hconn, mut neqo_trans_conn, _) = connect_and_receive_control_stream(true);
+        let (mut hconn, mut neqo_trans_conn, _, _) = connect_and_receive_control_stream(true);
         let request_stream_id = hconn
             .fetch("GET", "https", "something.com", "/", &[])
             .unwrap();
@@ -1929,7 +1923,7 @@ mod tests {
 
     // send a request with request body containing request_body. We expect to receive expected_data_frame_header.
     fn fetch_with_data_length_xbytes(request_body: &[u8], expected_data_frame_header: &[u8]) {
-        let (mut hconn, mut neqo_trans_conn, _) = connect_and_receive_control_stream(true);
+        let (mut hconn, mut neqo_trans_conn, _, _) = connect_and_receive_control_stream(true);
         let request_stream_id = hconn
             .fetch("GET", "https", "something.com", "/", &[])
             .unwrap();
@@ -2041,7 +2035,7 @@ mod tests {
         expected_second_data_frame_header: &[u8],
         expected_second_data_frame: &[u8],
     ) {
-        let (mut hconn, mut neqo_trans_conn, _) = connect_and_receive_control_stream(true);
+        let (mut hconn, mut neqo_trans_conn, _, _) = connect_and_receive_control_stream(true);
         let request_stream_id = hconn
             .fetch("GET", "https", "something.com", "/", &[])
             .unwrap();
@@ -2257,7 +2251,7 @@ mod tests {
     // Test receiving STOP_SENDING with the EarlyResponse error code.
     #[test]
     fn test_stop_sending_early_response() {
-        let (mut hconn, mut neqo_trans_conn, _) = connect_and_receive_control_stream(true);
+        let (mut hconn, mut neqo_trans_conn, _, _) = connect_and_receive_control_stream(true);
         let request_stream_id = hconn
             .fetch("GET", "https", "something.com", "/", &[])
             .unwrap();
@@ -2359,7 +2353,7 @@ mod tests {
     // Server sends stop sending and reset.
     #[test]
     fn test_stop_sending_other_error_with_reset() {
-        let (mut hconn, mut neqo_trans_conn, _) = connect_and_receive_control_stream(true);
+        let (mut hconn, mut neqo_trans_conn, _, _) = connect_and_receive_control_stream(true);
         let request_stream_id = hconn
             .fetch("GET", "https", "something.com", "/", &[])
             .unwrap();
@@ -2424,7 +2418,7 @@ mod tests {
     // We will reset the stream anyway.
     #[test]
     fn test_stop_sending_other_error_wo_reset() {
-        let (mut hconn, mut neqo_trans_conn, _) = connect_and_receive_control_stream(true);
+        let (mut hconn, mut neqo_trans_conn, _, _) = connect_and_receive_control_stream(true);
         let request_stream_id = hconn
             .fetch("GET", "https", "something.com", "/", &[])
             .unwrap();
@@ -2484,7 +2478,7 @@ mod tests {
     // in hconn.events. The events will be removed.
     #[test]
     fn test_stop_sending_and_reset_other_error_with_events() {
-        let (mut hconn, mut neqo_trans_conn, _) = connect_and_receive_control_stream(true);
+        let (mut hconn, mut neqo_trans_conn, _, _) = connect_and_receive_control_stream(true);
         let request_stream_id = hconn
             .fetch("GET", "https", "something.com", "/", &[])
             .unwrap();
@@ -2564,7 +2558,7 @@ mod tests {
     // The events will be removed.
     #[test]
     fn test_stop_sending_other_error_with_events() {
-        let (mut hconn, mut neqo_trans_conn, _) = connect_and_receive_control_stream(true);
+        let (mut hconn, mut neqo_trans_conn, _, _) = connect_and_receive_control_stream(true);
         let request_stream_id = hconn
             .fetch("GET", "https", "something.com", "/", &[])
             .unwrap();
@@ -2638,7 +2632,7 @@ mod tests {
     // Server sends a reset. We will close sending side as well.
     #[test]
     fn test_reset_wo_stop_sending() {
-        let (mut hconn, mut neqo_trans_conn, _) = connect_and_receive_control_stream(true);
+        let (mut hconn, mut neqo_trans_conn, _, _) = connect_and_receive_control_stream(true);
         let request_stream_id = hconn
             .fetch("GET", "https", "something.com", "/", &[])
             .unwrap();
@@ -2695,7 +2689,7 @@ mod tests {
     }
 
     fn test_incomplet_frame(res: &[u8], error: Error) {
-        let (mut hconn, mut neqo_trans_conn, _) = connect_and_receive_control_stream(true);
+        let (mut hconn, mut neqo_trans_conn, _, _) = connect_and_receive_control_stream(true);
         let request_stream_id = hconn
             .fetch("GET", "https", "something.com", "/", &[])
             .unwrap();
@@ -2790,7 +2784,7 @@ mod tests {
     // test goaway
     #[test]
     fn test_goaway() {
-        let (mut hconn, mut neqo_trans_conn, _control_stream) =
+        let (mut hconn, mut neqo_trans_conn, _control_stream, _) =
             connect_and_receive_control_stream(true);
         let request_stream_id_1 = hconn
             .fetch("GET", "https", "something.com", "/", &[])
@@ -2893,7 +2887,7 @@ mod tests {
     }
 
     fn connect_and_send_request() -> (Http3Connection, Connection, u64) {
-        let (mut hconn, mut neqo_trans_conn, _) = connect_and_receive_control_stream(true);
+        let (mut hconn, mut neqo_trans_conn, _, _) = connect_and_receive_control_stream(true);
         let request_stream_id = hconn
             .fetch("GET", "https", "something.com", "/", &[])
             .unwrap();
@@ -3277,7 +3271,7 @@ mod tests {
 
     #[test]
     fn test_multiple_data_frames() {
-        let (mut hconn, mut neqo_trans_conn, _) = connect_and_receive_control_stream(true);
+        let (mut hconn, mut neqo_trans_conn, _, _) = connect_and_receive_control_stream(true);
         let request_stream_id = hconn
             .fetch("GET", "https", "something.com", "/", &Vec::<Header>::new())
             .unwrap();
@@ -3374,7 +3368,7 @@ mod tests {
 
     #[test]
     fn test_receive_grease_before_response() {
-        let (mut hconn, mut neqo_trans_conn, _) = connect_and_receive_control_stream(true);
+        let (mut hconn, mut neqo_trans_conn, _, _) = connect_and_receive_control_stream(true);
         let request_stream_id = hconn
             .fetch(
                 "GET",
@@ -3464,4 +3458,108 @@ mod tests {
             Err(Error::InvalidStreamId)
         );
     }
+
+    #[test]
+    fn test_read_frames_header_blocked() {
+        let (mut hconn, mut neqo_trans_conn, _, mut encoder) =
+            connect_and_receive_control_stream(true);
+        let request_stream_id = hconn
+            .fetch(
+                "GET",
+                "https",
+                "something.com",
+                "/",
+                &Vec::<(String, String)>::new(),
+            )
+            .unwrap();
+        assert_eq!(request_stream_id, 0);
+        let _ = hconn.stream_close_send(request_stream_id);
+        let out = hconn.process(None, now());
+        neqo_trans_conn.process(out.dgram(), now());
+
+        encoder.set_max_capacity(100).unwrap();
+        encoder.set_max_blocked_streams(100).unwrap();
+
+        // find the new request/response stream and send frame v on it.
+        let events = neqo_trans_conn.events();
+        for e in events {
+            match e {
+                ConnectionEvent::NewStream {
+                    stream_id,
+                    stream_type,
+                } => {
+                    assert_eq!(stream_id, request_stream_id);
+                    assert_eq!(stream_type, StreamType::BiDi);
+                }
+                ConnectionEvent::RecvStreamReadable { stream_id } => {
+                    assert_eq!(stream_id, request_stream_id);
+                    let mut buf = [0u8; 100];
+                    let (amount, fin) = neqo_trans_conn.stream_recv(stream_id, &mut buf).unwrap();
+                    assert_eq!(fin, true);
+                    assert_eq!(amount, 18);
+                    assert_eq!(
+                        buf[..18],
+                        [
+                            0x01, 0x10, 0x00, 0x00, 0xd1, 0xd7, 0x50, 0x89, 0x41, 0xe9, 0x2a, 0x67,
+                            0x35, 0x53, 0x2e, 0x43, 0xd3, 0xc1
+                        ]
+                    );
+
+                    let headers = vec![
+                        (String::from(":status"), String::from("200")),
+                        (String::from("my-header"), String::from("my-header")),
+                        (String::from("content-length"), String::from("3")),
+                    ];
+                    let encoded_headers = encoder.encode_header_block(&headers, stream_id);
+                    let hframe = HFrame::Headers {
+                        len: encoded_headers.len() as u64,
+                    };
+                    let mut d = Encoder::default();
+                    hframe.encode(&mut d);
+                    d.encode(&encoded_headers);
+                    let d_frame = HFrame::Data { len: 3 };
+                    d_frame.encode(&mut d);
+                    d.encode(&[0x61, 0x62, 0x63]);
+                    let _ = neqo_trans_conn.stream_send(stream_id, &d[..]);
+                    neqo_trans_conn.stream_close_send(stream_id).unwrap();
+                }
+                _ => {}
+            }
+        }
+        // Send response before sending encoder instructions.
+        let out = neqo_trans_conn.process(None, now());
+        let _out = hconn.process(out.dgram(), now());
+
+        let header_ready_event = |e| matches!(e, Http3Event::HeaderReady { .. });
+        assert!(!hconn.events().any(header_ready_event));
+
+        // Send encoder instructions to unblock the stream.
+        encoder.send(&mut neqo_trans_conn).unwrap();
+
+        let out = neqo_trans_conn.process(None, now());
+        let _out = hconn.process(out.dgram(), now());
+        let _out = hconn.process(None, now());
+
+        let mut recv_header = false;
+        let mut recv_data = false;
+        // Now the stream is unblocked and both headers and data will be consumed.
+        let events = hconn.events();
+        for e in events {
+            match e {
+                Http3Event::HeaderReady { stream_id } => {
+                    assert_eq!(stream_id, request_stream_id);
+                    recv_header = true;
+                }
+                Http3Event::DataReadable { stream_id } => {
+                    recv_data = true;
+                    assert_eq!(stream_id, request_stream_id);
+                }
+                x => {
+                    eprintln!("event {:?}", x);
+                    panic!()
+                }
+            }
+        }
+        assert!(recv_header && recv_data);
+    }
 }

diff --git a/neqo-http3/src/transaction_client.rs b/neqo-http3/src/transaction_client.rs
--- a/neqo-http3/src/transaction_client.rs
+++ b/neqo-http3/src/transaction_client.rs
@@ -294,7 +294,21 @@ impl TransactionClient {
                         break Ok(());
                     }
                 }
-                TransactionRecvState::BlockedDecodingHeaders { .. } => break Ok(()),
+                TransactionRecvState::BlockedDecodingHeaders { ref buf, fin } => {
+                    match decoder.decode_header_block(buf, self.stream_id)? {
+                        Some(headers) => {
+                            self.add_headers(Some(headers))?;
+                            if fin {
+                                self.set_state_to_close_pending();
+                                break Ok(());
+                            }
+                        }
+                        None => {
+                            qdebug!([self] "decoding header is blocked.");
+                            break Ok(());
+                        }
+                    }
+                }
                 TransactionRecvState::WaitingForData => {
                     match self.recv_frame_header(conn)? {
                         None => break Ok(()),
@@ -448,41 +462,22 @@ impl TransactionClient {
                     self.add_headers(Some(headers))?;
                     if fin {
                         self.set_state_to_close_pending();
-                        return Ok(true);
                     }
+                    Ok(fin)
                 }
                 None => {
-                    qdebug!([label] "decoding header is blocked.");
                     let mut tmp: Vec<u8> = Vec::new();
                     mem::swap(&mut tmp, buf);
                     self.recv_state =
                         TransactionRecvState::BlockedDecodingHeaders { buf: tmp, fin };
-                    return Ok(true);
+                    Ok(true)
                 }
-            };
-            Ok(false)
+            }
         } else {
             panic!("This is only called when recv_state is ReadingHeaders.");
         }
     }
 
-    pub fn unblock(&mut self, decoder: &mut QPackDecoder) -> Res<()> {
-        if let TransactionRecvState::BlockedDecodingHeaders { ref mut buf, fin } = self.recv_state {
-            match decoder.decode_header_block(buf, self.stream_id)? {
-                Some(headers) => {
-                    self.add_headers(Some(headers))?;
-                    if fin {
-                        self.set_state_to_close_pending();
-                    }
-                }
-                None => panic!("We must not be blocked again!"),
-            };
-        } else {
-            panic!("Stream must be in the block state!");
-        }
-        Ok(())
-    }
-
     pub fn close_send(&mut self, conn: &mut Connection) -> Res<()> {
         match self.send_state {
             TransactionSendState::SendingHeaders { ref mut fin, .. } => {

diff --git a/neqo-http3/src/transaction_server.rs b/neqo-http3/src/transaction_server.rs
--- a/neqo-http3/src/transaction_server.rs
+++ b/neqo-http3/src/transaction_server.rs
@@ -161,8 +161,17 @@ impl TransactionServer {
                     } else {
                         self.state = TransactionState::ReadingRequestDone;
                     }
+                    break Ok(());
+                }
+                TransactionState::BlockedDecodingHeaders { ref mut buf } => {
+                    self.request_headers = decoder.decode_header_block(buf, self.stream_id)?;
+                    if self.request_headers.is_some() {
+                        self.state = TransactionState::ReadingRequestDone;
+                    } else {
+                        qdebug!([self] "decoding header is still blocked.");
+                    }
+                    break Ok(());
                 }
-                TransactionState::BlockedDecodingHeaders { .. } => break Ok(()),
                 TransactionState::ReadingRequestDone => break Ok(()),
                 TransactionState::SendingResponse => break Ok(()),
                 TransactionState::Error => break Ok(()),
@@ -188,19 +197,6 @@ impl TransactionServer {
         Ok(())
     }
 
-    pub fn unblock(&mut self, decoder: &mut QPackDecoder) -> Res<()> {
-        if let TransactionState::BlockedDecodingHeaders { ref mut buf } = self.state {
-            self.request_headers = decoder.decode_header_block(buf, self.stream_id)?;
-            if self.request_headers.is_none() {
-                panic!("We must not be blocked again!");
-            }
-            self.state = TransactionState::ReadingRequestDone;
-        } else {
-            panic!("Stream must be in the block state!");
-        }
-        Ok(())
-    }
-
     pub fn done_reading_request(&self) -> bool {
         self.state == TransactionState::ReadingRequestDone
     }


</patch>

Function signatures
<Signatures>

</Signatures>

You are a software tester at neqo and your are reviewing the above <patch> for the above <issue>
Identify whether a unit test is needed.
If there is no test needed or you believe you need additional testing resources beyond the Rust standard library (e.g., mocking libraries) to write a useful unit test, return <NO>.
If a test is needed, your task is:
1. Write exactly one rust test `#[test]fn test_...(){...}` block. Do NOT wrap the test inside a 'mod tests' block.
If the file you are adding the test already contains a test in the <patch>, ensure that the test name is unique.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. All 'use' declarations must be inside a <imports>...</imports> block. Additionally:
   - Do not use group imports.
  - Import only what is necessary for the test to run and make sure not to have colliding imports.
  - If the <patch> contains a 'mod tests' block with useful imports, do not add them to the <imports> block.
  - Use `use super::<function name> for the function under test.
.  - If multiple 'use' statements are needed, list each on a separate line.
5. To help you write the test, <Signatures> contains all modified function's:
  - name
  - parameters
  - Return type (assume '()' if empty)
6. Return only the absolute filename as it is in the <patch> block, the use statements, and rust test (no comments or explanations).

Here is an example structure:
<Filename> ... </Filename>
<imports> ... </imports>
<Rust>
#[test]
fn test_<describe_behavior>() {
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
}</Rust>

