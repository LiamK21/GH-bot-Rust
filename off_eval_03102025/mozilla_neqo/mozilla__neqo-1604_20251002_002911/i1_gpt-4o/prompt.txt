Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
`mio-extras` not being updated for mio>0.6
See https://github.com/dimbleby/mio-extras:
> This library is not compatible with mio 0.7. However, there's a similar project named [mio-misc](https://github.com/onurzdg/mio-misc) that works with mio 0.7.

I haven't checked whether and how `mio-misc` could be used to provide `Timer` functionality for `neqo-server.`

See #1511 
</issue>

Patch:
<patch>
diff --git a/neqo-client/src/main.rs b/neqo-client/src/main.rs
--- a/neqo-client/src/main.rs
+++ b/neqo-client/src/main.rs
@@ -22,13 +22,12 @@ use std::{
 };
 
 use clap::Parser;
-use common::IpTos;
 use futures::{
     future::{select, Either},
     FutureExt, TryFutureExt,
 };
 use neqo_common::{
-    self as common, event::Provider, hex, qdebug, qinfo, qlog::NeqoQlog, Datagram, Role,
+    self as common, event::Provider, hex, qdebug, qinfo, qlog::NeqoQlog, udp, Datagram, Role,
 };
 use neqo_crypto::{
     constants::{TLS_AES_128_GCM_SHA256, TLS_AES_256_GCM_SHA384, TLS_CHACHA20_POLY1305_SHA256},
@@ -42,7 +41,7 @@ use neqo_transport::{
     EmptyConnectionIdGenerator, Error as TransportError, StreamId, StreamType, Version,
 };
 use qlog::{events::EventImportance, streamer::QlogStreamer};
-use tokio::{net::UdpSocket, time::Sleep};
+use tokio::time::Sleep;
 use url::{Origin, Url};
 
 #[derive(Debug)]
@@ -351,21 +350,6 @@ impl QuicParameters {
     }
 }
 
-async fn emit_datagram(socket: &UdpSocket, out_dgram: Datagram) -> Result<(), io::Error> {
-    let sent = match socket.send_to(&out_dgram, &out_dgram.destination()).await {
-        Ok(res) => res,
-        Err(ref err) if err.kind() != io::ErrorKind::WouldBlock => {
-            eprintln!("UDP send error: {err:?}");
-            0
-        }
-        Err(e) => return Err(e),
-    };
-    if sent != out_dgram.len() {
-        eprintln!("Unable to send all {} bytes of datagram", out_dgram.len());
-    }
-    Ok(())
-}
-
 fn get_output_file(
     url: &Url,
     output_dir: &Option<PathBuf>,
@@ -415,7 +399,7 @@ enum Ready {
 
 // Wait for the socket to be readable or the timeout to fire.
 async fn ready(
-    socket: &UdpSocket,
+    socket: &udp::Socket,
     mut timeout: Option<&mut Pin<Box<Sleep>>>,
 ) -> Result<Ready, io::Error> {
     let socket_ready = Box::pin(socket.readable()).map_ok(|()| Ready::Socket);
@@ -426,43 +410,6 @@ async fn ready(
     select(socket_ready, timeout_ready).await.factor_first().0
 }
 
-fn read_dgram(
-    socket: &UdpSocket,
-    local_address: &SocketAddr,
-) -> Result<Option<Datagram>, io::Error> {
-    let buf = &mut [0u8; 2048];
-    let (sz, remote_addr) = match socket.try_recv_from(&mut buf[..]) {
-        Err(ref err)
-            if err.kind() == io::ErrorKind::WouldBlock
-                || err.kind() == io::ErrorKind::Interrupted =>
-        {
-            return Ok(None)
-        }
-        Err(err) => {
-            eprintln!("UDP recv error: {err:?}");
-            return Err(err);
-        }
-        Ok(res) => res,
-    };
-
-    if sz == buf.len() {
-        eprintln!("Might have received more than {} bytes", buf.len());
-    }
-
-    if sz == 0 {
-        eprintln!("zero length datagram received?");
-        Ok(None)
-    } else {
-        Ok(Some(Datagram::new(
-            remote_addr,
-            *local_address,
-            IpTos::default(),
-            None,
-            &buf[..sz],
-        )))
-    }
-}
-
 trait StreamHandler {
     fn process_header_ready(&mut self, stream_id: StreamId, fin: bool, headers: Vec<Header>);
     fn process_data_readable(
@@ -817,7 +764,7 @@ fn to_headers(values: &[impl AsRef<str>]) -> Vec<Header> {
 
 struct ClientRunner<'a> {
     local_addr: SocketAddr,
-    socket: &'a UdpSocket,
+    socket: &'a udp::Socket,
     client: Http3Client,
     handler: Handler<'a>,
     timeout: Option<Pin<Box<Sleep>>>,
@@ -827,7 +774,7 @@ struct ClientRunner<'a> {
 impl<'a> ClientRunner<'a> {
     fn new(
         args: &'a mut Args,
-        socket: &'a UdpSocket,
+        socket: &'a udp::Socket,
         local_addr: SocketAddr,
         remote_addr: SocketAddr,
         hostname: &str,
@@ -880,7 +827,7 @@ impl<'a> ClientRunner<'a> {
 
             match ready(self.socket, self.timeout.as_mut()).await? {
                 Ready::Socket => loop {
-                    let dgram = read_dgram(self.socket, &self.local_addr)?;
+                    let dgram = self.socket.recv(&self.local_addr)?;
                     if dgram.is_none() {
                         break;
                     }
@@ -915,7 +862,8 @@ impl<'a> ClientRunner<'a> {
         loop {
             match self.client.process(dgram.take(), Instant::now()) {
                 Output::Datagram(dgram) => {
-                    emit_datagram(self.socket, dgram).await?;
+                    self.socket.writable().await?;
+                    self.socket.send(dgram)?;
                 }
                 Output::Callback(new_timeout) => {
                     qinfo!("Setting timeout of {:?}", new_timeout);
@@ -1051,16 +999,7 @@ async fn main() -> Res<()> {
             SocketAddr::V6(..) => SocketAddr::new(IpAddr::V6(Ipv6Addr::from([0; 16])), 0),
         };
 
-        let socket = match std::net::UdpSocket::bind(local_addr) {
-            Err(e) => {
-                eprintln!("Unable to bind UDP socket: {e}");
-                exit(1)
-            }
-            Ok(s) => s,
-        };
-        socket.set_nonblocking(true)?;
-        let socket = UdpSocket::from_std(socket)?;
-
+        let socket = udp::Socket::bind(local_addr)?;
         let real_local = socket.local_addr().unwrap();
         println!(
             "{} Client connecting: {:?} -> {:?}",
@@ -1125,17 +1064,16 @@ mod old {
         time::Instant,
     };
 
-    use neqo_common::{event::Provider, qdebug, qinfo, Datagram};
+    use neqo_common::{event::Provider, qdebug, qinfo, udp, Datagram};
     use neqo_crypto::{AuthenticationStatus, ResumptionToken};
     use neqo_transport::{
         Connection, ConnectionEvent, EmptyConnectionIdGenerator, Error, Output, State, StreamId,
         StreamType,
     };
-    use tokio::{net::UdpSocket, time::Sleep};
+    use tokio::time::Sleep;
     use url::Url;
 
-    use super::{get_output_file, qlog_new, read_dgram, ready, Args, KeyUpdateState, Ready, Res};
-    use crate::emit_datagram;
+    use super::{get_output_file, qlog_new, ready, Args, KeyUpdateState, Ready, Res};
 
     struct HandlerOld<'b> {
         streams: HashMap<StreamId, Option<File>>,
@@ -1321,7 +1259,7 @@ mod old {
 
     pub struct ClientRunner<'a> {
         local_addr: SocketAddr,
-        socket: &'a UdpSocket,
+        socket: &'a udp::Socket,
         client: Connection,
         handler: HandlerOld<'a>,
         timeout: Option<Pin<Box<Sleep>>>,
@@ -1331,7 +1269,7 @@ mod old {
     impl<'a> ClientRunner<'a> {
         pub fn new(
             args: &'a Args,
-            socket: &'a UdpSocket,
+            socket: &'a udp::Socket,
             local_addr: SocketAddr,
             remote_addr: SocketAddr,
             origin: &str,
@@ -1394,7 +1332,7 @@ mod old {
 
                 match ready(self.socket, self.timeout.as_mut()).await? {
                     Ready::Socket => loop {
-                        let dgram = read_dgram(self.socket, &self.local_addr)?;
+                        let dgram = self.socket.recv(&self.local_addr)?;
                         if dgram.is_none() {
                             break;
                         }
@@ -1430,7 +1368,8 @@ mod old {
             loop {
                 match self.client.process(dgram.take(), Instant::now()) {
                     Output::Datagram(dgram) => {
-                        emit_datagram(self.socket, dgram).await?;
+                        self.socket.writable().await?;
+                        self.socket.send(dgram)?;
                     }
                     Output::Callback(new_timeout) => {
                         qinfo!("Setting timeout of {:?}", new_timeout);

diff --git a/neqo-common/src/datagram.rs b/neqo-common/src/datagram.rs
--- a/neqo-common/src/datagram.rs
+++ b/neqo-common/src/datagram.rs
@@ -53,6 +53,11 @@ impl Datagram {
     pub fn ttl(&self) -> Option<u8> {
         self.ttl
     }
+
+    #[must_use]
+    pub(crate) fn into_data(self) -> Vec<u8> {
+        self.d
+    }
 }
 
 impl Deref for Datagram {

diff --git a/neqo-common/src/lib.rs b/neqo-common/src/lib.rs
--- a/neqo-common/src/lib.rs
+++ b/neqo-common/src/lib.rs
@@ -17,6 +17,8 @@ pub mod log;
 pub mod qlog;
 pub mod timer;
 pub mod tos;
+#[cfg(feature = "udp")]
+pub mod udp;
 
 use std::fmt::Write;

diff --git a/neqo-common/src/tos.rs b/neqo-common/src/tos.rs
--- a/neqo-common/src/tos.rs
+++ b/neqo-common/src/tos.rs
@@ -46,6 +46,12 @@ impl From<u8> for IpTosEcn {
     }
 }
 
+impl From<IpTos> for IpTosEcn {
+    fn from(value: IpTos) -> Self {
+        IpTosEcn::from(value.0 & 0x3)
+    }
+}
+
 /// Diffserv Codepoints, mapped to the upper six bits of the TOS field.
 /// <https://www.iana.org/assignments/dscp-registry/dscp-registry.xhtml>
 #[derive(Copy, Clone, PartialEq, Eq, Enum, Default, Debug)]
@@ -159,6 +165,12 @@ impl From<u8> for IpTosDscp {
     }
 }
 
+impl From<IpTos> for IpTosDscp {
+    fn from(value: IpTos) -> Self {
+        IpTosDscp::from(value.0 & 0xfc)
+    }
+}
+
 /// The type-of-service field in an IP packet.
 #[allow(clippy::module_name_repetitions)]
 #[derive(Copy, Clone, PartialEq, Eq)]
@@ -169,22 +181,37 @@ impl From<IpTosEcn> for IpTos {
         Self(u8::from(v))
     }
 }
+
 impl From<IpTosDscp> for IpTos {
     fn from(v: IpTosDscp) -> Self {
         Self(u8::from(v))
     }
 }
+
 impl From<(IpTosDscp, IpTosEcn)> for IpTos {
     fn from(v: (IpTosDscp, IpTosEcn)) -> Self {
         Self(u8::from(v.0) | u8::from(v.1))
     }
 }
+
+impl From<(IpTosEcn, IpTosDscp)> for IpTos {
+    fn from(v: (IpTosEcn, IpTosDscp)) -> Self {
+        Self(u8::from(v.0) | u8::from(v.1))
+    }
+}
+
 impl From<IpTos> for u8 {
     fn from(v: IpTos) -> Self {
         v.0
     }
 }
 
+impl From<u8> for IpTos {
+    fn from(v: u8) -> Self {
+        Self(v)
+    }
+}
+
 impl Debug for IpTos {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         f.debug_tuple("IpTos")
@@ -287,4 +314,12 @@ mod tests {
         let iptos_dscp: IpTos = dscp.into();
         assert_eq!(u8::from(iptos_dscp), dscp as u8);
     }
+
+    #[test]
+    fn u8_to_iptos() {
+        let tos = 0x8b;
+        let iptos: IpTos = (IpTosEcn::Ce, IpTosDscp::Af41).into();
+        assert_eq!(tos, u8::from(iptos));
+        assert_eq!(IpTos::from(tos), iptos);
+    }
 }

diff --git a/neqo-common/src/udp.rs b/neqo-common/src/udp.rs
--- a/neqo-common/src/udp.rs
+++ b/neqo-common/src/udp.rs
@@ -0,0 +1,154 @@
+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
+// option. This file may not be copied, modified, or distributed
+// except according to those terms.
+
+#![allow(clippy::missing_errors_doc)] // Functions simply delegate to tokio and quinn-udp.
+#![allow(clippy::missing_panics_doc)] // Functions simply delegate to tokio and quinn-udp.
+
+use std::{
+    io::{self, IoSliceMut},
+    net::{SocketAddr, ToSocketAddrs},
+    slice,
+};
+
+use quinn_udp::{EcnCodepoint, RecvMeta, Transmit, UdpSocketState};
+use tokio::io::Interest;
+
+use crate::{Datagram, IpTos};
+
+pub struct Socket {
+    socket: tokio::net::UdpSocket,
+    state: UdpSocketState,
+}
+
+impl Socket {
+    /// Calls [`std::net::UdpSocket::bind`] and instantiates [`quinn_udp::UdpSocketState`].
+    pub fn bind<A: ToSocketAddrs>(addr: A) -> Result<Self, io::Error> {
+        let socket = std::net::UdpSocket::bind(addr)?;
+
+        Ok(Self {
+            state: quinn_udp::UdpSocketState::new((&socket).into())?,
+            socket: tokio::net::UdpSocket::from_std(socket)?,
+        })
+    }
+
+    /// See [`tokio::net::UdpSocket::local_addr`].
+    pub fn local_addr(&self) -> io::Result<SocketAddr> {
+        self.socket.local_addr()
+    }
+
+    /// See [`tokio::net::UdpSocket::writable`].
+    pub async fn writable(&self) -> Result<(), io::Error> {
+        self.socket.writable().await
+    }
+
+    /// See [`tokio::net::UdpSocket::readable`].
+    pub async fn readable(&self) -> Result<(), io::Error> {
+        self.socket.readable().await
+    }
+
+    /// Send the UDP datagram on the specified socket.
+    pub fn send(&self, d: Datagram) -> io::Result<usize> {
+        let transmit = Transmit {
+            destination: d.destination(),
+            ecn: EcnCodepoint::from_bits(Into::<u8>::into(d.tos())),
+            contents: d.into_data().into(),
+            segment_size: None,
+            src_ip: None,
+        };
+
+        let n = self.socket.try_io(Interest::WRITABLE, || {
+            self.state
+                .send((&self.socket).into(), slice::from_ref(&transmit))
+        })?;
+
+        assert_eq!(n, 1, "only passed one slice");
+
+        Ok(n)
+    }
+
+    /// Receive a UDP datagram on the specified socket.
+    pub fn recv(&self, local_address: &SocketAddr) -> Result<Option<Datagram>, io::Error> {
+        let mut buf = [0; u16::MAX as usize];
+
+        let mut meta = RecvMeta::default();
+
+        match self.socket.try_io(Interest::READABLE, || {
+            self.state.recv(
+                (&self.socket).into(),
+                &mut [IoSliceMut::new(&mut buf)],
+                slice::from_mut(&mut meta),
+            )
+        }) {
+            Ok(n) => {
+                assert_eq!(n, 1, "only passed one slice");
+            }
+            Err(ref err)
+                if err.kind() == io::ErrorKind::WouldBlock
+                    || err.kind() == io::ErrorKind::Interrupted =>
+            {
+                return Ok(None)
+            }
+            Err(err) => {
+                return Err(err);
+            }
+        };
+
+        if meta.len == 0 {
+            eprintln!("zero length datagram received?");
+            return Ok(None);
+        }
+
+        if meta.len == buf.len() {
+            eprintln!("Might have received more than {} bytes", buf.len());
+        }
+
+        Ok(Some(Datagram::new(
+            meta.addr,
+            *local_address,
+            meta.ecn.map(|n| IpTos::from(n as u8)).unwrap_or_default(),
+            None, // TODO: get the real TTL https://github.com/quinn-rs/quinn/issues/1749
+            &buf[..meta.len],
+        )))
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use crate::{IpTos, IpTosDscp, IpTosEcn};
+
+    #[tokio::test]
+    async fn datagram_tos() -> Result<(), io::Error> {
+        let sender = Socket::bind("127.0.0.1:0")?;
+        let receiver_addr: SocketAddr = "127.0.0.1:0".parse().unwrap();
+        let receiver = Socket::bind(receiver_addr)?;
+
+        let datagram = Datagram::new(
+            sender.local_addr()?,
+            receiver.local_addr()?,
+            IpTos::from((IpTosDscp::Le, IpTosEcn::Ect1)),
+            None,
+            "Hello, world!".as_bytes().to_vec(),
+        );
+
+        sender.writable().await?;
+        sender.send(datagram.clone())?;
+
+        receiver.readable().await?;
+        let received_datagram = receiver
+            .recv(&receiver_addr)
+            .expect("receive to succeed")
+            .expect("receive to yield datagram");
+
+        // Assert that the ECN is correct.
+        assert_eq!(
+            IpTosEcn::from(datagram.tos()),
+            IpTosEcn::from(received_datagram.tos())
+        );
+
+        Ok(())
+    }
+}

diff --git a/neqo-server/src/main.rs b/neqo-server/src/main.rs
--- a/neqo-server/src/main.rs
+++ b/neqo-server/src/main.rs
@@ -27,7 +27,7 @@ use futures::{
     future::{select, select_all, Either},
     FutureExt,
 };
-use neqo_common::{hex, qdebug, qinfo, qwarn, Datagram, Header, IpTos};
+use neqo_common::{hex, qinfo, qwarn, udp, Datagram, Header};
 use neqo_crypto::{
     constants::{TLS_AES_128_GCM_SHA256, TLS_AES_256_GCM_SHA384, TLS_CHACHA20_POLY1305_SHA256},
     generate_ech_keys, init_db, random, AntiReplay, Cipher,
@@ -40,7 +40,7 @@ use neqo_transport::{
     ConnectionIdGenerator, ConnectionParameters, Output, RandomConnectionIdGenerator, StreamType,
     Version,
 };
-use tokio::{net::UdpSocket, time::Sleep};
+use tokio::time::Sleep;
 
 use crate::old_https::Http09Server;
 
@@ -305,21 +305,6 @@ impl QuicParameters {
     }
 }
 
-async fn emit_packet(socket: &mut UdpSocket, out_dgram: Datagram) {
-    let sent = match socket.send_to(&out_dgram, &out_dgram.destination()).await {
-        Err(ref err) => {
-            if err.kind() != io::ErrorKind::WouldBlock || err.kind() == io::ErrorKind::Interrupted {
-                eprintln!("UDP send error: {err:?}");
-            }
-            0
-        }
-        Ok(res) => res,
-    };
-    if sent != out_dgram.len() {
-        eprintln!("Unable to send all {} bytes of datagram", out_dgram.len());
-    }
-}
-
 fn qns_read_response(filename: &str) -> Option<Vec<u8>> {
     let mut file_path = PathBuf::from("/www");
     file_path.push(filename.trim_matches(|p| p == '/'));
@@ -578,48 +563,11 @@ impl HttpServer for SimpleServer {
     }
 }
 
-fn read_dgram(
-    socket: &mut UdpSocket,
-    local_address: &SocketAddr,
-) -> Result<Option<Datagram>, io::Error> {
-    let buf = &mut [0u8; 2048];
-    let (sz, remote_addr) = match socket.try_recv_from(&mut buf[..]) {
-        Err(ref err)
-            if err.kind() == io::ErrorKind::WouldBlock
-                || err.kind() == io::ErrorKind::Interrupted =>
-        {
-            return Ok(None)
-        }
-        Err(err) => {
-            eprintln!("UDP recv error: {err:?}");
-            return Err(err);
-        }
-        Ok(res) => res,
-    };
-
-    if sz == buf.len() {
-        eprintln!("Might have received more than {} bytes", buf.len());
-    }
-
-    if sz == 0 {
-        eprintln!("zero length datagram received?");
-        Ok(None)
-    } else {
-        Ok(Some(Datagram::new(
-            remote_addr,
-            *local_address,
-            IpTos::default(),
-            None,
-            &buf[..sz],
-        )))
-    }
-}
-
 struct ServersRunner {
     args: Args,
     server: Box<dyn HttpServer>,
     timeout: Option<Pin<Box<Sleep>>>,
-    sockets: Vec<(SocketAddr, UdpSocket)>,
+    sockets: Vec<(SocketAddr, udp::Socket)>,
 }
 
 impl ServersRunner {
@@ -632,11 +580,11 @@ impl ServersRunner {
         let sockets = hosts
             .into_iter()
             .map(|host| {
-                let socket = std::net::UdpSocket::bind(host)?;
+                let socket = udp::Socket::bind(host)?;
                 let local_addr = socket.local_addr()?;
                 println!("Server waiting for connection on: {local_addr:?}");
-                socket.set_nonblocking(true)?;
-                Ok((host, UdpSocket::from_std(socket)?))
+
+                Ok((host, socket))
             })
             .collect::<Result<_, io::Error>>()?;
         let server = Self::create_server(&args);
@@ -683,7 +631,7 @@ impl ServersRunner {
     }
 
     /// Tries to find a socket, but then just falls back to sending from the first.
-    fn find_socket(&mut self, addr: SocketAddr) -> &mut UdpSocket {
+    fn find_socket(&mut self, addr: SocketAddr) -> &mut udp::Socket {
         let ((_host, first_socket), rest) = self.sockets.split_first_mut().unwrap();
         rest.iter_mut()
             .map(|(_host, socket)| socket)
@@ -696,12 +644,13 @@ impl ServersRunner {
             .unwrap_or(first_socket)
     }
 
-    async fn process(&mut self, mut dgram: Option<&Datagram>) {
+    async fn process(&mut self, mut dgram: Option<&Datagram>) -> Result<(), io::Error> {
         loop {
             match self.server.process(dgram.take(), self.args.now()) {
                 Output::Datagram(dgram) => {
                     let socket = self.find_socket(dgram.source());
-                    emit_packet(socket, dgram).await;
+                    socket.writable().await?;
+                    socket.send(dgram)?;
                 }
                 Output::Callback(new_timeout) => {
                     qinfo!("Setting timeout of {:?}", new_timeout);
@@ -709,11 +658,11 @@ impl ServersRunner {
                     break;
                 }
                 Output::None => {
-                    qdebug!("Output::None");
                     break;
                 }
             }
         }
+        Ok(())
     }
 
     // Wait for any of the sockets to be readable or the timeout to fire.
@@ -740,20 +689,20 @@ impl ServersRunner {
             match self.ready().await? {
                 Ready::Socket(inx) => loop {
                     let (host, socket) = self.sockets.get_mut(inx).unwrap();
-                    let dgram = read_dgram(socket, host)?;
+                    let dgram = socket.recv(host)?;
                     if dgram.is_none() {
                         break;
                     }
-                    self.process(dgram.as_ref()).await;
+                    self.process(dgram.as_ref()).await?;
                 },
                 Ready::Timeout => {
                     self.timeout = None;
-                    self.process(None).await;
+                    self.process(None).await?;
                 }
             }
 
             self.server.process_events(&self.args, self.args.now());
-            self.process(None).await;
+            self.process(None).await?;
         }
     }
 }


</patch>

Function signatures
<Signatures>
fn to_headers(values: &[impl AsRef<str>]) -> Vec<Header>

fn main() -> Res<()>

fn ready(
socket: &udp::Socket,
mut timeout: Option<&mut Pin<Box<Sleep>>>) -> Result<Ready, io::Error>
</Signatures>

You are a software tester at neqo and your are reviewing the above <patch> for the above <issue>
Identify whether a unit test is needed.
If there is no test needed or you believe you need additional testing resources beyond the Rust standard library (e.g., mocking libraries) to write a useful unit test, return <NO>.
If a test is needed, your task is:
1. Write exactly one rust test `#[test]fn test_...(){...}` block. Do NOT wrap the test inside a 'mod tests' block.
If the file you are adding the test already contains a test in the <patch>, ensure that the test name is unique.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. All 'use' declarations must be inside a <imports>...</imports> block. Additionally:
   - Do not use group imports.
  - Import only what is necessary for the test to run and make sure not to have colliding imports.
  - If the <patch> contains a 'mod tests' block with useful imports, do not add them to the <imports> block.
  - Use `use super::<function name> for the function under test.
.  - If multiple 'use' statements are needed, list each on a separate line.
5. To help you write the test, <Signatures> contains all modified function's:
  - name
  - parameters
  - Return type (assume '()' if empty)
6. Return only the absolute filename as it is in the <patch> block, the use statements, and rust test (no comments or explanations).

Here is an example structure:
<Filename> ... </Filename>
<imports> ... </imports>
<Rust>
#[test]
fn test_<describe_behavior>() {
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
}</Rust>

