#[test]
fn test_packet_removal_after_2rtt() {
    let mut loss_recovery = LossRecovery::default();
    let now = Instant::now();
    let pn_space = PNSpace::ApplicationData;
    let rtt = Duration::from_millis(100);

    // Simulate sending a packet
    loss_recovery.spaces[pn_space].sent_packets.insert(
        1,
        SentPacket {
            ack_eliciting: true,
            time_sent: now - rtt * 3,
            tokens: vec![RecoveryToken::Ack(crate::tracking::AckToken {
                space: pn_space,
                ranges: vec![],
            })],
            time_declared_lost: None,
        },
    );

    // Detect lost packets
    let lost_packets = loss_recovery.detect_lost_packets(pn_space, now);

    // Mark the packet as lost
    assert_eq!(lost_packets.len(), 1);
    assert_eq!(lost_packets[0].time_declared_lost, Some(now));

    // Simulate time passing to 2*RTT after the packet was declared lost
    let later = now + rtt * 2 + Duration::from_millis(1);

    // Detect lost packets again
    let lost_packets_again = loss_recovery.detect_lost_packets(pn_space, later);

    // The packet should be removed after 2*RTT
    assert!(lost_packets_again.is_empty());
    assert!(loss_recovery.spaces[pn_space].sent_packets.is_empty());
}