#[test]
fn test_response_stream_receives_headers() {
    let mut client = connect("https://example.com").unwrap();
    let mut req = client.newTransactionalRequest();
    req.send_headers(&[("host", "example.com")]);
    client.send_request(req).unwrap();

    let mut server = client.server_mut();
    server.encoder.set_max_capacity(100).unwrap();
    server.encoder.set_max_blocked_streams(100).unwrap();

    let headers = vec![
        ("content-length".to_string(), "0".to_string()),
        (":status".to_string(), "200".to_string()),
    ];
    let encoded_headers = server.encoder.encode_header_block(&headers, 3);
    let hframe = HFrame::Headers {
        header_block: encoded_headers.to_vec(),
    };
    let mut d = Vec::new();
    hframe.encode(&mut d);

    let stream_id = 3;
    server.conn.stream_send(stream_id, &d).unwrap();
    server.conn.stream_close_send(stream_id).unwrap();

    client.process(server.conn.process(None), 0);
    let mut events: Vec<_> = client.events().collect();
    assert!(events.iter().any(|e| match e { neqo_http3::client::ClientEvent::HeadersReady { stream_id: 3, .. } => true, _ => false }));

    client.read_response_headers(3).unwrap();
    assert!(client.events().is_empty());
}