<think>
Okay, I need to determine whether a unit test is necessary for the given patch. The patch modifies the `on_ack` function in `recovery.rs` by adding a check for `now.checked_duration_since(send_time)`. This change is likely to prevent potential underflows or invalid calculations when `send_time` is in the future relative to `now`.

First, I should understand what the patch does. Before, the code subtracted `send_time` from `now` directly, which could result in a negative value if `send_time` is after `now`. The patch replaces this with a safe operation using `checked_duration_since`, which returns `None` if `send_time` is after `now`, thus avoiding negative samples.

So, the purpose of the test is to ensure that when `send_time` is after `now`, the `rtt.update` function isn't called with a negative sample. The test should fail before the patch because without the check, `rtt.update` would receive a negative value, which might cause incorrect behavior. After the patch, it shouldn't update in such cases.

I need to write a test that simulates `send_time` being in the future. I'll create a test case where `now` is before `send_time`, so `now.checked_duration_since(send_time)` returns `None`, and `rtt.update` isn't called.

I'll use a mock `LossRecovery` struct and a mock `Rtt` implementation to track whether `update` was called. The mock `Rtt` will have a boolean flag that's set to `true` when `update` is called. Then, I'll call `on_ack` with `send_time` set to a time after `now` and check that the `updated` flag remains `false`.

I should import necessary modules like `std::time::{Duration, Instant}` and `super::recovery::LossRecovery` for the test. The test function will be named `test_on_ack_does_not_update_rtt_when_send_time_is_in_future` to clearly describe its purpose.

Putting it all together, the test initializes the mock structs, sets up `send_time` to be after `now`, calls `on_ack`, and asserts that `rtt_updated` is `false`. This ensures that the patch correctly prevents the update when `send_time` is in the future.
</think>

<Filename>neqo-transport/src/recovery.rs</Filename>
<imports>
use std::time::{Duration, Instant};
use super::recovery::LossRecovery;
</imports>
<Rust>
#[test]
fn test_on_ack_does_not_update_rtt_when_send_time_is_in_future() {
    struct MockRtt {
        updated: bool,
    }

    impl MockRtt {
        fn new() -> Self {
            Self { updated: false }
        }

        fn update(&mut self, _qlog: &mut dyn std::any::Any, _sample: Duration, _ack_delay: Duration, _confirmed: bool, _now: Instant) {
            self.updated = true;
        }
    }

    let mut recovery = LossRecovery {
        qlog: None,
        rtt: MockRtt::new(),
        confirmed_time: None,
    };

    let send_time = Instant::now() + Duration::from_secs(1);
    let now = Instant::now();

    recovery.on_ack(&mut MockRtt::new(), send_time, Duration::from_secs(1), now);

    assert!(!recovery.rtt.updated);
}
</Rust>