<think>
Okay, I need to figure out how to write a regression test for the given patch. The issue is that datagrams were being sent at a higher priority than other data, which isn't correct because they're best-effort. The patch reorders the write_frames calls so that datagrams are sent after higher priority streams.

First, I should understand what the patch changed. Before, datagrams were written after Normal priority, but now they're moved to after all the streams have written their frames. So, the test needs to ensure that datagrams are indeed being sent after other data.

I think the best approach is to simulate a scenario where multiple types of data are written and then check the order in which they're sent. The test will create a mock builder and track the order of write_frames calls.

I'll set up a test where the connection has some data to send: maybe a critical stream, an important stream, and a datagram. Then, I'll check if the datagram is written last.

I'll use a MockFrameBuilder that records the order of priorities. The test will call write_frames with different priorities and datagrams, then verify the order.

I need to make sure the test fails before the patch and passes after. So, without the patch, datagrams would be written before Normal streams, causing the test to fail. After the patch, they should come after.

I'll structure the test by initializing the connection, setting up the frame builder, and then asserting the order of priorities in the recorded calls.

I should also make sure to import all necessary modules and keep the test self-contained without any group imports. The test name needs to be unique, so I'll name it test_datagram_priority.

Finally, I'll write the test function, including the mock, setup, and assertions to check the correct order.
</think>

The test verifies that datagrams are sent after higher priority streams by checking the order of write_frames calls.

<Filename>neqo-transport/src/connection/mod.rs</Filename>
<imports>
use super::connection::Connection;
use super::frame::FrameBuilder;
use super::frame::TransmissionPriority;
use std::sync::Arc;
</imports>
<Rust>
#[test]
fn test_datagram_priority() {
    struct MockFrameBuilder {
        called_with_priority: Vec<TransmissionPriority>,
    }

    impl FrameBuilder for MockFrameBuilder {
        fn is_full(&self) -> bool {
            false
        }

        fn write(&mut self, _data: &[u8]) -> usize {
            0
        }

        fn finish(&mut self) -> Vec<u8> {
            Vec::new()
        }

        fn write_frames(
            &mut self,
            priority: TransmissionPriority,
            _builder: &mut dyn FrameBuilder,
            _tokens: usize,
            _frame_stats: &mut dyn std::any::Any,
        ) {
            self.called_with_priority.push(priority);
        }
    }

    let mut connection = Connection::new(Arc::new(MockFrameBuilder {
        called_with_full: false,
        called_with_priority: Vec::new(),
    }));

    let expected_order = vec![
        TransmissionPriority::Critical,
        TransmissionPriority::Important,
        TransmissionPriority::High,
        TransmissionPriority::Normal,
        // Datagrams should come after all streams
    ];

    connection.write_frames();

    assert_eq!(
        connection.frame_builder.called_with_priority,
        expected_order
    );
}
</Rust>