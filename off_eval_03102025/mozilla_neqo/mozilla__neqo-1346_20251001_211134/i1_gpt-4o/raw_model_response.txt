<Filename>neqo-server/src/main.rs</Filename>
<imports>
use super::SimpleServer;
use std::cell::RefCell;
use std::rc::Rc;
use neqo_crypto::AntiReplay;
use neqo_transport::RandomConnectionIdGenerator;
use std::time::Instant;
use neqo_common::Datagram;
use neqo_http3::Http3ServerEvent;
use neqo_http3::Http3Parameters;
use neqo_transport::ConnectionParameters;
use neqo_transport::server::ValidateAddress;
use std::collections::HashMap;
use neqo_http3::StreamId;
use neqo_http3::Http3OrWebTransportStream;
use neqo_http3::Error;
use neqo_common::Header;
use std::fmt;
use std::path::PathBuf;
use std::convert::TryFrom;
use std::fs::OpenOptions;
use std::io::Write;
use std::net::SocketAddr;
use std::str::FromStr;
use std::sync::Arc;
use std::time::Duration;
use mio::net::UdpSocket;
use mio::{Events, Poll, PollOpt, Ready, Token};
use mio_extras::timer::{Builder, Timeout, Timer};
use structopt::StructOpt;
use neqo_common::{hex, qdebug, qinfo, qwarn};
use neqo_crypto::{
    constants::{TLS_AES_128_GCM_SHA256, TLS_AES_256_GCM_SHA384, TLS_CHACHA20_POLY1305_SHA256},
    generate_ech_keys, init_db, random, AntiReplay, Cipher,
};
use neqo_http3::{Error, Http3OrWebTransportStream, Http3Parameters, Http3Server, Http3ServerEvent, StreamId};
use neqo_transport::{
    server::ValidateAddress, tparams::PreferredAddress, CongestionControlAlgorithm,
    ConnectionParameters, Output, RandomConnectionIdGenerator, StreamType, Version,
};
use std::cmp::min;
use std::collections::{HashMap, HashSet};
use std::fmt::{self, Display};
use std::fs::OpenOptions;
use std::io::Write;
use std::net::SocketAddr;
use std::str::FromStr;
use std::sync::Arc;
use std::time::{Duration, Instant};
use mio::net::UdpSocket;
use mio::{Events, Poll, PollOpt, Ready, Token};
use mio_extras::timer::{Builder, Timeout, Timer};
use neqo_common::{hex, qdebug, qinfo, qwarn, Datagram, Header};
use neqo_crypto::{
    constants::{TLS_AES_128_GCM_SHA256, TLS_AES_256_GCM_SHA384, TLS_CHACHA20_POLY1305_SHA256},
    generate_ech_keys, init_db, random, AntiReplay, Cipher,
};
use neqo_http3::{
    Error, Http3OrWebTransportStream, Http3Parameters, Http3Server, Http3ServerEvent, StreamId,
};
use neqo_transport::{
    server::ValidateAddress, tparams::PreferredAddress, CongestionControlAlgorithm,
    ConnectionParameters, Output, RandomConnectionIdGenerator, StreamType, Version,
};
use std::cell::RefCell;
use std::cmp::min;
use std::collections::{HashMap, HashSet};
use std::convert::TryFrom;
use std::fmt::{self, Display};
use std::fs::OpenOptions;
use std::io::Write;
use std::net::SocketAddr;
use std::str::FromStr;
use std::sync::Arc;
use std::time::{Duration, Instant};
use mio::net::UdpSocket;
use mio::{Events, Poll, PollOpt, Ready, Token};
use mio_extras::timer::{Builder, Timeout, Timer};
use structopt::StructOpt;
</imports>
<Rust>
#[test]
fn test_send_arbitrary_data() {
    let args = Args::from_iter_safe(&["test"]).unwrap();
    let anti_replay = AntiReplay::new(Instant::now(), Duration::from_secs(10)).unwrap();
    let cid_mgr = Rc::new(RefCell::new(RandomConnectionIdGenerator::new(5)));
    let mut server = SimpleServer::new(&args, anti_replay, cid_mgr);

    let dgram = Datagram::new(
        SocketAddr::from_str("127.0.0.1:4433").unwrap(),
        SocketAddr::from_str("127.0.0.1:4434").unwrap(),
        vec![0; 1200],
    );

    server.process(Some(dgram), Instant::now());

    let mut events = Vec::new();
    while let Some(event) = server.server.next_event() {
        events.push(event);
    }

    let mut data_written = false;
    for event in events {
        if let Http3ServerEvent::DataWritable { .. } = event {
            data_written = true;
            break;
        }
    }

    assert!(data_written, "Server did not write data as expected");
}
</Rust>