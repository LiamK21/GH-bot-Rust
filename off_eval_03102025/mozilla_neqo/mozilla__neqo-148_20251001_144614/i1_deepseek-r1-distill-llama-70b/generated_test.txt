#[test]
fn test_aead_length_overflow() {
    let version = 0;
    let cipher = 0;
    let secret = [0; 32];
    let prefix = "test";
    let p = prefix.as_bytes();

    // Create a large length that overflows u32
    let large_len = usize::try_from(u32::MAX).unwrap() + 1;
    let mut big_vec = Vec::with_capacity(large_len);
    unsafe { big_vec.set_len(large_len); }

    let result = Aead::new(version, cipher, secret, big_vec);
    assert!(result.is_err());
}