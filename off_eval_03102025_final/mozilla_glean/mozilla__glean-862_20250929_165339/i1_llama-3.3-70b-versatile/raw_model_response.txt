<Filename> glean-core/src/upload/mod.rs </Filename>
<imports>
use std::thread;
use std::time::Duration;
use tempfile::tempdir;
use crate::PingUploadManager;
use crate::PingUploadTask;
use crate::HttpStatus;
</imports>
<Rust>
#[test]
fn test_concurrently_submitted_pings_are_uploaded() {
  // Create a new upload_manager
  let dir = tempdir().unwrap();
  let upload_manager = PingUploadManager::new(dir.path());

  // Wait for processing of pending pings directory to finish.
  while upload_manager.get_upload_task() == PingUploadTask::Wait {
    thread::sleep(Duration::from_millis(10));
  }

  let doc1 = "684fa150-8dff-11ea-8faf-cb1ff3b11119";
  let path1 = format!("/submit/app_id/test-ping/1/{}", doc1);

  let doc2 = "74f14e9a-8dff-11ea-b45a-6f936923f639";
  let path2 = format!("/submit/app_id/test-ping/1/{}", doc2);

  // Enqueue a ping
  upload_manager.enqueue_ping(doc1, &path1, serde_json::json!({}));

  // Try and get the first request.
  let req = match upload_manager.get_upload_task() {
    PingUploadTask::Upload(req) => req,
    _ => panic!("Expected upload manager to return the next request!"),
  };
  assert_eq!(doc1, req.document_id);

  // Schedule the next one while the first one is "in progress"
  upload_manager.enqueue_ping(doc2, &path2, serde_json::json!({}));

  // Mark as processed
  upload_manager.process_ping_upload_response(&req.document_id, HttpStatus(200));

  // Get the second request.
  let req = match upload_manager.get_upload_task() {
    PingUploadTask::Upload(req) => req,
    _ => panic!("Expected upload manager to return the next request!"),
  };
  assert_eq!(doc2, req.document_id);

  // Mark as processed
  upload_manager.process_ping_upload_response(&req.document_id, HttpStatus(200));

  // ... and then we're done.
  match upload_manager.get_upload_task() {
    PingUploadTask::Done => {}
    _ => panic!("Expected upload manager to return the next request!"),
  }
}
</Rust>