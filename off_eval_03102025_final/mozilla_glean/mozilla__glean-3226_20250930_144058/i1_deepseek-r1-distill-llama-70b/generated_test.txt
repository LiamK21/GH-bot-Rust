#[test]
fn test_pings_submitted_when_main_ping_disabled() {
    let _lock = lock_test();

    // Define a fake uploader that reports back the submission headers
    let (s, r) = bounded::<String>(3);

    #[derive(Debug)]
    struct FakeUploader {
        sender: Sender<String>,
    }
    impl net::PingUploader for FakeUploader {
        fn upload(&self, upload_request: net::CapablePingUploadRequest) -> net::UploadResult {
            let upload_request = upload_request.capable(|_| true).unwrap();
            self.sender.send(upload_request.url).unwrap();
            net::UploadResult::http_status(200)
        }
    }

    // Create a custom configuration to use a fake uploader.
    let dir = tempdir().unwrap();
    let tmpname = dir.path().to_path_buf();

    let ping_schedule = HashMap::from([("baseline".to_string(), vec!["ride-along".to_string()])]);

    let cfg = ConfigurationBuilder::new(false, tmpname, GLOBAL_APPLICATION_ID)
        .with_server_endpoint("invalid-test-host")
        .with_uploader(FakeUploader { sender: s })
        .with_ping_schedule(ping_schedule)
        .build();

    let _t = new_glean(Some(cfg), true);

    let baseline_ping = PingType::new(
        "baseline",
        true,
        true,
        true,
        true,
        true,
        vec![],
        vec![],
        false,
        vec![],
    );
    baseline_ping.set_enabled(false);

    let ride_along_ping = PingType::new(
        "ride-along",
        true,
        true,
        true,
        true,
        true,
        vec![],
        vec![],
        false,
        vec![],
    );
    ride_along_ping.set_enabled(true);

    // Simulate becoming active.
    handle_client_active();

    // We expect a ride-along ping to ride along.
    let url = r.recv_timeout(Duration::from_millis(100)).unwrap();
    assert!(url.contains("ride-along"));
}