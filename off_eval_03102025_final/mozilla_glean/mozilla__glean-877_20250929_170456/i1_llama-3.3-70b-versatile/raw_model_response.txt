<Filename> glean-core/ffi/src/upload.rs </Filename>
<imports> 
use glean_core::upload::PingUploadTask;
use ffi_support::ByteBuffer;
use std::ffi::CString;
use serde_json::json;
</imports>
<Rust>
#[test]
fn test_gzip_ping_upload_task_conversion() {
  let document_id = "test_document_id";
  let path = "test_path";
  let body = json!({"key": "value"});
  let headers = json!({"header_key": "header_value"});
  let ping_upload_task = PingUploadTask::Upload(glean_core::upload::UploadRequest {
    document_id: document_id.to_string(),
    path: path.to_string(),
    body,
    headers,
  });
  let ffi_ping_upload_task: FfiPingUploadTask = ping_upload_task.into();
  match ffi_ping_upload_task {
    FfiPingUploadTask::Upload { document_id: document_id_ptr, path: path_ptr, body: body_bytes, headers: headers_ptr } => {
      let document_id_str = unsafe { CString::from_raw(document_id_ptr) }.into_string().unwrap();
      let path_str = unsafe { CString::from_raw(path_ptr) }.into_string().unwrap();
      let headers_str = unsafe { CString::from_raw(headers_ptr) }.into_string().unwrap();
      assert_eq!(document_id_str, document_id);
      assert_eq!(path_str, path);
      assert_eq!(body_bytes.len(), serde_json::to_string(&body).unwrap().len());
      assert_eq!(headers_str, serde_json::to_string(&json!({"header_key": "header_value"})).unwrap());
    },
    _ => assert!(false, "Expected FfiPingUploadTask::Upload"),
  }
}
</Rust>