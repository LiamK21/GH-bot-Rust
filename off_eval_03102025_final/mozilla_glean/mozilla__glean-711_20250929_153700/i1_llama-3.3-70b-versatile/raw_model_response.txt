<Filename> glean-core/src/upload/mod.rs </Filename>
<imports>
use super::PingDirectoryManager;
use super::PingRequest;
use std::sync::Arc;
use std::sync::RwLock;
use std::thread;
use std::time::Duration;
use uuid::Uuid;
</imports>

<Rust>
#[test]
fn test_process_ping_upload_response_re_enqueues_on_server_error() {
  let directory_manager = PingDirectoryManager::new("/tmp");
  let queue = Arc::new(RwLock::new(vec![]));
  let upload_manager = super::PingUploadManager { queue: queue.clone(), directory_manager, processed_pending_pings: std::sync::atomic::AtomicBool::new(false) };

  // Submit a ping
  let ping_type = super::PingType::new("test", true, true, vec![]);
  let uuid = Uuid::new_v4().to_string();
  let request = PingRequest::new(&uuid, "https://example.com", serde_json::json!({}));
  queue.write().unwrap().push(request.clone());

  // Simulate the processing of a server error
  upload_manager.process_ping_upload_response(&uuid, 500);

  // Verify this ping was indeed re-enqueued
  let mut upload_task = upload_manager.get_upload_task();
  while upload_task == super::PingUploadTask::Wait {
    thread::sleep(Duration::from_millis(10));
    upload_task = upload_manager.get_upload_task();
  }
  match upload_task {
    super::PingUploadTask::Upload(request) => {
      assert_eq!(uuid, request.uuid);
    }
    _ => panic!("Expected upload manager to return the next request!"),
  }
}
</Rust>