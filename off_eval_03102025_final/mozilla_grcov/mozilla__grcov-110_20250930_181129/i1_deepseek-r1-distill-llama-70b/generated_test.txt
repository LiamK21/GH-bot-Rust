#[test]
fn test_llvm_gcno_buffers() {
    let (sender, receiver) = channel();
    let queue = Arc::new(Mutex::new(SyncQueue::new()));

    // Create a temporary directory to extract files
    let tmp_dir = PathBuf::from("target/test_llvm_gcno_buffers");
    if tmp_dir.exists() {
        std::fs::remove_dir_all(&tmp_dir).unwrap();
    }
    tmp_dir.create_dir_all().unwrap();

    // Create test ZIP files with gcno and gcda contents
    let gcno_content = b"gcno_content";
    let gcda_content = b"gcda_content";

    // Create ZIP files
    let zip_path = tmp_dir.join("test.zip");
    {
        let mut zip = zip::ZipWriter::new(File::create(&zip_path).unwrap());
        // Add gcno file
        let mut options = zip::write::FileOptions::default();
        options.compression_method = zip::CompressionMethod::Stored;
        let mut gcno = zip.start_file("gcno_file.gcno", options).unwrap();
        gcno.write_all(gcno_content).unwrap();
        // Add gcda file
        let mut gcda = zip.start_file("gcda_file.gcda", options).unwrap();
        gcda.write_all(gcda_content).unwrap();
    }

    // Call producer with LLVM option enabled
    producer(&tmp_dir, &[zip_path.to_str().unwrap().to_string()], &queue, false, true);

    // Verify that the buffers are correctly passed
    let mut received_item = queue.lock().unwrap().pop().unwrap();
    while let Some(item) = received_item {
        match item.item {
            ItemType::Buffers(ref buffers) => {
                assert_eq!(buffers.gcno_buf, gcno_content.to_vec());
                assert_eq!(buffers.gcda_buf, gcda_content.to_vec());
                break;
            }
            _ => panic!("Expected ItemType::Buffers, got something else"),
        }
    }
}