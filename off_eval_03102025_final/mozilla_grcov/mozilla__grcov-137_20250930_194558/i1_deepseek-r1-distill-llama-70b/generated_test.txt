#[test]
fn test_llvm_gcno_identification() {
    let tmp_dir = Path::new("target").join("test_llvm_gcno");
    let _ = File::create(&tmp_dir).unwrap();

    // Create non-LLVM GCNO file
    let non_llvm_path = tmp_dir.join("non_llvm.gcno");
    let mut file = File::create(&non_llvm_path).unwrap();
    file.write_all(b"non_llvm_gcno_content").unwrap();

    // Create LLVM-style GCNO file with magic bytes
    let llvm_path = tmp_dir.join("llvm.gcno");
    let mut file = File::create(&llvm_path).unwrap();
    file.write_all(b"ongc*204").unwrap(); // LLVM magic bytes

    let mut queue = WorkQueue::new();
    let paths = vec![non_llvm_path.to_str().unwrap().to_string(), 
                    llvm_path.to_str().unwrap().to_string()];

    producer(&tmp_dir, &paths, &mut queue, false, false).unwrap();

    // Check if LLVM file was correctly identified
    let expected = vec![
        ItemFormat::GCNO as u32,
        // ... (rest of expected queue items)
    ];

    assert_eq!(queue.items, expected);
}