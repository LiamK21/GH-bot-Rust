#[test]
fn test_rewrite_paths_filtering() {
    let mut result_map: CovResultMap = HashMap::new();

    // Add a covered result
    let mut covered_functions = HashMap::new();
    covered_functions.insert("covered_func".to_string(), Function {
        start: 1,
        executed: true,
    });
    let covered_result = CovResult {
        lines: [(1, 1)].iter().cloned().collect(),
        branches: BTreeMap::new(),
        functions: covered_functions,
    };
    result_map.insert("covered.cpp".to_string(), covered_result);

    // Add an uncovered result
    let mut uncovered_functions = HashMap::new();
    uncovered_functions.insert("uncovered_func".to_string(), Function {
        start: 1,
        executed: false,
    });
    let uncovered_result = CovResult {
        lines: [(1, 0)].iter().cloned().collect(),
        branches: BTreeMap::new(),
        functions: uncovered_functions,
    };
    result_map.insert("uncovered.cpp".to_string(), uncovered_result);

    // Test with filter_option Some(true) - should only return covered
    let results = rewrite_paths(
        result_map.clone(),
        None,
        "",
        "",
        false,
        false,
        Vec::new(),
        Some(true),
    );
    let mut count = 0;
    for (abs_path, rel_path, result) in results {
        count += 1;
        assert_eq!(abs_path, PathBuf::from("covered.cpp"));
        assert_eq!(rel_path, PathBuf::from("covered.cpp"));
        assert!(is_covered(&result));
    }
    assert_eq!(count, 1);

    // Test with filter_option Some(false) - should only return uncovered
    let results = rewrite_paths(
        result_map,
        None,
        "",
        "",
        false,
        false,
        Vec::new(),
        Some(false),
    );
    let mut count = 0;
    for (abs_path, rel_path, result) in results {
        count += 1;
        assert_eq!(abs_path, PathBuf::from("uncovered.cpp"));
        assert_eq!(rel_path, PathBuf::from("uncovered.cpp"));
        assert!(!is_covered(&result));
    }
    assert_eq!(count, 1);
}