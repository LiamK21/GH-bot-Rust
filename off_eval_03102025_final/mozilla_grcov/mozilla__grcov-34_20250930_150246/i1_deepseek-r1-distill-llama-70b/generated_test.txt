#[test]
fn test_coveralls_output_with_function_info() {
    let mut results = Vec::new();

    // Mock a function
    let mock_function = Function {
        start: 5,
        executed: true,
    };

    let mock_result = CovResult {
        functions: vec![("mock_function".to_string(), mock_function)],
        ..Default::default()
    };

    let mock_path = PathBuf::from("mock_path.rs");
    let rel_path = "mock_path.rs".to_string();

    results.push((mock_path, rel_path, mock_result));

    let mut cursor = Cursor::new(Vec::new());

    // Test without function info
    output_coveralls(
        results.iter().cloned(),
        "token",
        "service",
        "service_number",
        "service_job",
        "commit",
        false,
    );

    let output = cursor.into_inner();
    let json: Value = serde_json::from_slice(&output).unwrap();
    assert!(!json.as_array().unwrap()[0].has_key("functions"));

    // Reset cursor
    cursor = Cursor::new(Vec::new());

    // Test with function info
    output_coveralls(
        results.iter().cloned(),
        "token",
        "service",
        "service_number",
        "service_job",
        "commit",
        true,
    );

    let output_with_functions = cursor.into_inner();
    let json_with_functions: Value = serde_json::from_slice(&output_with_functions).unwrap();
    let source_file = json_with_functions.as_array().unwrap()[0];
    assert!(source_file.has_key("functions"));

    let functions = source_file["functions"].as_array().unwrap();
    assert_eq!(functions[0]["name"], "mock_function");
    assert_eq!(functions[0]["start"], 5);
    assert_eq!(functions[0]["exec"], true);
}