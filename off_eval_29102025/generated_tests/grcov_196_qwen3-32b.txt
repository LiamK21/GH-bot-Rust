#[test]
fn test_rewrite_paths_multiple_files_same_name() {
    // Create temporary test directory
    let temp_dir = env::temp_dir().join("grcov_path_rewrite_test");
    fs::create_dir_all(&temp_dir).unwrap();

    // Create two files with same name in different directories
    let base_dir = temp_dir.join("src");
    let deep_path = base_dir.join("dir1").join("dir2").join("file.java");
    let shallow_path = base_dir.join("dir1").join("file.java");
    fs::create_dir_all(deep_path.parent().unwrap()).unwrap();
    fs::create_dir_all(shallow_path.parent().unwrap()).unwrap();
    fs::File::create(&deep_path).unwrap();
    fs::File::create(&shallow_path).unwrap();

    // Test case using partial path that should resolve to deeper path
    let mut result_map: CovResultMap = HashMap::new();
    result_map.insert("dir2/file.java".to_string(), empty_result!());

    // Test with source directory pointing to base_dir
    let results = rewrite_paths(
        result_map,
        None,
        Some(base_dir),
        None,
        true,
        Vec::new(),
        None,
    );

    // Verify result resolves to deeper file path
    let mut count = 0;
    for (abs_path, rel_path, result) in results {
        count += 1;
        assert!(abs_path.is_absolute());
        assert!(abs_path.ends_with("dir1/dir2/file.java"));
        assert_eq!(rel_path, PathBuf::from("dir1/dir2/file.java"));
        assert_eq!(result, empty_result!());
    }
    assert_eq!(count, 1);

    // Cleanup
    fs::remove_dir_all(&temp_dir).unwrap();
}