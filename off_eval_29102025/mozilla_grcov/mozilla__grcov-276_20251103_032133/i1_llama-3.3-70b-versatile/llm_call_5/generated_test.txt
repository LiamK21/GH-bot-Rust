#[test]
fn test_cli_options() {
  let args_before_patch = vec!["grcov", "path1", "path2", "-t", "lcov"];
  let result_before_patch = std::process::Command::new("grcov")
    .args(&args_before_patch)
    .output();
  let expected_stderr = "Usage: grcov DIRECTORY_OR_ZIP_FILE[...] [-o OUTPUT FILENAME] [-t OUTPUT_TYPE] [-s SOURCE_ROOT] [-p PREFIX_PATH] [--token COVERALLS_REPO_TOKEN] [--commit-sha COVERALLS_COMMIT_SHA] [--ignore-not-existing] [--ignore-dir DIRECTORY] [--llvm] [--path-mapping PATH_MAPPING_FILE] [--branch] [--filter]";
  assert!(result_before_patch.stderr.len() > 0);
  let stderr_string = String::from_utf8_lossy(&result_before_patch.stderr);
  assert!(stderr_string.contains(expected_stderr));

  let args_after_patch = vec!["grcov", "path1", "path2", "-t", "lcov"];
  let result_after_patch = App::new("grcov")
    .arg(Arg::with_name("paths")
         .help("Sets the input paths to use")
         .required(true)
         .multiple(true)
         .takes_value(true))
    .arg(Arg::with_name("output_type")
         .help("Sets a custom output type")
         .long_help(
           "Sets a custom output type:
           - *lcov* for the lcov INFO format;
           - *coveralls* for the Coveralls specific format;
           - *coveralls+* for the Coveralls specific format with function information;
           - *ade* for the ActiveData-ETL specific format;
           - *files* to only return a list of files.
           ")
         .short("t")
         .long("output-type")
         .value_name("OUTPUT TYPE")
         .default_value("lcov")
         .possible_values(&["ade", "lcov", "coveralls", "coveralls+", "files"])
         .takes_value(true))
    .get_matches_from(args_after_patch);
  assert!(result_after_patch.is_ok());
}