#[test]
fn test_zip_producer_ignore_orphan_gcno() {
    // Create temporary directory for test data
    let tmp_dir = tempfile::tempdir().unwrap();
    let tmp_path = tmp_dir.path().to_path_buf();

    // Create a GCNO file without matching GCDA
    let gcno_content = b"gcno_data";
    let gcno_path = tmp_path.join("test.gcno");
    let mut gcno_file = fs::File::create(&gcno_path).unwrap();
    gcno_file.write_all(gcno_content).unwrap();

    // Create a ZIP with only the GCNO file
    let zip_path = tmp_path.join("files.zip");
    let mut zip = zip::ZipWriter::new(fs::File::create(&zip_path).unwrap());

    let options = FileOptions::default()
        .compression_method(zip::CompressionMethod::Deflated);

    zip.start_file("test.gcno", options).unwrap();
    zip.write_all(gcno_content).unwrap();
    zip.finish().unwrap();

    // Create queue
    let queue: Arc<WorkQueue> = Arc::new(MsQueue::new());

    // Run producer with ignore_orphan_gcno = true
    let paths = vec![String::from("files.zip")];
    let tmp_path = &zip_path.parent().unwrap().to_path_buf();
    let ignore_orphan_gcno = true;

    let ret = zip_producer(tmp_path, &vec![&zip_path.to_string_lossy().to_string()], &queue, ignore_orphan_gcno);

    // After fix should have no entries in queue
    let expected = vec![];

    check_produced(tmp_path, &queue, expected);
    assert!(ret.is_none());

    tmp_dir.close().unwrap();
}