<Filename>src/lib.rs</Filename>
<imports>
use std::path::PathBuf;
use std::fs;
use std::io::BufReader;
use super::add_results;
use super::SyncCovResultMap;
use super::CovResult;
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
</imports>
<Rust>
#[test]
fn test_cleanup_relative_paths() {
  let mut results = Vec::new();
  let result_map: SyncCovResultMap = Arc::new(Mutex::new(HashMap::new()));
  let source_dir = PathBuf::from("./test/relative_path");
  let file_path = source_dir.join("relative_path.info");
  let file = fs::File::open(file_path).expect("Failed to open file");
  let file = BufReader::new(file);
  let results = super::parse_lcov(file, false).unwrap();
  let expected_path = fs::canonicalize(source_dir.join("foo/bar/oof.cpp")).unwrap().to_str().unwrap().to_string();
  let mut expected_map: HashMap<String, CovResult> = HashMap::new();
  expected_map.insert(expected_path, CovResult { lines: Vec::new(), functions: HashMap::new(), summary: None });
  let expected_map: SyncCovResultMap = Arc::new(Mutex::new(expected_map));
  add_results(results, &result_map, &Some(source_dir));
  let actual_map = Arc::try_unwrap(result_map).unwrap().into_inner().unwrap();
  assert_eq!(actual_map.len(), 1);
  assert!(actual_map.contains_key(&expected_path));
}
</Rust>