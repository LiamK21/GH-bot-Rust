#[test]
fn test_producer_multiple_profraws_collected() {
    let tmp_dir = tempdir().unwrap();
    let (sender, receiver) = mpsc::channel();

    // Create mock archives with get_name() returning predictable names
    #[derive(Clone)]
    struct MockArchive {
        name: String,
    }
    impl MockArchive {
        fn get_name(&self) -> &str {
            &self.name
        }
    }

    let mut profraws = FxHashMap::default();
    profraws.insert(
        "profraw1".to_string(),
        vec![&MockArchive { name: "profraw1".to_string() }],
    );
    profraws.insert(
        "profraw2".to_string(),
        vec![&MockArchive { name: "profraw2".to_string() }],
    );

    profraw_producer(&tmp_dir.path(), &profraws, &sender);

    let work_item = receiver.recv().unwrap().unwrap();
    assert_eq!(work_item.format, ItemFormat::PROFRAW);

    if let ItemType::Paths(paths) = work_item.item {
        assert_eq!(paths.len(), 2);
        assert!(paths[0].ends_with("profraw1.profraw"));
        assert!(paths[1].ends_with("profraw2.profraw"));
    } else {
        panic!("Expected ItemType::Paths variant");
    }
}