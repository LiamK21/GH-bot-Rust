#[test]
fn test_producer_multiple_profraws_collected() {
    let tmp_dir = tempdir().unwrap();
    let profraw_sender = mpsc::channel().0;

    // Create mock archives with get_name() returning predictable names
    #[derive(Clone)]
    struct MockArchive {
        name: String,
    }
    impl MockArchive {
        fn get_name(&self) -> &str {
            &self.name
        }
    }

    let mut profraws = FxHashMap::default();
    profraws.insert(
        "profraw1".to_string(),
        vec![&MockArchive { name: "profraw1" }],
    );
    profraws.insert(
        "profraw2".to_string(),
        vec![&MockArchive { name: "profraw2" }],
    );

    // Patch: Use MockArchive and set impl methods to simulate real behavior
    use crate::profraw_producer;

    profraw_producer(&tmp_dir.path(), &profraws, &profraw_sender);

    let (format, item) = profraw_sender.recv().unwrap().unwrap();
    assert_eq!(format, ItemFormat::PROFRAW);

    if let ItemType::Paths(paths) = item {
        assert_eq!(paths.len(), 2);
        assert!(paths[0].ends_with("profraw1"));
        assert!(paths[1].ends_with("profraw2"));
    } else {
        panic!("Expected ItemType::Paths variant");
    }
}