// Ensure this test runs only on Unix-like systems
#[cfg(unix)]
#[test]
fn test_llvm_profiles_to_lcov_passes_num_threads() {
    let tmp_dir = env::temp_dir();
    let working_dir = tmp_dir.join("grcov_thread_test");
    fs::create_dir_all(&working_dir).unwrap();

    // Create dummy profraw file
    let profraw_path = working_dir.join("dummy.profraw");
    fs::File::create(&profraw_path).unwrap();

    // Create dummy binary file
    let binary_path = working_dir.join("dummy_binary");
    fs::File::create(&binary_path).unwrap();

    // Create mock llvm-profdata script
    let script_path = working_dir.join("llvm-profdata");
    let mut script = fs::File::create(&script_path).unwrap();
    writeln!(script, "#!/bin/sh").unwrap();
    writeln!(
        script,
        "echo $@ > {}",
        working_dir.join("args.txt").to_string_lossy()
    ).unwrap();
    #[cfg(unix)]
    {
        let mut perms = fs::metadata(&script_path).unwrap().permissions();
        perms.set_mode(0o755);
        fs::set_permissions(&script_path, perms).unwrap();
    }

    // Set PATH to prioritize our mock script
    let old_path = env::var("PATH").unwrap();
    let new_path = format!("{}:{}", working_dir.to_string_lossy(), old_path);
    env::set_var("PATH", &new_path);

    // Call function with num_threads=4
    let profile_paths = vec![profraw_path];
    let result = super::llvm_profiles_to_lcov(
        &profile_paths,
        &binary_path,
        &working_dir,
        4,
    );

    // Restore PATH
    env::set_var("PATH", old_path);

    // Assertions
    assert!(result.is_ok(), "Function should not return error");

    // Check arguments captured by mock script
    {
        let args_path = working_dir.join("args.txt");
        let args = fs::read_to_string(&args_path).unwrap();
        assert!(
            args.contains("--num-threads=4"),
            "Expected --num-threads=4 in arguments, got: {}",
            args
        );
    }
}