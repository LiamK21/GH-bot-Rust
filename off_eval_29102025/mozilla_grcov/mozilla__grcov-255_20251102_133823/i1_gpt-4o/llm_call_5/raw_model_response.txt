<Filename>src/output.rs</Filename>
<imports>
use super::output_lcov;
use std::fs::File;
use std::io::{BufRead, BufReader};
use tempfile::tempdir;
use std::path::PathBuf;
use std::collections::BTreeMap;
use defs::{CovResultIter, CovResult};
use std::boxed::Box;
</imports>
<Rust>
#[test]
fn test_output_lcov_to_file() {
    let temp_dir = tempdir().unwrap();
    let file_path = temp_dir.path().join("output.lcov");
    let output_file = Some(file_path.to_str().unwrap().to_string());

    let mut coverage_data = BTreeMap::new();
    coverage_data.insert(1, 1);
    let results: CovResultIter = Box::new(vec![
        (PathBuf::from("source1.rs"), PathBuf::from("source1.rs"), CovResult { lines: coverage_data.clone(), branches: BTreeMap::new(), functions: BTreeMap::new() }),
        (PathBuf::from("source2.rs"), PathBuf::from("source2.rs"), CovResult { lines: coverage_data, branches: BTreeMap::new(), functions: BTreeMap::new() }),
    ].into_iter());

    output_lcov(results, output_file.as_ref());

    let file = File::open(file_path).unwrap();
    let reader = BufReader::new(file);
    let mut lines = reader.lines();

    assert_eq!(lines.next().unwrap().unwrap(), "TN:");
    assert_eq!(lines.next().unwrap().unwrap(), "SF:source1.rs");
    assert_eq!(lines.next().unwrap().unwrap(), "DA:1,1");
    assert_eq!(lines.next().unwrap().unwrap(), "end_of_record");
    assert_eq!(lines.next().unwrap().unwrap(), "SF:source2.rs");
    assert_eq!(lines.next().unwrap().unwrap(), "DA:1,1");
    assert_eq!(lines.next().unwrap().unwrap(), "end_of_record");
    assert!(lines.next().is_none());
}
</Rust>