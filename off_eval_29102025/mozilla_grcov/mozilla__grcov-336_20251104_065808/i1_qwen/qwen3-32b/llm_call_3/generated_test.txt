#[test]
fn test_parallel_flag_in_json_output() {
    let tmp_dir = tempfile::tempdir().unwrap();
    let output_path = tmp_dir.path().join("test.json");
    let output_path_str = output_path.to_str().unwrap();

    // Dummy parameters
    let dummy_repo_token = "";
    let dummy_service_name = "";
    let dummy_service_number = "";
    let dummy_service_job_number = "";
    let dummy_commit_sha = "";
    let dummy_vcs_branch = "";

    // Create an empty iterator with correct type
    let dummy_results_true: Box<dyn Iterator<Item = (std::path::PathBuf, std::path::PathBuf, CovResult)>> = 
        Box::new(std::iter::empty::<(std::path::PathBuf, std::path::PathBuf, CovResult)>() as _);

    // Test with parallel: true
    super::output_coveralls(
        dummy_results_true,
        dummy_repo_token,
        dummy_service_name,
        dummy_service_number,
        dummy_service_job_number,
        dummy_commit_sha,
        false,
        Some(output_path_str),
        dummy_vcs_branch,
        true,
    );

    let json_content = fs::read_to_string(output_path_str).unwrap();
    let json_value: Value = serde_json::from_str(&json_content).unwrap();
    assert_eq!(json_value["parallel"].as_bool().unwrap(), true);

    // Create new empty iterator for parallel: false
    let dummy_results_false: Box<dyn Iterator<Item = (std::path::PathBuf, std::path::PathBuf, CovResult)>> =
        Box::new(std::iter::empty::<(std::path::PathBuf, std::path::PathBuf, CovResult)>() as _);

    super::output_coveralls(
        dummy_results_false,
        dummy_repo_token,
        dummy_service_name,
        dummy_service_number,
        dummy_service_job_number,
        dummy_commit_sha,
        false,
        Some(output_path_str),
        dummy_vcs_branch,
        false,
    );

    let json_content = fs::read_to_string(output_path_str).unwrap();
    let json_value: Value = serde_json::from_str(&json_content).unwrap();
    assert_eq!(json_value["parallel"].as_bool().unwrap(), false);
}