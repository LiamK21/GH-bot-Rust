<Filename>src/main.rs</Filename>
<imports>
use super::output_coveralls;
use std::path::PathBuf;
use serde_json::json;
use serde_json::Value;
use std::io::Write;
use std::fs::File;
use crate::CovResult;
use crate::FunctionCoverage;
</imports>
<Rust>
#[test]
fn test_output_coveralls_with_function_info() {
    let results = vec![
        (
            PathBuf::from("src/lib.rs"),
            "src/lib.rs".to_string(),
            CovResult {
                coverage: vec![Some(1), Some(0), None],
                branches: vec![(1, 2, true), (3, 4, false)],
                functions: vec![
                    ("foo".to_string(), FunctionCoverage { start: 1, executed: true }),
                    ("bar".to_string(), FunctionCoverage { start: 5, executed: false }),
                ],
            },
        ),
    ];
    let repo_token = "dummy_token";
    let service_name = "dummy_service";
    let service_number = "123";
    let service_job_number = "456";
    let commit_sha = "abcdef";

    let mut output = Vec::new();
    {
        let mut file = File::create("output.json").unwrap();
        output_coveralls(
            Box::new(results.into_iter()),
            repo_token,
            service_name,
            service_number,
            service_job_number,
            commit_sha,
            true,
        );
        file.write_all(&output).unwrap();
    }

    let expected: Value = json!({
        "name": "src/lib.rs",
        "source_digest": "dummy_digest",
        "coverage": [1, 0, null],
        "branches": [1, 0],
        "functions": [
            {"name": "foo", "start": 1, "exec": true},
            {"name": "bar", "start": 5, "exec": false}
        ]
    });

    let actual: Value = serde_json::from_slice(&output).unwrap();
    assert_eq!(expected, actual);
}
</Rust>