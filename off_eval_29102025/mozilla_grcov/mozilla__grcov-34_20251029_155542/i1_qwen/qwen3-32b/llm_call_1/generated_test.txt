#[test]
fn test_output_coveralls_with_function_info() {
    use std::io::stdout;
    use std::path::PathBuf;
    use std::collections::HashMap;

    // Mock data
    let abs_path = PathBuf::from("/tmp/mock.rs");
    let rel_path = PathBuf::from("mock.rs");

    // Create mock functions
    let mut functions = HashMap::new();
    functions.insert("fn1".to_string(), FunctionInfo { start: 5, executed: true });
    functions.insert("fn2".to_string(), FunctionInfo { start: 10, executed: false });

    // Create mock CovResult
    let cov_result = MockCovResult {
        functions,
        coverage: vec![Some(1), None, Some(3)],
        branches: vec![1, 0],
    };

    // Create mock results iterator
    let results = vec![(abs_path, rel_path, cov_result)].into_iter();

    // Redirect stdout
    let original_stdout = stdout();
    let mut stdout_buffer = vec![];
    {
        let mut writer = io::BufWriter::new(&mut stdout_buffer);
        io::set_output(writer);
        output_coveralls(
            results,
            "test-token",
            "test-service",
            "1",
            "2",
            "abcdef",
            true,
        );
    }

    // Parse and validate JSON
    let output_str = String::from_utf8(stdout_buffer).unwrap();
    let json_value: serde_json::Value = serde_json::from_str(&output_str).unwrap();

    // Check for functions array
    assert!(json_value["source_files"][0].get("functions").is_some());
    let functions_array = json_value["source_files"][0]["functions"].as_array().unwrap();
    assert_eq!(functions_array.len(), 2);

    // Verify first function
    let first_fn = &functions_array[0];
    assert_eq!(first_fn["name"], "fn1");
    assert_eq!(first_fn["start"], 5);
    assert_eq!(first_fn["exec"], true);

    // Verify second function
    let second_fn = &functions_array[1];
    assert_eq!(second_fn["name"], "fn2");
    assert_eq!(second_fn["start"], 10);
    assert_eq!(second_fn["exec"], false);
}

// Mock types
struct FunctionInfo {
    start: usize,
    executed: bool,
}

struct MockCovResult {
    functions: HashMap<String, FunctionInfo>,
    coverage: Vec<Option<usize>>,
    branches: Vec<u8>,
}