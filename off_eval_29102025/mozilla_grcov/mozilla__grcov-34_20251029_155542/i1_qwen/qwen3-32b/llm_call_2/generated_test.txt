#[test]
fn test_output_coveralls_with_function_info() {
    use super::output_coveralls;
    use std::collections::HashMap;
    use std::path::PathBuf;

    // Mock data
    let abs_path = PathBuf::from("/tmp/mock.rs");
    let rel_path = PathBuf::from("mock.rs");

    // Create mock functions
    let mut functions = HashMap::new();
    functions.insert("fn1".to_string(), FunctionInfo { start: 5, executed: true });
    functions.insert("fn2".to_string(), FunctionInfo { start: 10, executed: false });

    // Create mock CovResult
    let cov_result = CovResult {
        functions,
        coverage: vec![Some(1), None, Some(3)],
        branches: vec![1, 0],
    };

    // Create mock results iterator
    let results = vec![(abs_path, rel_path, cov_result)].into_iter();

    // Redirect stdout to capture output
    let original_stdout = std::io::stdout();
    let mut stdout_buffer = Vec::new();
    {
        let writer = std::io::BufWriter::new(&mut stdout_buffer);
        let _guard = original_stdout.lock();
        // Call function directly without outputting to real stdout
        output_coveralls_with_custom_writer(
            results,
            "test-token",
            "test-service",
            "1",
            "2",
            "abcdef",
            true,
            &mut stdout_buffer,
        );
    }

    // Parse and validate JSON
    let output_str = String::from_utf8(stdout_buffer).unwrap();
    let json_value: serde_json::Value = serde_json::from_str(&output_str).unwrap();

    // Check for functions array
    assert!(json_value["source_files"][0].get("functions").is_some());
    let functions_array = json_value["source_files"][0]["functions"].as_array().unwrap();
    assert_eq!(functions_array.len(), 2);

    // Verify first function
    let first_fn = &functions_array[0];
    assert_eq!(first_fn["name"], "fn1");
    assert_eq!(first_fn["start"], 5);
    assert_eq!(first_fn["exec"].as_bool().unwrap(), true);

    // Verify second function
    let second_fn = &functions_array[1];
    assert_eq!(second_fn["name"], "fn2");
    assert_eq!(second_fn["start"], 10);
    assert_eq!(second_fn["exec"].as_bool().unwrap(), false);
}

// Mock types
struct FunctionInfo {
    start: usize,
    executed: bool,
}

struct CovResult {
    functions: HashMap<String, FunctionInfo>,
    coverage: Vec<Option<usize>>,
    branches: Vec<u8>,
}

// Helper to redirect output to a buffer instead of real stdout
fn output_coveralls_with_custom_writer(
    results: impl Iterator<Item = (PathBuf, PathBuf, CovResult)>,
    repo_token: &str,
    service_name: &str,
    service_number: &str,
    service_job_number: &str,
    commit_sha: &str,
    with_function_info: bool,
    writer: &mut impl std::io::Write,
) {
    let mut source_files = Vec::new();

    for (abs_path, rel_path, result) in results {
        let coverage: Vec<_> = result
            .coverage
            .iter()
            .map(|c| match c {
                Some(n) => json!(n),
                None => json!(0),
            })
            .collect();

        let branches = result
            .branches
            .iter()
            .map(|&b| b)
            .collect();

        if with_function_info {
            let mut functions = Vec::new();
            for (name, function) in &result.functions {
                functions.push(json!({
                    "name": name,
                    "start": function.start,
                    "exec": function.executed,
                }));
            }

            source_files.push(json!({
                "name": rel_path.to_string_lossy(),
                "source_digest": "mock-digest",
                "coverage": coverage,
                "branches": branches,
                "functions": functions,
            }));
        }
    }

    let _ = serde_json::to_writer(writer, &json!({
        "repo_token": repo_token,
        "service_name": service_name,
        "service_number": service_number,
        "service_job_number": service_job_number,
        "commit_sha": commit_sha,
        "source_files": source_files,
    }));
}