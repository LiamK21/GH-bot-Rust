#[cfg(unix)]
#[test]
fn test_rewrite_paths_submodule_same_name() {
    let mut result_map: CovResultMap = HashMap::new();
    result_map.insert("memflow/lib.rs".to_string(), empty_result!());
    let results = rewrite_paths(
        result_map,
        None,
        Some(canonicalize_path("memflow").unwrap()),
        None,
        false,
        &mut Vec::new(),
        &Vec::new(),
        None,
        Default::default(),
    );
    let mut count = 0;
    for (abs_path, rel_path, result) in results {
        count += 1;
        assert!(abs_path.is_absolute());
        assert!(abs_path.ends_with("/memflow/memflow/lib.rs"));
        assert_eq!(rel_path, PathBuf::from("memflow/lib.rs"));
        assert_eq!(result, empty_result!());
    }
    assert_eq!(count, 1);
}

#[cfg(windows)]
#[test]
fn test_rewrite_paths_submodule_same_name() {
    let mut result_map: CovResultMap = HashMap::new();
    result_map.insert("memflow\\lib.rs".to_string(), empty_result!());
    let results = rewrite_paths(
        result_map,
        None,
        Some(canonicalize_path("memflow").unwrap()),
        None,
        false,
        &mut Vec::new(),
        &Vec::new(),
        None,
        Default::default(),
    );
    let mut count = 0;
    for (abs_path, rel_path, result) in results {
        count += 1;
        assert!(abs_path.is_absolute());
        assert!(abs_path.ends_with("memflow\\memflow\\lib.rs"));
        assert_eq!(rel_path, PathBuf::from("memflow\\lib.rs"));
        assert_eq!(result, empty_result!());
    }
    assert_eq!(count, 1);
}