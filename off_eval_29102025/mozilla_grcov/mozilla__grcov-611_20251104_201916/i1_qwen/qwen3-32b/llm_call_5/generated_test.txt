#[test]
fn test_overflow_logs_warning() {
    struct TestLogger {
        overflow_logged: Arc<AtomicBool>,
    }

    impl TestLogger {
        fn new() -> Self {
            Self { overflow_logged: Arc::new(AtomicBool::new(false)) }
        }

        fn overflow_logged(&self) -> bool {
            self.overflow_logged.load(Ordering::Relaxed)
        }
    }

    impl Clone for TestLogger {
        fn clone(&self) -> Self {
            Self { overflow_logged: Arc::clone(&self.overflow_logged) }
        }
    }

    impl log::Logger for TestLogger {
        fn enabled(&self, metadata: &log::Metadata) -> bool {
            metadata.level() <= Level::Warn
        }

        fn log(&self, record: &log::Record) {
            if record.level() == Level::Warn && record.args().to_string().contains("Execution count overflow detected.") {
                self.overflow_logged.store(true, Ordering::Relaxed);
            }
        }

        fn flush(&self) {}
    }

    let logger = TestLogger::new();
    let results = vec![("test_file".to_string(), CovResult { execution_count: u32::MAX })];
    let warn_overflow = true;

    log::set_max_level(LevelFilter::Warn);
    log::set_logger(Box::new(logger.clone())).unwrap();

    add_results(results, warn_overflow);

    assert!(logger.overflow_logged(), "Execution count overflow log not found");
}