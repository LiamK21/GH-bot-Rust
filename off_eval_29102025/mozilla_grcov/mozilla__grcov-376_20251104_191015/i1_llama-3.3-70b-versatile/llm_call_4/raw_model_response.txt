<Filename>src/output.rs</Filename>
<imports>
use serde_json::Value;
use std::fs;
use std::path::PathBuf;
use tempfile::tempdir;
use std::collections::BTreeMap;
use std::collections::FxHashMap;
use super::output_coveralls;
use std::collections::HashMap;
</imports>
<Rust>
#[test]
fn test_coveralls_service_job_id_output() {
  let tmp_dir = tempdir().expect("Failed to create temporary directory");
  let file_name = "test_coveralls_service_job_id.json";
  let file_path = tmp_dir.path().join(&file_name);
  let results = vec![(
    PathBuf::from("foo/bar/a.cpp"),
    PathBuf::from("foo/bar/a.cpp"),
    CovResult {
      lines: BTreeMap::new(),
      branches: BTreeMap::new(),
      functions: FxHashMap::new(),
    },
  )];
  let results: CovResultIter = Box::new(results.into_iter());
  let expected_service_job_id: &str = "100500";
  let with_function_info: bool = true;
  let parallel: bool = true;
  output_coveralls(
    results,
    "unused",
    "unused",
    "unused",
    expected_service_job_id,
    "unused",
    "unused",
    with_function_info,
    Some(file_path.to_str().unwrap()),
    "unused",
    parallel,
  );
  let contents = fs::read_to_string(file_path).expect("Failed to read file");
  let json: Value = serde_json::from_str(&contents).expect("Failed to parse json");
  assert_eq!(json["service_job_id"], expected_service_job_id);
}
</Rust>