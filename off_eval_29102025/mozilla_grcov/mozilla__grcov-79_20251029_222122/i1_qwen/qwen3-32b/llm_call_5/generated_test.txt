#[test]
fn test_branch_coverage_lcov_format() {
    let branches = vec![((10, 1), true), ((12, 2), false)];
    let branches_map: HashMap<_, _> = branches.into_iter().collect();
    let result = CoverageResult {
        branches: branches_map,
        functions: HashMap::new(),
        lines: HashMap::new(),
    };
    let results = Box::new(vec![result].into_iter());
    let output = capture_output(|| output_lcov(results));
    assert!(output.contains("BRDA:10,0,1,1"));
    assert!(output.contains("BRDA:12,0,2,-"));
    assert!(output.contains("BRF:2"));
    assert!(output.contains("BRH:1"));
}

fn capture_output<F>(f: F) -> String 
where
    F: FnOnce(),
{
    let original_stdout = std::io::stdout();
    let mut buffer = Vec::new();
    {
        let mut stdout_handle = original_stdout.lock();
        if let Ok(handle) = stdout_handle.write(&mut buffer) {
            f();
        }
    }
    String::from_utf8(buffer).unwrap()
}