#[derive(Debug)]
struct FunctionCoverage {
    executed: bool,
}

#[derive(Debug)]
struct CovResult {
    functions: HashMap<String, FunctionCoverage>,
    branches: BTreeMap<(u32, u32), bool>,
    lines: BTreeMap<u32, u32>,
}

type CovResultIter = Box<dyn Iterator<Item = (PathBuf, PathBuf, CovResult)>>;

#[test]
fn test_output_lcov_with_branch_coverage() {
    let mut results = Vec::new();
    let mut functions = HashMap::new();
    functions.insert("func1".to_string(), FunctionCoverage { executed: true });
    let mut branches = BTreeMap::new();
    branches.insert((10, 0), true);
    branches.insert((10, 1), false);
    let lines = BTreeMap::new();
    results.push((PathBuf::new(), PathBuf::new(), CovResult {
        functions,
        branches,
        lines,
    }));

    let mut buffer = Cursor::new(Vec::new());
    output_lcov(Box::new(results.into_iter()));

    let expected_output = "TN:\nBRDA:10,0,0,1\nBRDA:10,0,1,-\nBRF:2\nBRH:1\n";
    let actual_output = String::from_utf8(buffer.into_inner()).unwrap();

    assert!(actual_output.contains(expected_output));
}