<Filename>src/output.rs</Filename>
<imports>
use super::output_activedata_etl;
use serde_json::json;
use std::collections::HashSet;
use std::iter::FromIterator;
use std::io::BufWriter;
use std::io::Write;
use std::path::PathBuf;
use defs::CovResult;
</imports>
<Rust>
#[test]
fn test_output_activedata_etl_removes_line_key() {
    let results: Vec<(PathBuf, PathBuf, CovResult)> = vec![(
        PathBuf::from("file1.rs"),
        PathBuf::from("file1.rs"),
        (
            HashSet::from_iter(vec![1, 2, 3].into_iter()),
            HashSet::from_iter(vec![4, 5].into_iter()),
            vec![("func1".to_string(), 1, 4)],
        ),
    )];
    let expected = json!({
        "is_file": true,
        "file": {
            "name": "file1.rs",
            "covered": [1, 2, 3],
            "uncovered": [4, 5],
            "total_covered": 3,
            "total_uncovered": 2,
            "percentage_covered": 0.6,
        },
        "method": {
            "covered": [],
            "uncovered": [],
            "total_covered": 0,
            "total_uncovered": 0,
        }
    });

    let mut actual_output = Vec::new();
    {
        let writer = BufWriter::new(&mut actual_output);
        output_activedata_etl(Box::new(results.into_iter()));
    }

    let actual: serde_json::Value = serde_json::from_slice(&actual_output).unwrap();
    assert_eq!(expected, actual);
}
</Rust>