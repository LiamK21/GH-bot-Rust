#[test]
fn test_get_coverage_env_vars_adds_expected_flags() {
    let target_dir = tempdir().expect("couldn't create temp dir");
    let target_dir_path = target_dir.path().to_path_buf();
    let target_dir_os = target_dir_path.into_os_string();

    let project_dir = tempdir().expect("couldn't create temp dir");
    let project_dir_path = project_dir.path().to_path_buf();

    // Create a minimal Cargo.toml and Cargo.lock
    fs::write(
        project_dir_path.join("Cargo.toml"),
        r#"[package]
name = "test-project"
version = "0.1.0"
edition = "2021"
"#,
    ).expect("Failed to create Cargo.toml");

    fs::write(
        project_dir_path.join("Cargo.lock"),
        r#""#
    ).expect("Failed to create Cargo.lock");

    let mut env = HashMap::new();
    env.insert(OsString::from("CARGO_TARGET_DIR"), target_dir_os);

    let context = Context {
        env,
        pwd: project_dir_path,
        args: vec![].into_iter().collect(),
    };

    let profile = "debug";

    let result = get_coverage_env_vars(&context.env, profile);

    // Check RUSTFLAGS contains coverage instrumentation flags
    let rustflags = &result.iter()
        .find(|(k, _)| k == &OsString::from("RUSTFLAGS"))
        .unwrap()
        .1;
    assert!(rustflags.to_string_lossy().contains("-Zprofile"));
    assert!(rustflags.to_string_lossy().contains("-Ccodegen-units=1"));

    // Check LLVM_PROFILE_FILE points to expected debug output directory
    let llvm_profile = result.iter()
        .find(|(k, _)| k == &OsString::from("LLVM_PROFILE_FILE"))
        .unwrap()
        .1;
    let expected_profile_dir = context
        .env
        .get(&OsString::from("CARGO_TARGET_DIR"))
        .expect("CARGO_TARGET_DIR missing")
        .to_string_lossy()
        .to_string()
        + "/coverage/debug";
    assert!(llvm_profile.to_string_lossy().contains(&expected_profile_dir));
}