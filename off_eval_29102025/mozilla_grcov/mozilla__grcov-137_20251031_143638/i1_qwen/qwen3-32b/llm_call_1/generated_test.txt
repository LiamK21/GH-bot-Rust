fn check_produced(tmp_path: &Path, queue: &WorkQueue, expected: &Vec<(&str, bool, &str, bool)>) {
    for elem in expected {
        let (format_str, is_path, path_str, expected_found) = elem;
        let format = match format_str {
            "ItemFormat::GCNO" => ItemFormat::GCNO,
            _ => panic!("Unknown format"),
        };
        let items = queue.get(&format);
        assert!(items.len() >= 1, "Missing items for format {}", format_str);
        for item in items {
            let item_type = item.get_item_type();
            match item_type {
                ItemType::Path(p) => {
                    assert!(is_path, "Expected ItemType::Path");
                    assert!(p.ends_with(path_str), "Path ends with {}", path_str);
                },
                ItemType::Buffers(b) => {
                    assert!(!*is_path, "Expected ItemType::Buffers");
                    assert!(b.stem.ends_with(path_str), "Buffers stem ends with {}", path_str);
                },
                _ => panic!("Unknown ItemType"),
            }
        }
    }
}

#[test]
fn test_llvm_gcno_detection() {
    let tmp_dir = tempdir().unwrap();
    let test_file_path = tmp_dir.path().join("test.gcno");
    let mut file = File::create(&test_file_path).unwrap();
    let magic: [u8; 8] = [b'o', b'n', b'c', b'g', b'*', b'2', b'0', b'4'];
    file.write_all(&magic).unwrap();

    let queue = WorkQueue::new();
    producer(tmp_dir.path(), &[test_file_path.to_string_lossy().to_string()], &queue, false, false);

    let expected = vec![
        ( "ItemFormat::GCNO", false, "test", true)
    ];
    check_produced(tmp_dir.path(), &queue, &expected);
}