#[test]
fn test_dump_json_to_stdout() {
  let space = FuncSpace {
    name: None,
    kind: crate::spaces::SpaceKind::Function,
    start_line: 1,
    end_line: 10,
    spaces: vec![],
    metrics: CodeMetrics {
      nargs: fn_args::Stats { n_args: 0 },
      nexits: exit::Stats { exit: 0 },
      cyclomatic: cyclomatic::Stats { cyclomatic: 0.0 },
      halstead: halstead::Stats::default(),
      loc: loc::Stats::default(),
      nom: nom::Stats::default(),
      mi: mi::Stats::default(),
    },
  };
  let path = PathBuf::from("test_file");
  let output_path = None;
  let output_format = Format::Json;
  let pretty = true;

  let expected_json = serde_json::to_string_pretty(&space).unwrap();
  let mut actual_json = Vec::new();
  let mut stdout = std::io::stdout();
  stdout.lock().write_all(expected_json.as_bytes()).unwrap();

  dump_formats(&space, &path, &output_path, output_format, pretty).unwrap();
  let mut stdout = std::io::stdout();
  stdout.lock().read_to_end(&mut actual_json).unwrap();

  assert_eq!(expected_json, String::from_utf8_lossy(&actual_json).to_string());
}