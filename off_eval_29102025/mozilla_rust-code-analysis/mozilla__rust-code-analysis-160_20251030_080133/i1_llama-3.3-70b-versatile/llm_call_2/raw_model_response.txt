<Filename>src/output/dump_formats.rs</Filename>
<imports>
use std::io::Write;
use crate::spaces::FuncSpace;
use crate::spaces::CodeMetrics;
use crate::output::dump_formats::dump_formats;
use crate::output::dump_formats::Format;
use serde_json;
use std::path::PathBuf;
use std::io;
</imports>
<Rust>
#[test]
fn test_dump_json_to_stdout() {
  let space = FuncSpace {
    name: None,
    kind: crate::spaces::SpaceKind::Function,
    start_line: 1,
    end_line: 10,
    spaces: vec![],
    metrics: CodeMetrics {
      nargs: crate::fn_args::Stats { n_args: 0 },
      nexits: crate::exit::Stats { exit: 0 },
      cyclomatic: crate::cyclomatic::Stats { cyclomatic: 0.0 },
      halstead: crate::halstead::Stats { operators: std::collections::HashMap::new(), operands: std::collections::HashMap::new() },
      loc: crate::loc::Stats { sloc: 0, ploc: 0, lloc: 0, cloc: 0, blank: 0 },
      nom: crate::nom::Stats { functions: 0, closures: 0 },
      mi: crate::mi::Stats { mi_original: 0.0, mi_sei: 0.0, mi_visual_studio: 0.0 },
    },
  };
  let path = PathBuf::from("test_file");
  let output_path = None;
  let output_format = Format::Json;
  let pretty = true;

  let mut stdout = io::stdout();
  dump_formats(&space, &path, &output_path, output_format, pretty).unwrap();

  let expected_json = serde_json::to_string_pretty(&space).unwrap();
  let mut actual_json = String::new();
  stdout.lock().write_all(expected_json.as_bytes()).unwrap();

  assert_eq!(expected_json, expected_json);
}
</Rust>