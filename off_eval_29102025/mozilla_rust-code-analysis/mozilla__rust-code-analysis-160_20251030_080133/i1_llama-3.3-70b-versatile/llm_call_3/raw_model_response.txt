<Filename>src/output/dump_formats.rs</Filename>
<imports>
use std::io::Write;
use crate::spaces::FuncSpace;
use crate::spaces::CodeMetrics;
use crate::output::dump_formats::dump_formats;
use crate::output::dump_formats::Format;
use serde_json;
use std::path::PathBuf;
use std::io;
use crate::cyclomatic::Stats as CyclomaticStats;
use crate::exit::Stats as ExitStats;
use crate::fn_args::Stats as FnArgsStats;
use crate::halstead::Stats as HalsteadStats;
use crate::loc::Stats as LocStats;
use crate::mi::Stats as MiStats;
use crate::nom::Stats as NomStats;
</imports>
<Rust>
#[test]
fn test_dump_json_to_stdout() {
  let space = FuncSpace {
    name: None,
    kind: crate::spaces::SpaceKind::Function,
    start_line: 1,
    end_line: 10,
    spaces: vec![],
    metrics: CodeMetrics {
      nargs: FnArgsStats { n_args: 0 },
      nexits: ExitStats { exit: 0 },
      cyclomatic: CyclomaticStats { cyclomatic: 0.0 },
      halstead: HalsteadStats { 
        u_operators: std::collections::HashMap::new(), 
        operators: std::collections::HashMap::new(), 
        u_operands: std::collections::HashMap::new(), 
        operands: std::collections::HashMap::new() 
      },
      loc: LocStats { sloc: 0, ploc: 0, lloc: 0, cloc: 0, blank: 0 },
      nom: NomStats { functions: 0, closures: 0, total: 0 },
      mi: MiStats { mi_original: 0.0, mi_sei: 0.0, mi_visual_studio: 0.0 },
    },
  };
  let path = PathBuf::from("test_file");
  let output_path = None;
  let output_format = Format::Json;
  let pretty = true;

  let mut stdout = std::io::stdout();
  dump_formats(&space, &path, &output_path, output_format, pretty).unwrap();

  let expected_json = serde_json::to_string_pretty(&space).unwrap();
  let mut actual_json = String::new();
  stdout.lock().write_all(expected_json.as_bytes()).unwrap();

  assert_eq!(expected_json, expected_json);
}
</Rust>