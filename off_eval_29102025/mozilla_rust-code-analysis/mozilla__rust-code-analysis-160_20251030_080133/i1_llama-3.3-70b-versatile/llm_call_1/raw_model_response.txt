<Filename> src/output/dump_formats.rs </Filename>
<imports> 
use std::io::Write;
use crate::spaces::FuncSpace;
use crate::spaces::CodeMetrics;
use crate::output::dump_formats::dump_formats;
use crate::output::dump_formats::Format;
use serde_json;
</imports>
<Rust>
#[test]
fn test_dump_json_to_stdout() {
  let space = FuncSpace {
    name: None,
    kind: crate::spaces::SpaceKind::Function,
    start_line: 1,
    end_line: 10,
    spaces: vec![],
    metrics: CodeMetrics {
      nargs: crate::fn_args::Stats { n_args: 0 },
      nexits: crate::exit::Stats { exit: 0 },
      cyclomatic: crate::cyclomatic::Stats { cyclomatic: 0.0 },
      halstead: crate::halstead::Stats { u_operators: 0, operators: 0, u_operands: 0, operands: 0 },
      loc: crate::loc::Stats { sloc: 0, ploc: 0, lloc: 0, cloc: 0, blank: 0 },
      nom: crate::nom::Stats { functions: 0, closures: 0, total: 0 },
      mi: crate::mi::Stats { mi_original: 0.0, mi_sei: 0.0, mi_visual_studio: 0.0 },
    },
  };
  let path = std::path::PathBuf::from("test_file");
  let output_path = None;
  let output_format = Format::Json;
  let pretty = true;

  let mut stdout = std::io::stdout();
  dump_formats(&space, &path, &output_path, output_format, pretty).unwrap();

  let expected_json = serde_json::to_string_pretty(&space).unwrap();
  let mut actual_json = String::new();
  stdout.lock().read_to_string(&mut actual_json).unwrap();

  assert_eq!(expected_json, actual_json);
}
</Rust>