Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Use a stack approach for cognitive complexity
Currently the cognitive complexity metric analyzes the nodes using ancestors. It would be helpful to analyze the nodes using a stack approach
</issue>

Patch:
<patch>
diff --git a/src/metrics/cognitive.rs b/src/metrics/cognitive.rs
--- a/src/metrics/cognitive.rs
+++ b/src/metrics/cognitive.rs
@@ -1,3 +1,4 @@
+use fxhash::FxHashMap;
 use serde::ser::{SerializeStruct, Serializer};
 use serde::Serialize;
 use std::fmt;
@@ -123,65 +124,28 @@ pub trait Cognitive
 where
     Self: Checker,
 {
-    fn compute(_node: &Node, _stats: &mut Stats) {}
+    fn compute(
+        _node: &Node,
+        _stats: &mut Stats,
+        _nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>,
+    ) {
+    }
 }
 
-macro_rules! compute_booleans {
-    ($node: ident, $stats: ident, $( $typs: pat_param )|*) => {
-        let mut cursor = $node.object().walk();
-        for child in $node.object().children(&mut cursor) {
-            if let $( $typs )|* = child.kind_id().into() {
-                $stats.structural = $stats
-                    .boolean_seq
-                    .eval_based_on_prev(child.kind_id(), $stats.structural);
-            }
+fn compute_booleans<T: std::cmp::PartialEq + std::convert::From<u16>>(
+    node: &Node,
+    stats: &mut Stats,
+    typs1: T,
+    typs2: T,
+) {
+    let mut cursor = node.object().walk();
+    for child in node.object().children(&mut cursor) {
+        if typs1 == child.kind_id().into() || typs2 == child.kind_id().into() {
+            stats.structural = stats
+                .boolean_seq
+                .eval_based_on_prev(child.kind_id(), stats.structural)
         }
-    };
-}
-
-macro_rules! nesting_levels {
-    ($node: ident, $stats: ident, [$nest_func: pat_param => $nest_func_stop: pat_param],
-     [$lambdas: pat => $( $lambdas_stop: pat_param )|*],
-     [$( $nest_level: pat_param )|* => $( $nest_level_stop: pat_param )|*]) => {
-        // Find the depth of a function (the most external function is
-        // not considered)
-        $stats.nesting = count_specific_ancestors!($node, $nest_func, $nest_func_stop).max(1) - 1;
-
-        // Find the depth of a lambda
-        let lambda_depth = count_specific_ancestors!($node, $lambdas, $( $lambdas_stop )|*);
-
-        // Find the nesting operator level
-        $stats.nesting += lambda_depth
-            + count_specific_ancestors!(
-                $node,
-                $( $nest_level )|*,
-                $( $nest_level_stop)|*
-            );
-
-        // Reset the boolean sequence
-        $stats.boolean_seq.reset();
-
-        increment($stats);
-    };
-    ($node: ident, $stats: ident,
-     [$lambdas: pat_param => $( $lambdas_stop: pat_param )|*],
-     [$( $nest_level: pat_param )|* => $( $nest_level_stop: pat_param )|*]) => {
-        // Find the depth of a lambda
-        let lambda_depth = count_specific_ancestors!($node, $lambdas, $( $lambdas_stop )|*);
-
-        // Find the nesting operator level
-        $stats.nesting = lambda_depth
-            + count_specific_ancestors!(
-                $node,
-                $( $nest_level )|*,
-                $( $nest_level_stop)|*
-            );
-
-        // Reset the boolean sequence
-        $stats.boolean_seq.reset();
-
-        increment($stats);
-    };
+    }
 }
 
 #[derive(Debug, Default, Clone)]
@@ -228,18 +192,59 @@ fn increment_by_one(stats: &mut Stats) {
     stats.structural += 1;
 }
 
+fn get_nesting_from_map(
+    node: &Node,
+    nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>,
+) -> (usize, usize, usize) {
+    if let Some(parent) = node.object().parent() {
+        if let Some(n) = nesting_map.get(&parent.id()) {
+            *n
+        } else {
+            (0, 0, 0)
+        }
+    } else {
+        (0, 0, 0)
+    }
+}
+
+fn increment_function_depth<T: std::cmp::PartialEq + std::convert::From<u16>>(
+    depth: &mut usize,
+    node: &Node,
+    stop: T,
+) {
+    // Increase depth function nesting if needed
+    let mut child = node.object();
+    while let Some(parent) = child.parent() {
+        if stop == parent.kind_id().into() {
+            *depth += 1;
+            break;
+        }
+        child = parent;
+    }
+}
+
+#[inline(always)]
+fn increase_nesting(stats: &mut Stats, nesting: &mut usize, depth: usize, lambda: usize) {
+    stats.nesting = *nesting + depth + lambda;
+    increment(stats);
+    *nesting += 1;
+    stats.boolean_seq.reset();
+}
+
 impl Cognitive for PythonCode {
-    fn compute(node: &Node, stats: &mut Stats) {
+    fn compute(
+        node: &Node,
+        stats: &mut Stats,
+        nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>,
+    ) {
         use Python::*;
 
+        // Get nesting of the parent
+        let (mut nesting, mut depth, mut lambda) = get_nesting_from_map(node, nesting_map);
+
         match node.object().kind_id().into() {
             IfStatement | ForStatement | WhileStatement | ConditionalExpression => {
-                nesting_levels!(
-                    node, stats,
-                    [FunctionDefinition => Module],
-                    [Lambda => FunctionDefinition | Module],
-                    [IfStatement | ForStatement | WhileStatement | ExceptClause => FunctionDefinition]
-                );
+                increase_nesting(stats, &mut nesting, depth, lambda);
             }
             ElifClause => {
                 // No nesting increment for them because their cost has already
@@ -254,6 +259,7 @@ impl Cognitive for PythonCode {
                 increment_by_one(stats);
             }
             ExceptClause => {
+                nesting += 1;
                 increment(stats);
             }
             ExpressionList | ExpressionStatement | Tuple => {
@@ -270,38 +276,46 @@ impl Cognitive for PythonCode {
                         ExpressionList | IfStatement | ForStatement | WhileStatement
                     );
                 }
-                compute_booleans!(node, stats, And | Or);
+                compute_booleans::<language_python::Python>(node, stats, And, Or);
+            }
+            Lambda => {
+                // Increase lambda nesting
+                lambda += 1;
+            }
+            FunctionDefinition => {
+                // Increase depth function nesting if needed
+                increment_function_depth::<language_python::Python>(
+                    &mut depth,
+                    node,
+                    FunctionDefinition,
+                );
             }
             _ => {}
         }
+        // Add node to nesting map
+        nesting_map.insert(node.object().id(), (nesting, depth, lambda));
     }
 }
 
 impl Cognitive for RustCode {
-    fn compute(node: &Node, stats: &mut Stats) {
+    fn compute(
+        node: &Node,
+        stats: &mut Stats,
+        nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>,
+    ) {
         use Rust::*;
-
         //TODO: Implement macros
+        let (mut nesting, mut depth, mut lambda) = get_nesting_from_map(node, nesting_map);
 
         match node.object().kind_id().into() {
             IfExpression | IfLetExpression => {
                 // Check if a node is not an else-if
                 if !Self::is_else_if(node) {
-                    nesting_levels!(
-                        node, stats,
-                        [FunctionItem => SourceFile],
-                        [ClosureExpression => SourceFile],
-                        [IfExpression | IfLetExpression | ForExpression | WhileExpression | MatchExpression => FunctionItem]
-                    );
+                    increase_nesting(stats,&mut nesting, depth, lambda);
                 }
             }
             ForExpression | WhileExpression | MatchExpression => {
-                nesting_levels!(
-                    node, stats,
-                    [FunctionItem => SourceFile],
-                    [ClosureExpression => SourceFile],
-                    [IfExpression | IfLetExpression | ForExpression | WhileExpression | MatchExpression => FunctionItem]
-                );
+                increase_nesting(stats,&mut nesting, depth, lambda);
             }
             Else /*else-if also */ => {
                 increment_by_one(stats);
@@ -317,45 +331,41 @@ impl Cognitive for RustCode {
                 stats.boolean_seq.not_operator(node.object().kind_id());
             }
             BinaryExpression => {
-                compute_booleans!(node, stats, AMPAMP | PIPEPIPE);
+                compute_booleans::<language_rust::Rust>(node, stats, AMPAMP, PIPEPIPE);
+            }
+            FunctionItem  => {
+                nesting = 0;
+                // Increase depth function nesting if needed
+                increment_function_depth::<language_rust::Rust>(&mut depth, node, FunctionItem);
+            }
+            ClosureExpression => {
+                lambda += 1;
             }
             _ => {}
         }
+        nesting_map.insert(node.object().id(), (nesting, depth, lambda));
     }
 }
 
 impl Cognitive for CppCode {
-    fn compute(node: &Node, stats: &mut Stats) {
+    fn compute(
+        node: &Node,
+        stats: &mut Stats,
+        nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>,
+    ) {
         use Cpp::*;
 
         //TODO: Implement macros
+        let (mut nesting, depth, mut lambda) = get_nesting_from_map(node, nesting_map);
 
         match node.object().kind_id().into() {
             IfStatement => {
                 if !Self::is_else_if(node) {
-                    nesting_levels!(
-                        node, stats,
-                        [LambdaExpression => TranslationUnit],
-                        [IfStatement
-                            | ForStatement
-                            | WhileStatement
-                            | DoStatement
-                            | SwitchStatement
-                            | CatchClause => FunctionDefinition]
-                    );
+                    increase_nesting(stats,&mut nesting, depth, lambda);
                 }
             }
             ForStatement | WhileStatement | DoStatement | SwitchStatement | CatchClause => {
-                nesting_levels!(
-                    node, stats,
-                    [LambdaExpression => TranslationUnit],
-                    [IfStatement
-                        | ForStatement
-                        | WhileStatement
-                        | DoStatement
-                        | SwitchStatement
-                        | CatchClause => FunctionDefinition]
-                );
+                increase_nesting(stats,&mut nesting, depth, lambda);
             }
             GotoStatement | Else /* else-if also */ => {
                 increment_by_one(stats);
@@ -364,50 +374,31 @@ impl Cognitive for CppCode {
                 stats.boolean_seq.not_operator(node.object().kind_id());
             }
             BinaryExpression2 => {
-                compute_booleans!(node, stats, AMPAMP | PIPEPIPE);
+                compute_booleans::<language_cpp::Cpp>(node, stats, AMPAMP, PIPEPIPE);
+            }
+            LambdaExpression => {
+                lambda += 1;
             }
             _ => {}
         }
+        nesting_map.insert(node.object().id(), (nesting, depth, lambda));
     }
 }
 
 macro_rules! js_cognitive {
     ($lang:ident) => {
-        fn compute(node: &Node, stats: &mut Stats) {
+        fn compute(node: &Node, stats: &mut Stats, nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>) {
             use $lang::*;
+            let (mut nesting, mut depth, mut lambda) = get_nesting_from_map(node, nesting_map);
 
             match node.object().kind_id().into() {
                 IfStatement => {
                     if !Self::is_else_if(&node) {
-                        nesting_levels!(
-                            node, stats,
-                            [FunctionDeclaration => Program],
-                            [ArrowFunction => FunctionDeclaration | Program],
-                            [IfStatement
-                                | ForStatement
-                                | ForInStatement
-                                | WhileStatement
-                                | DoStatement
-                                | SwitchStatement
-                                | CatchClause
-                                | TernaryExpression => FunctionDeclaration]
-                        );
+                        increase_nesting(stats,&mut nesting, depth, lambda);
                     }
                 }
                 ForStatement | ForInStatement | WhileStatement | DoStatement | SwitchStatement | CatchClause | TernaryExpression => {
-                    nesting_levels!(
-                        node, stats,
-                        [FunctionDeclaration => Program],
-                        [ArrowFunction => FunctionDeclaration | Program],
-                        [IfStatement
-                            | ForStatement
-                            | ForInStatement
-                            | WhileStatement
-                            | DoStatement
-                            | SwitchStatement
-                            | CatchClause
-                            | TernaryExpression => FunctionDeclaration]
-                    );
+                    increase_nesting(stats,&mut nesting, depth, lambda);
                 }
                 Else /* else-if also */ => {
                     increment_by_one(stats);
@@ -420,10 +411,21 @@ macro_rules! js_cognitive {
                     stats.boolean_seq.not_operator(node.object().kind_id());
                 }
                 BinaryExpression => {
-                    compute_booleans!(node, stats, AMPAMP | PIPEPIPE);
+                    compute_booleans::<$lang>(node, stats, AMPAMP, PIPEPIPE);
+                }
+                FunctionDeclaration => {
+                    // Reset lambda nesting at function for JS
+                    nesting = 0;
+                    lambda = 0;
+                    // Increase depth function nesting if needed
+                    increment_function_depth::<$lang>(&mut depth, node, FunctionDeclaration);
+                }
+                ArrowFunction => {
+                    lambda += 1;
                 }
                 _ => {}
             }
+            nesting_map.insert(node.object().id(), (nesting, depth, lambda));
         }
     };
 }

diff --git a/src/spaces.rs b/src/spaces.rs
--- a/src/spaces.rs
+++ b/src/spaces.rs
@@ -1,3 +1,4 @@
+use fxhash::FxHashMap;
 use serde::Serialize;
 use std::fmt;
 use std::path::{Path, PathBuf};
@@ -293,7 +294,10 @@ pub fn metrics<'a, T: ParserTrait>(parser: &'a T, path: &'a Path) -> Option<Func
     let mut children = Vec::new();
     let mut state_stack: Vec<State> = Vec::new();
     let mut last_level = 0;
-
+    // Initialize nesting_map used for storing nesting information for cognitive
+    // Three type of nesting info: conditionals, functions and lambdas
+    let mut nesting_map = FxHashMap::<usize, (usize, usize, usize)>::default();
+    nesting_map.insert(node.object().id(), (0, 0, 0));
     stack.push((node, 0));
 
     while let Some((node, level)) = stack.pop() {
@@ -321,7 +325,7 @@ pub fn metrics<'a, T: ParserTrait>(parser: &'a T, path: &'a Path) -> Option<Func
 
         if let Some(state) = state_stack.last_mut() {
             let last = &mut state.space;
-            T::Cognitive::compute(&node, &mut last.metrics.cognitive);
+            T::Cognitive::compute(&node, &mut last.metrics.cognitive, &mut nesting_map);
             T::Cyclomatic::compute(&node, &mut last.metrics.cyclomatic);
             T::Halstead::compute(&node, code, &mut state.halstead_maps);
             T::Loc::compute(&node, &mut last.metrics.loc, func_space, unit);


</patch>

<TEST>
<Filename>src/metrics/cognitive.rs</Filename>
<imports>use std::collections::HashMap;
use fxhash::FxHashMap;</imports>
<Rust>#[test]
fn test_cognitive_compute() {
  let mut stats = Stats::default();
  let mut nesting_map: FxHashMap<usize, (usize, usize, usize)> = FxHashMap::default();
  let node = Node { 0: () };
  let python_code = PythonCode;
  python_code.compute(&node, &mut stats, &mut nesting_map);
  assert_ne!(stats.nesting, 0);
}
</Rust>
</TEST>

<output>
error[E0423]: expected value, found struct `PythonCode`
    --> src/metrics/cognitive.rs:1523:25
     |
1523 |       let python_code = PythonCode;
     |                         ^^^^^^^^^^ help: use struct literal syntax instead: `PythonCode { _guard: val }`
     |
    ::: src/macros.rs:254:13
     |
254  |             pub struct $code { _guard: (), }
     |             -------------------------------- `PythonCode` defined here

error[E0308]: mismatched types
    --> src/metrics/cognitive.rs:1522:28
     |
1522 |       let node = Node { 0: () };
     |                            ^^ expected `Node<'_>`, found `()`
</output>

Function signatures
<Signatures>
fn increment_by_one(stats: &mut Stats) -> ()

pub fn metrics<'a, T: ParserTrait>(parser: &'a T, path: &'a Path) -> Option<FuncSpace>
</Signatures>

You are a software tester at rust-code-analysis and your are reviewing the above <patch> for the above <issue>.
A unit test has already been created for this PR and can be found alongside the filename and the imports used inside the <TEST> block.
It currently fails on codebase after the patch, which the errors in the <output> block.
Your task is to:
1. Identify and understand the errors introduced by the unit test.
2. Update the unit test in the <TEST> block in order for it to fail on the code before the patch, and pass after, hence verifying that the patch resolves the issue.
3. All 'use' declarations must be inside a <imports>...</imports> block. Additionally:
   - Do not use group imports.
  - Import only what is necessary for the test to run and make sure not to have colliding imports.
  - If the <patch> contains a 'mod tests' block with useful imports, do not add them to the <imports> block.
  - Use `use super::<function name> for the function under test.
.  - If multiple 'use' statements are needed, list each on a separate line.
4. To help you write the test, <Signatures> contains all modified function's:
  - name
  - parameters
  - Return type (assume '()' if empty)
5. Return only the absolute filename as it is in the <patch> block, the use statements, and rust test (no comments or explanations).

Follow this expected output format, do not deviate from this structure:
<Filename> ... </Filename>
<imports> ... </imports>
<Rust>
#[test]
fn test_<describe_behavior>() {
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
}</Rust>

