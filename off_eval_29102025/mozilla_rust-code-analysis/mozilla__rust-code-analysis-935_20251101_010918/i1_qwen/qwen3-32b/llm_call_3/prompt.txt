Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Use a stack approach for cognitive complexity
Currently the cognitive complexity metric analyzes the nodes using ancestors. It would be helpful to analyze the nodes using a stack approach
</issue>

Patch:
<patch>
diff --git a/src/metrics/cognitive.rs b/src/metrics/cognitive.rs
--- a/src/metrics/cognitive.rs
+++ b/src/metrics/cognitive.rs
@@ -1,3 +1,4 @@
+use fxhash::FxHashMap;
 use serde::ser::{SerializeStruct, Serializer};
 use serde::Serialize;
 use std::fmt;
@@ -123,65 +124,28 @@ pub trait Cognitive
 where
     Self: Checker,
 {
-    fn compute(_node: &Node, _stats: &mut Stats) {}
+    fn compute(
+        _node: &Node,
+        _stats: &mut Stats,
+        _nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>,
+    ) {
+    }
 }
 
-macro_rules! compute_booleans {
-    ($node: ident, $stats: ident, $( $typs: pat_param )|*) => {
-        let mut cursor = $node.object().walk();
-        for child in $node.object().children(&mut cursor) {
-            if let $( $typs )|* = child.kind_id().into() {
-                $stats.structural = $stats
-                    .boolean_seq
-                    .eval_based_on_prev(child.kind_id(), $stats.structural);
-            }
+fn compute_booleans<T: std::cmp::PartialEq + std::convert::From<u16>>(
+    node: &Node,
+    stats: &mut Stats,
+    typs1: T,
+    typs2: T,
+) {
+    let mut cursor = node.object().walk();
+    for child in node.object().children(&mut cursor) {
+        if typs1 == child.kind_id().into() || typs2 == child.kind_id().into() {
+            stats.structural = stats
+                .boolean_seq
+                .eval_based_on_prev(child.kind_id(), stats.structural)
         }
-    };
-}
-
-macro_rules! nesting_levels {
-    ($node: ident, $stats: ident, [$nest_func: pat_param => $nest_func_stop: pat_param],
-     [$lambdas: pat => $( $lambdas_stop: pat_param )|*],
-     [$( $nest_level: pat_param )|* => $( $nest_level_stop: pat_param )|*]) => {
-        // Find the depth of a function (the most external function is
-        // not considered)
-        $stats.nesting = count_specific_ancestors!($node, $nest_func, $nest_func_stop).max(1) - 1;
-
-        // Find the depth of a lambda
-        let lambda_depth = count_specific_ancestors!($node, $lambdas, $( $lambdas_stop )|*);
-
-        // Find the nesting operator level
-        $stats.nesting += lambda_depth
-            + count_specific_ancestors!(
-                $node,
-                $( $nest_level )|*,
-                $( $nest_level_stop)|*
-            );
-
-        // Reset the boolean sequence
-        $stats.boolean_seq.reset();
-
-        increment($stats);
-    };
-    ($node: ident, $stats: ident,
-     [$lambdas: pat_param => $( $lambdas_stop: pat_param )|*],
-     [$( $nest_level: pat_param )|* => $( $nest_level_stop: pat_param )|*]) => {
-        // Find the depth of a lambda
-        let lambda_depth = count_specific_ancestors!($node, $lambdas, $( $lambdas_stop )|*);
-
-        // Find the nesting operator level
-        $stats.nesting = lambda_depth
-            + count_specific_ancestors!(
-                $node,
-                $( $nest_level )|*,
-                $( $nest_level_stop)|*
-            );
-
-        // Reset the boolean sequence
-        $stats.boolean_seq.reset();
-
-        increment($stats);
-    };
+    }
 }
 
 #[derive(Debug, Default, Clone)]
@@ -228,18 +192,59 @@ fn increment_by_one(stats: &mut Stats) {
     stats.structural += 1;
 }
 
+fn get_nesting_from_map(
+    node: &Node,
+    nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>,
+) -> (usize, usize, usize) {
+    if let Some(parent) = node.object().parent() {
+        if let Some(n) = nesting_map.get(&parent.id()) {
+            *n
+        } else {
+            (0, 0, 0)
+        }
+    } else {
+        (0, 0, 0)
+    }
+}
+
+fn increment_function_depth<T: std::cmp::PartialEq + std::convert::From<u16>>(
+    depth: &mut usize,
+    node: &Node,
+    stop: T,
+) {
+    // Increase depth function nesting if needed
+    let mut child = node.object();
+    while let Some(parent) = child.parent() {
+        if stop == parent.kind_id().into() {
+            *depth += 1;
+            break;
+        }
+        child = parent;
+    }
+}
+
+#[inline(always)]
+fn increase_nesting(stats: &mut Stats, nesting: &mut usize, depth: usize, lambda: usize) {
+    stats.nesting = *nesting + depth + lambda;
+    increment(stats);
+    *nesting += 1;
+    stats.boolean_seq.reset();
+}
+
 impl Cognitive for PythonCode {
-    fn compute(node: &Node, stats: &mut Stats) {
+    fn compute(
+        node: &Node,
+        stats: &mut Stats,
+        nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>,
+    ) {
         use Python::*;
 
+        // Get nesting of the parent
+        let (mut nesting, mut depth, mut lambda) = get_nesting_from_map(node, nesting_map);
+
         match node.object().kind_id().into() {
             IfStatement | ForStatement | WhileStatement | ConditionalExpression => {
-                nesting_levels!(
-                    node, stats,
-                    [FunctionDefinition => Module],
-                    [Lambda => FunctionDefinition | Module],
-                    [IfStatement | ForStatement | WhileStatement | ExceptClause => FunctionDefinition]
-                );
+                increase_nesting(stats, &mut nesting, depth, lambda);
             }
             ElifClause => {
                 // No nesting increment for them because their cost has already
@@ -254,6 +259,7 @@ impl Cognitive for PythonCode {
                 increment_by_one(stats);
             }
             ExceptClause => {
+                nesting += 1;
                 increment(stats);
             }
             ExpressionList | ExpressionStatement | Tuple => {
@@ -270,38 +276,46 @@ impl Cognitive for PythonCode {
                         ExpressionList | IfStatement | ForStatement | WhileStatement
                     );
                 }
-                compute_booleans!(node, stats, And | Or);
+                compute_booleans::<language_python::Python>(node, stats, And, Or);
+            }
+            Lambda => {
+                // Increase lambda nesting
+                lambda += 1;
+            }
+            FunctionDefinition => {
+                // Increase depth function nesting if needed
+                increment_function_depth::<language_python::Python>(
+                    &mut depth,
+                    node,
+                    FunctionDefinition,
+                );
             }
             _ => {}
         }
+        // Add node to nesting map
+        nesting_map.insert(node.object().id(), (nesting, depth, lambda));
     }
 }
 
 impl Cognitive for RustCode {
-    fn compute(node: &Node, stats: &mut Stats) {
+    fn compute(
+        node: &Node,
+        stats: &mut Stats,
+        nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>,
+    ) {
         use Rust::*;
-
         //TODO: Implement macros
+        let (mut nesting, mut depth, mut lambda) = get_nesting_from_map(node, nesting_map);
 
         match node.object().kind_id().into() {
             IfExpression | IfLetExpression => {
                 // Check if a node is not an else-if
                 if !Self::is_else_if(node) {
-                    nesting_levels!(
-                        node, stats,
-                        [FunctionItem => SourceFile],
-                        [ClosureExpression => SourceFile],
-                        [IfExpression | IfLetExpression | ForExpression | WhileExpression | MatchExpression => FunctionItem]
-                    );
+                    increase_nesting(stats,&mut nesting, depth, lambda);
                 }
             }
             ForExpression | WhileExpression | MatchExpression => {
-                nesting_levels!(
-                    node, stats,
-                    [FunctionItem => SourceFile],
-                    [ClosureExpression => SourceFile],
-                    [IfExpression | IfLetExpression | ForExpression | WhileExpression | MatchExpression => FunctionItem]
-                );
+                increase_nesting(stats,&mut nesting, depth, lambda);
             }
             Else /*else-if also */ => {
                 increment_by_one(stats);
@@ -317,45 +331,41 @@ impl Cognitive for RustCode {
                 stats.boolean_seq.not_operator(node.object().kind_id());
             }
             BinaryExpression => {
-                compute_booleans!(node, stats, AMPAMP | PIPEPIPE);
+                compute_booleans::<language_rust::Rust>(node, stats, AMPAMP, PIPEPIPE);
+            }
+            FunctionItem  => {
+                nesting = 0;
+                // Increase depth function nesting if needed
+                increment_function_depth::<language_rust::Rust>(&mut depth, node, FunctionItem);
+            }
+            ClosureExpression => {
+                lambda += 1;
             }
             _ => {}
         }
+        nesting_map.insert(node.object().id(), (nesting, depth, lambda));
     }
 }
 
 impl Cognitive for CppCode {
-    fn compute(node: &Node, stats: &mut Stats) {
+    fn compute(
+        node: &Node,
+        stats: &mut Stats,
+        nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>,
+    ) {
         use Cpp::*;
 
         //TODO: Implement macros
+        let (mut nesting, depth, mut lambda) = get_nesting_from_map(node, nesting_map);
 
         match node.object().kind_id().into() {
             IfStatement => {
                 if !Self::is_else_if(node) {
-                    nesting_levels!(
-                        node, stats,
-                        [LambdaExpression => TranslationUnit],
-                        [IfStatement
-                            | ForStatement
-                            | WhileStatement
-                            | DoStatement
-                            | SwitchStatement
-                            | CatchClause => FunctionDefinition]
-                    );
+                    increase_nesting(stats,&mut nesting, depth, lambda);
                 }
             }
             ForStatement | WhileStatement | DoStatement | SwitchStatement | CatchClause => {
-                nesting_levels!(
-                    node, stats,
-                    [LambdaExpression => TranslationUnit],
-                    [IfStatement
-                        | ForStatement
-                        | WhileStatement
-                        | DoStatement
-                        | SwitchStatement
-                        | CatchClause => FunctionDefinition]
-                );
+                increase_nesting(stats,&mut nesting, depth, lambda);
             }
             GotoStatement | Else /* else-if also */ => {
                 increment_by_one(stats);
@@ -364,50 +374,31 @@ impl Cognitive for CppCode {
                 stats.boolean_seq.not_operator(node.object().kind_id());
             }
             BinaryExpression2 => {
-                compute_booleans!(node, stats, AMPAMP | PIPEPIPE);
+                compute_booleans::<language_cpp::Cpp>(node, stats, AMPAMP, PIPEPIPE);
+            }
+            LambdaExpression => {
+                lambda += 1;
             }
             _ => {}
         }
+        nesting_map.insert(node.object().id(), (nesting, depth, lambda));
     }
 }
 
 macro_rules! js_cognitive {
     ($lang:ident) => {
-        fn compute(node: &Node, stats: &mut Stats) {
+        fn compute(node: &Node, stats: &mut Stats, nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>) {
             use $lang::*;
+            let (mut nesting, mut depth, mut lambda) = get_nesting_from_map(node, nesting_map);
 
             match node.object().kind_id().into() {
                 IfStatement => {
                     if !Self::is_else_if(&node) {
-                        nesting_levels!(
-                            node, stats,
-                            [FunctionDeclaration => Program],
-                            [ArrowFunction => FunctionDeclaration | Program],
-                            [IfStatement
-                                | ForStatement
-                                | ForInStatement
-                                | WhileStatement
-                                | DoStatement
-                                | SwitchStatement
-                                | CatchClause
-                                | TernaryExpression => FunctionDeclaration]
-                        );
+                        increase_nesting(stats,&mut nesting, depth, lambda);
                     }
                 }
                 ForStatement | ForInStatement | WhileStatement | DoStatement | SwitchStatement | CatchClause | TernaryExpression => {
-                    nesting_levels!(
-                        node, stats,
-                        [FunctionDeclaration => Program],
-                        [ArrowFunction => FunctionDeclaration | Program],
-                        [IfStatement
-                            | ForStatement
-                            | ForInStatement
-                            | WhileStatement
-                            | DoStatement
-                            | SwitchStatement
-                            | CatchClause
-                            | TernaryExpression => FunctionDeclaration]
-                    );
+                    increase_nesting(stats,&mut nesting, depth, lambda);
                 }
                 Else /* else-if also */ => {
                     increment_by_one(stats);
@@ -420,10 +411,21 @@ macro_rules! js_cognitive {
                     stats.boolean_seq.not_operator(node.object().kind_id());
                 }
                 BinaryExpression => {
-                    compute_booleans!(node, stats, AMPAMP | PIPEPIPE);
+                    compute_booleans::<$lang>(node, stats, AMPAMP, PIPEPIPE);
+                }
+                FunctionDeclaration => {
+                    // Reset lambda nesting at function for JS
+                    nesting = 0;
+                    lambda = 0;
+                    // Increase depth function nesting if needed
+                    increment_function_depth::<$lang>(&mut depth, node, FunctionDeclaration);
+                }
+                ArrowFunction => {
+                    lambda += 1;
                 }
                 _ => {}
             }
+            nesting_map.insert(node.object().id(), (nesting, depth, lambda));
         }
     };
 }

diff --git a/src/spaces.rs b/src/spaces.rs
--- a/src/spaces.rs
+++ b/src/spaces.rs
@@ -1,3 +1,4 @@
+use fxhash::FxHashMap;
 use serde::Serialize;
 use std::fmt;
 use std::path::{Path, PathBuf};
@@ -293,7 +294,10 @@ pub fn metrics<'a, T: ParserTrait>(parser: &'a T, path: &'a Path) -> Option<Func
     let mut children = Vec::new();
     let mut state_stack: Vec<State> = Vec::new();
     let mut last_level = 0;
-
+    // Initialize nesting_map used for storing nesting information for cognitive
+    // Three type of nesting info: conditionals, functions and lambdas
+    let mut nesting_map = FxHashMap::<usize, (usize, usize, usize)>::default();
+    nesting_map.insert(node.object().id(), (0, 0, 0));
     stack.push((node, 0));
 
     while let Some((node, level)) = stack.pop() {
@@ -321,7 +325,7 @@ pub fn metrics<'a, T: ParserTrait>(parser: &'a T, path: &'a Path) -> Option<Func
 
         if let Some(state) = state_stack.last_mut() {
             let last = &mut state.space;
-            T::Cognitive::compute(&node, &mut last.metrics.cognitive);
+            T::Cognitive::compute(&node, &mut last.metrics.cognitive, &mut nesting_map);
             T::Cyclomatic::compute(&node, &mut last.metrics.cyclomatic);
             T::Halstead::compute(&node, code, &mut state.halstead_maps);
             T::Loc::compute(&node, &mut last.metrics.loc, func_space, unit);


</patch>

<TEST>
<Filename>src/spaces.rs</Filename>
<imports>use super::metrics;
use std::path::Path;
use fxhash::FxHashMap;</imports>
<Rust>#[test]
fn test_cognitive_nesting_stack() {
    // Mock parser simulating a structure: function -> lambda -> if
    struct MockParser;
    impl<'a> crate::ParserTrait for MockParser {
        type Checker = ();
        type Getter = ();
        type Cognitive = PythonCode;
        type Cyclomatic = ();
        type Halstead = ();
        type Loc = ();
        type Nom = ();
        type Mi = ();
        type NArgs = ();
        type Exit = ();
        type Wmc = ();
        type Abc = ();
        type Npm = ();
        type Npa = ();

        fn new(_code: Vec<u8>, _path: &Path, _pr: Option<std::sync::Arc<()>>) -> Self {
            Self
        }

        fn get_language(&self) -> LANG {
            LANG::Python
        }

        fn get_root(&self) -> Node {
            // Dummy node structure for testing
            Node::new(Default::default(), Default::default(), None, None, None)
        }

        fn get_code(&self) -> &[u8] {
            unreachable!()
        }

        fn get_filters(&self, _filters: &[String]) -> Filter {
            unreachable!()
        }
    }

    let parser = MockParser::new(Vec::new(), &Path::new(""), None);
    let path = Path::new("test.rs");

    if let Some(func) = metrics(&parser, &path) {
        // Cognitive complexity should increase due to stack-based nesting analysis
        assert!(func.metrics.cognitive.structural > 0, "Stack-based nesting failed to increment complexity");
    } else {
        panic!("Function space structure invalid");
    }
}
</Rust>
</TEST>

<output>
error[E0412]: cannot find type `PythonCode` in this scope
   --> src/spaces.rs:399:26
    |
399 |         type Cognitive = PythonCode;
    |                          ^^^^^^^^^^ not found in this scope
    |
help: consider importing this struct through its public re-export
    |
388 + use crate::PythonCode;
    |

error[E0412]: cannot find type `LANG` in this scope
   --> src/spaces.rs:416:35
    |
416 |         fn get_language(&self) -> LANG {
    |                                   ^^^^ not found in this scope
    |
help: consider importing this enum through its public re-export
    |
388 + use crate::LANG;
    |

error[E0433]: failed to resolve: use of undeclared type `LANG`
   --> src/spaces.rs:417:13
    |
417 |             LANG::Python
    |             ^^^^ use of undeclared type `LANG`
    |
help: consider importing this enum through its public re-export
    |
388 + use crate::LANG;
    |

error[E0412]: cannot find type `Node` in this scope
   --> src/spaces.rs:420:31
    |
420 |         fn get_root(&self) -> Node {
    |                               ^^^^ not found in this scope
    |
help: consider importing one of these structs
    |
388 + use crate::Node;
    |
388 + use petgraph::graph::Node;
    |
388 + use tree_sitter::Node;
    |

error[E0433]: failed to resolve: use of undeclared type `Node`
   --> src/spaces.rs:422:13
    |
422 |             Node::new(Default::default(), Default::default(), None, None, None)
    |             ^^^^ use of undeclared type `Node`
    |
help: consider importing one of these structs
    |
388 + use crate::Node;
    |
388 + use petgraph::graph::Node;
    |
388 + use tree_sitter::Node;
    |

error[E0412]: cannot find type `Filter` in this scope
   --> src/spaces.rs:429:55
    |
429 |         fn get_filters(&self, _filters: &[String]) -> Filter {
    |                                                       ^^^^^^ not found in this scope
    |
help: consider importing one of these structs
    |
388 + use crate::Filter;
    |
388 + use std::iter::Filter;
    |

error[E0277]: the trait bound `(): alterator::Alterator` is not satisfied
   --> src/spaces.rs:397:24
    |
397 |         type Checker = ();
    |                        ^^ the trait `alterator::Alterator` is not implemented for `()`
    |
    = help: the following other types implement trait `alterator::Alterator`:
              langs::CcommentCode
              langs::CppCode
              langs::JavaCode
              langs::JavascriptCode
              langs::MozjsCode
              langs::PreprocCode
              langs::PythonCode
              langs::RustCode
            and 2 others
note: required by a bound in `traits::ParserTrait::Checker`
   --> src/traits.rs:56:19
    |
56  |     type Checker: Alterator + Checker;
    |                   ^^^^^^^^^ required by this bound in `ParserTrait::Checker`

error[E0277]: the trait bound `(): Getter` is not satisfied
   --> src/spaces.rs:398:23
    |
398 |         type Getter = ();
    |                       ^^ the trait `Getter` is not implemented for `()`
    |
    = help: the following other types implement trait `Getter`:
              langs::CcommentCode
              langs::CppCode
              langs::JavaCode
              langs::JavascriptCode
              langs::MozjsCode
              langs::PreprocCode
              langs::PythonCode
              langs::RustCode
            and 2 others
note: required by a bound in `traits::ParserTrait::Getter`
   --> src/traits.rs:57:18
    |
57  |     type Getter: Getter;
    |                  ^^^^^^ required by this bound in `ParserTrait::Getter`

error[E0277]: the trait bound `(): Cyclomatic` is not satisfied
   --> src/spaces.rs:400:27
    |
400 |         type Cyclomatic = ();
    |                           ^^ the trait `Cyclomatic` is not implemented for `()`
    |
    = help: the following other types implement trait `Cyclomatic`:
              langs::CcommentCode
              langs::CppCode
              langs::JavaCode
              langs::JavascriptCode
              langs::MozjsCode
              langs::PreprocCode
              langs::PythonCode
              langs::RustCode
            and 2 others
note: required by a bound in `traits::ParserTrait::Cyclomatic`
   --> src/traits.rs:59:22
    |
59  |     type Cyclomatic: Cyclomatic;
    |                      ^^^^^^^^^^ required by this bound in `ParserTrait::Cyclomatic`

error[E0277]: the trait bound `(): Halstead` is not satisfied
   --> src/spaces.rs:401:25
    |
401 |         type Halstead = ();
    |                         ^^ the trait `Halstead` is not implemented for `()`
    |
    = help: the following other types implement trait `Halstead`:
              langs::CcommentCode
              langs::CppCode
              langs::JavaCode
              langs::JavascriptCode
              langs::MozjsCode
              langs::PreprocCode
              langs::PythonCode
              langs::RustCode
            and 2 others
note: required by a bound in `traits::ParserTrait::Halstead`
   --> src/traits.rs:60:20
    |
60  |     type Halstead: Halstead;
    |                    ^^^^^^^^ required by this bound in `ParserTrait::Halstead`

error[E0277]: the trait bound `(): Loc` is not satisfied
   --> src/spaces.rs:402:20
    |
402 |         type Loc = ();
    |                    ^^ the trait `Loc` is not implemented for `()`
    |
    = help: the following other types implement trait `Loc`:
              langs::CcommentCode
              langs::CppCode
              langs::JavaCode
              langs::JavascriptCode
              langs::MozjsCode
              langs::PreprocCode
              langs::PythonCode
              langs::RustCode
            and 2 others
note: required by a bound in `traits::ParserTrait::Loc`
   --> src/traits.rs:61:15
    |
61  |     type Loc: Loc;
    |               ^^^ required by this bound in `ParserTrait::Loc`

error[E0277]: the trait bound `(): Nom` is not satisfied
   --> src/spaces.rs:403:20
    |
403 |         type Nom = ();
    |                    ^^ the trait `Nom` is not implemented for `()`
    |
    = help: the following other types implement trait `Nom`:
              langs::CcommentCode
              langs::CppCode
              langs::JavaCode
              langs::JavascriptCode
              langs::MozjsCode
              langs::PreprocCode
              langs::PythonCode
              langs::RustCode
            and 2 others
note: required by a bound in `traits::ParserTrait::Nom`
   --> src/traits.rs:62:15
    |
62  |     type Nom: Nom;
    |               ^^^ required by this bound in `ParserTrait::Nom`

error[E0277]: the trait bound `(): Mi` is not satisfied
   --> src/spaces.rs:404:19
    |
404 |         type Mi = ();
    |                   ^^ the trait `Mi` is not implemented for `()`
    |
    = help: the following other types implement trait `Mi`:
              langs::CcommentCode
              langs::CppCode
              langs::JavaCode
              langs::JavascriptCode
              langs::MozjsCode
              langs::PreprocCode
              langs::PythonCode
              langs::RustCode
            and 2 others
note: required by a bound in `traits::ParserTrait::Mi`
   --> src/traits.rs:63:14
    |
63  |     type Mi: Mi;
    |              ^^ required by this bound in `ParserTrait::Mi`

error[E0277]: the trait bound `(): NArgs` is not satisfied
   --> src/spaces.rs:405:22
    |
405 |         type NArgs = ();
    |                      ^^ the trait `NArgs` is not implemented for `()`
    |
    = help: the following other types implement trait `NArgs`:
              langs::CcommentCode
              langs::CppCode
              langs::JavaCode
              langs::JavascriptCode
              langs::MozjsCode
              langs::PreprocCode
              langs::PythonCode
              langs::RustCode
            and 2 others
note: required by a bound in `traits::ParserTrait::NArgs`
   --> src/traits.rs:64:17
    |
64  |     type NArgs: NArgs;
    |                 ^^^^^ required by this bound in `ParserTrait::NArgs`

error[E0277]: the trait bound `(): Exit` is not satisfied
   --> src/spaces.rs:406:21
    |
406 |         type Exit = ();
    |                     ^^ the trait `Exit` is not implemented for `()`
    |
    = help: the following other types implement trait `Exit`:
              langs::CcommentCode
              langs::CppCode
              langs::JavaCode
              langs::JavascriptCode
              langs::MozjsCode
              langs::PreprocCode
              langs::PythonCode
              langs::RustCode
            and 2 others
note: required by a bound in `traits::ParserTrait::Exit`
   --> src/traits.rs:65:16
    |
65  |     type Exit: Exit;
    |                ^^^^ required by this bound in `ParserTrait::Exit`

error[E0277]: the trait bound `(): Wmc` is not satisfied
   --> src/spaces.rs:407:20
    |
407 |         type Wmc = ();
    |                    ^^ the trait `Wmc` is not implemented for `()`
    |
    = help: the following other types implement trait `Wmc`:
              langs::CcommentCode
              langs::CppCode
              langs::JavaCode
              langs::JavascriptCode
              langs::MozjsCode
              langs::PreprocCode
              langs::PythonCode
              langs::RustCode
            and 2 others
note: required by a bound in `traits::ParserTrait::Wmc`
   --> src/traits.rs:66:15
    |
66  |     type Wmc: Wmc;
    |               ^^^ required by this bound in `ParserTrait::Wmc`

error[E0277]: the trait bound `(): Abc` is not satisfied
   --> src/spaces.rs:408:20
    |
408 |         type Abc = ();
    |                    ^^ the trait `Abc` is not implemented for `()`
    |
    = help: the following other types implement trait `Abc`:
              langs::CcommentCode
              langs::CppCode
              langs::JavaCode
              langs::JavascriptCode
              langs::MozjsCode
              langs::PreprocCode
              langs::PythonCode
              langs::RustCode
            and 2 others
note: required by a bound in `traits::ParserTrait::Abc`
   --> src/traits.rs:67:15
    |
67  |     type Abc: Abc;
    |               ^^^ required by this bound in `ParserTrait::Abc`

error[E0277]: the trait bound `(): Npm` is not satisfied
   --> src/spaces.rs:409:20
    |
409 |         type Npm = ();
    |                    ^^ the trait `Npm` is not implemented for `()`
    |
    = help: the following other types implement trait `Npm`:
              langs::CcommentCode
              langs::CppCode
              langs::JavaCode
              langs::JavascriptCode
              langs::MozjsCode
              langs::PreprocCode
              langs::PythonCode
              langs::RustCode
            and 2 others
note: required by a bound in `traits::ParserTrait::Npm`
   --> src/traits.rs:68:15
    |
68  |     type Npm: Npm;
    |               ^^^ required by this bound in `ParserTrait::Npm`

error[E0277]: the trait bound `(): Npa` is not satisfied
   --> src/spaces.rs:410:20
    |
410 |         type Npa = ();
    |                    ^^ the trait `Npa` is not implemented for `()`
    |
    = help: the following other types implement trait `Npa`:
              langs::CcommentCode
              langs::CppCode
              langs::JavaCode
              langs::JavascriptCode
              langs::MozjsCode
              langs::PreprocCode
              langs::PythonCode
              langs::RustCode
            and 2 others
note: required by a bound in `traits::ParserTrait::Npa`
   --> src/traits.rs:69:15
    |
69  |     type Npa: Npa;
    |               ^^^ required by this bound in `ParserTrait::Npa`

error[E0053]: method `new` has an incompatible type for trait
   --> src/spaces.rs:412:51
    |
412 |         fn new(_code: Vec<u8>, _path: &Path, _pr: Option<std::sync::Arc<()>>) -> Self {
    |                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `PreprocResults`, found `()`
    |
note: type in trait
   --> src/traits.rs:71:44
    |
71  |     fn new(code: Vec<u8>, path: &Path, pr: Option<Arc<PreprocResults>>) -> Self;
    |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = note: expected signature `fn(Vec<_>, &Path, std::option::Option<Arc<PreprocResults>>) -> MockParser`
               found signature `fn(Vec<_>, &Path, std::option::Option<Arc<()>>) -> MockParser`
help: change the parameter type to match the trait
    |
412 -         fn new(_code: Vec<u8>, _path: &Path, _pr: Option<std::sync::Arc<()>>) -> Self {
412 +         fn new(_code: Vec<u8>, _path: &Path, _pr: std::option::Option<Arc<PreprocResults>>) -> Self {
    |

error[E0599]: no function or associated item named `new` found for struct `MockParser` in the current scope
   --> src/spaces.rs:434:30
    |
395 |     struct MockParser;
    |     ----------------- function or associated item `new` not found for this struct
...
434 |     let parser = MockParser::new(Vec::new(), &Path::new(""), None);
    |                              ^^^ function or associated item not found in `MockParser`
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `ParserTrait` which provides `new` is implemented but not in scope; perhaps you want to import it
    |
388 + use crate::traits::ParserTrait;
    |

error[E0616]: field `structural` of struct `metrics::cognitive::Stats` is private
   --> src/spaces.rs:439:40
    |
439 |         assert!(func.metrics.cognitive.structural > 0, "Stack-based nesting failed to increment complexity");
    |                                        ^^^^^^^^^^ private field
</output>

Function signatures
<Signatures>
fn increment_by_one(stats: &mut Stats) -> ()

pub fn metrics<'a, T: ParserTrait>(parser: &'a T, path: &'a Path) -> Option<FuncSpace>
</Signatures>

You are a software tester at rust-code-analysis and your are reviewing the above <patch> for the above <issue>.
A unit test has already been created for this PR and can be found alongside the filename and the imports used inside the <TEST> block.
It currently fails on codebase after the patch, which the errors in the <output> block.
Your task is to:
1. Identify and understand the errors introduced by the unit test.
2. Update the unit test in the <TEST> block in order for it to fail on the code before the patch, and pass after, hence verifying that the patch resolves the issue.
3. All 'use' declarations must be inside a <imports>...</imports> block. Additionally:
   - Do not use group imports.
  - Import only what is necessary for the test to run and make sure not to have colliding imports.
  - If the <patch> contains a 'mod tests' block with useful imports, do not add them to the <imports> block.
  - Use `use super::<function name> for the function under test.
.  - If multiple 'use' statements are needed, list each on a separate line.
4. To help you write the test, <Signatures> contains all modified function's:
  - name
  - parameters
  - Return type (assume '()' if empty)
5. Return only the absolute filename as it is in the <patch> block, the use statements, and rust test (no comments or explanations).

Follow this expected output format, do not deviate from this structure:
<Filename> ... </Filename>
<imports> ... </imports>
<Rust>
#[test]
fn test_<describe_behavior>() {
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
}</Rust>

