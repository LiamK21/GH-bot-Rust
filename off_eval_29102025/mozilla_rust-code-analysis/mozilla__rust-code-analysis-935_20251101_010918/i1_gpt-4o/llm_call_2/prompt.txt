Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Use a stack approach for cognitive complexity
Currently the cognitive complexity metric analyzes the nodes using ancestors. It would be helpful to analyze the nodes using a stack approach
</issue>

Patch:
<patch>
diff --git a/src/metrics/cognitive.rs b/src/metrics/cognitive.rs
--- a/src/metrics/cognitive.rs
+++ b/src/metrics/cognitive.rs
@@ -1,3 +1,4 @@
+use fxhash::FxHashMap;
 use serde::ser::{SerializeStruct, Serializer};
 use serde::Serialize;
 use std::fmt;
@@ -123,65 +124,28 @@ pub trait Cognitive
 where
     Self: Checker,
 {
-    fn compute(_node: &Node, _stats: &mut Stats) {}
+    fn compute(
+        _node: &Node,
+        _stats: &mut Stats,
+        _nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>,
+    ) {
+    }
 }
 
-macro_rules! compute_booleans {
-    ($node: ident, $stats: ident, $( $typs: pat_param )|*) => {
-        let mut cursor = $node.object().walk();
-        for child in $node.object().children(&mut cursor) {
-            if let $( $typs )|* = child.kind_id().into() {
-                $stats.structural = $stats
-                    .boolean_seq
-                    .eval_based_on_prev(child.kind_id(), $stats.structural);
-            }
+fn compute_booleans<T: std::cmp::PartialEq + std::convert::From<u16>>(
+    node: &Node,
+    stats: &mut Stats,
+    typs1: T,
+    typs2: T,
+) {
+    let mut cursor = node.object().walk();
+    for child in node.object().children(&mut cursor) {
+        if typs1 == child.kind_id().into() || typs2 == child.kind_id().into() {
+            stats.structural = stats
+                .boolean_seq
+                .eval_based_on_prev(child.kind_id(), stats.structural)
         }
-    };
-}
-
-macro_rules! nesting_levels {
-    ($node: ident, $stats: ident, [$nest_func: pat_param => $nest_func_stop: pat_param],
-     [$lambdas: pat => $( $lambdas_stop: pat_param )|*],
-     [$( $nest_level: pat_param )|* => $( $nest_level_stop: pat_param )|*]) => {
-        // Find the depth of a function (the most external function is
-        // not considered)
-        $stats.nesting = count_specific_ancestors!($node, $nest_func, $nest_func_stop).max(1) - 1;
-
-        // Find the depth of a lambda
-        let lambda_depth = count_specific_ancestors!($node, $lambdas, $( $lambdas_stop )|*);
-
-        // Find the nesting operator level
-        $stats.nesting += lambda_depth
-            + count_specific_ancestors!(
-                $node,
-                $( $nest_level )|*,
-                $( $nest_level_stop)|*
-            );
-
-        // Reset the boolean sequence
-        $stats.boolean_seq.reset();
-
-        increment($stats);
-    };
-    ($node: ident, $stats: ident,
-     [$lambdas: pat_param => $( $lambdas_stop: pat_param )|*],
-     [$( $nest_level: pat_param )|* => $( $nest_level_stop: pat_param )|*]) => {
-        // Find the depth of a lambda
-        let lambda_depth = count_specific_ancestors!($node, $lambdas, $( $lambdas_stop )|*);
-
-        // Find the nesting operator level
-        $stats.nesting = lambda_depth
-            + count_specific_ancestors!(
-                $node,
-                $( $nest_level )|*,
-                $( $nest_level_stop)|*
-            );
-
-        // Reset the boolean sequence
-        $stats.boolean_seq.reset();
-
-        increment($stats);
-    };
+    }
 }
 
 #[derive(Debug, Default, Clone)]
@@ -228,18 +192,59 @@ fn increment_by_one(stats: &mut Stats) {
     stats.structural += 1;
 }
 
+fn get_nesting_from_map(
+    node: &Node,
+    nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>,
+) -> (usize, usize, usize) {
+    if let Some(parent) = node.object().parent() {
+        if let Some(n) = nesting_map.get(&parent.id()) {
+            *n
+        } else {
+            (0, 0, 0)
+        }
+    } else {
+        (0, 0, 0)
+    }
+}
+
+fn increment_function_depth<T: std::cmp::PartialEq + std::convert::From<u16>>(
+    depth: &mut usize,
+    node: &Node,
+    stop: T,
+) {
+    // Increase depth function nesting if needed
+    let mut child = node.object();
+    while let Some(parent) = child.parent() {
+        if stop == parent.kind_id().into() {
+            *depth += 1;
+            break;
+        }
+        child = parent;
+    }
+}
+
+#[inline(always)]
+fn increase_nesting(stats: &mut Stats, nesting: &mut usize, depth: usize, lambda: usize) {
+    stats.nesting = *nesting + depth + lambda;
+    increment(stats);
+    *nesting += 1;
+    stats.boolean_seq.reset();
+}
+
 impl Cognitive for PythonCode {
-    fn compute(node: &Node, stats: &mut Stats) {
+    fn compute(
+        node: &Node,
+        stats: &mut Stats,
+        nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>,
+    ) {
         use Python::*;
 
+        // Get nesting of the parent
+        let (mut nesting, mut depth, mut lambda) = get_nesting_from_map(node, nesting_map);
+
         match node.object().kind_id().into() {
             IfStatement | ForStatement | WhileStatement | ConditionalExpression => {
-                nesting_levels!(
-                    node, stats,
-                    [FunctionDefinition => Module],
-                    [Lambda => FunctionDefinition | Module],
-                    [IfStatement | ForStatement | WhileStatement | ExceptClause => FunctionDefinition]
-                );
+                increase_nesting(stats, &mut nesting, depth, lambda);
             }
             ElifClause => {
                 // No nesting increment for them because their cost has already
@@ -254,6 +259,7 @@ impl Cognitive for PythonCode {
                 increment_by_one(stats);
             }
             ExceptClause => {
+                nesting += 1;
                 increment(stats);
             }
             ExpressionList | ExpressionStatement | Tuple => {
@@ -270,38 +276,46 @@ impl Cognitive for PythonCode {
                         ExpressionList | IfStatement | ForStatement | WhileStatement
                     );
                 }
-                compute_booleans!(node, stats, And | Or);
+                compute_booleans::<language_python::Python>(node, stats, And, Or);
+            }
+            Lambda => {
+                // Increase lambda nesting
+                lambda += 1;
+            }
+            FunctionDefinition => {
+                // Increase depth function nesting if needed
+                increment_function_depth::<language_python::Python>(
+                    &mut depth,
+                    node,
+                    FunctionDefinition,
+                );
             }
             _ => {}
         }
+        // Add node to nesting map
+        nesting_map.insert(node.object().id(), (nesting, depth, lambda));
     }
 }
 
 impl Cognitive for RustCode {
-    fn compute(node: &Node, stats: &mut Stats) {
+    fn compute(
+        node: &Node,
+        stats: &mut Stats,
+        nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>,
+    ) {
         use Rust::*;
-
         //TODO: Implement macros
+        let (mut nesting, mut depth, mut lambda) = get_nesting_from_map(node, nesting_map);
 
         match node.object().kind_id().into() {
             IfExpression | IfLetExpression => {
                 // Check if a node is not an else-if
                 if !Self::is_else_if(node) {
-                    nesting_levels!(
-                        node, stats,
-                        [FunctionItem => SourceFile],
-                        [ClosureExpression => SourceFile],
-                        [IfExpression | IfLetExpression | ForExpression | WhileExpression | MatchExpression => FunctionItem]
-                    );
+                    increase_nesting(stats,&mut nesting, depth, lambda);
                 }
             }
             ForExpression | WhileExpression | MatchExpression => {
-                nesting_levels!(
-                    node, stats,
-                    [FunctionItem => SourceFile],
-                    [ClosureExpression => SourceFile],
-                    [IfExpression | IfLetExpression | ForExpression | WhileExpression | MatchExpression => FunctionItem]
-                );
+                increase_nesting(stats,&mut nesting, depth, lambda);
             }
             Else /*else-if also */ => {
                 increment_by_one(stats);
@@ -317,45 +331,41 @@ impl Cognitive for RustCode {
                 stats.boolean_seq.not_operator(node.object().kind_id());
             }
             BinaryExpression => {
-                compute_booleans!(node, stats, AMPAMP | PIPEPIPE);
+                compute_booleans::<language_rust::Rust>(node, stats, AMPAMP, PIPEPIPE);
+            }
+            FunctionItem  => {
+                nesting = 0;
+                // Increase depth function nesting if needed
+                increment_function_depth::<language_rust::Rust>(&mut depth, node, FunctionItem);
+            }
+            ClosureExpression => {
+                lambda += 1;
             }
             _ => {}
         }
+        nesting_map.insert(node.object().id(), (nesting, depth, lambda));
     }
 }
 
 impl Cognitive for CppCode {
-    fn compute(node: &Node, stats: &mut Stats) {
+    fn compute(
+        node: &Node,
+        stats: &mut Stats,
+        nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>,
+    ) {
         use Cpp::*;
 
         //TODO: Implement macros
+        let (mut nesting, depth, mut lambda) = get_nesting_from_map(node, nesting_map);
 
         match node.object().kind_id().into() {
             IfStatement => {
                 if !Self::is_else_if(node) {
-                    nesting_levels!(
-                        node, stats,
-                        [LambdaExpression => TranslationUnit],
-                        [IfStatement
-                            | ForStatement
-                            | WhileStatement
-                            | DoStatement
-                            | SwitchStatement
-                            | CatchClause => FunctionDefinition]
-                    );
+                    increase_nesting(stats,&mut nesting, depth, lambda);
                 }
             }
             ForStatement | WhileStatement | DoStatement | SwitchStatement | CatchClause => {
-                nesting_levels!(
-                    node, stats,
-                    [LambdaExpression => TranslationUnit],
-                    [IfStatement
-                        | ForStatement
-                        | WhileStatement
-                        | DoStatement
-                        | SwitchStatement
-                        | CatchClause => FunctionDefinition]
-                );
+                increase_nesting(stats,&mut nesting, depth, lambda);
             }
             GotoStatement | Else /* else-if also */ => {
                 increment_by_one(stats);
@@ -364,50 +374,31 @@ impl Cognitive for CppCode {
                 stats.boolean_seq.not_operator(node.object().kind_id());
             }
             BinaryExpression2 => {
-                compute_booleans!(node, stats, AMPAMP | PIPEPIPE);
+                compute_booleans::<language_cpp::Cpp>(node, stats, AMPAMP, PIPEPIPE);
+            }
+            LambdaExpression => {
+                lambda += 1;
             }
             _ => {}
         }
+        nesting_map.insert(node.object().id(), (nesting, depth, lambda));
     }
 }
 
 macro_rules! js_cognitive {
     ($lang:ident) => {
-        fn compute(node: &Node, stats: &mut Stats) {
+        fn compute(node: &Node, stats: &mut Stats, nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>) {
             use $lang::*;
+            let (mut nesting, mut depth, mut lambda) = get_nesting_from_map(node, nesting_map);
 
             match node.object().kind_id().into() {
                 IfStatement => {
                     if !Self::is_else_if(&node) {
-                        nesting_levels!(
-                            node, stats,
-                            [FunctionDeclaration => Program],
-                            [ArrowFunction => FunctionDeclaration | Program],
-                            [IfStatement
-                                | ForStatement
-                                | ForInStatement
-                                | WhileStatement
-                                | DoStatement
-                                | SwitchStatement
-                                | CatchClause
-                                | TernaryExpression => FunctionDeclaration]
-                        );
+                        increase_nesting(stats,&mut nesting, depth, lambda);
                     }
                 }
                 ForStatement | ForInStatement | WhileStatement | DoStatement | SwitchStatement | CatchClause | TernaryExpression => {
-                    nesting_levels!(
-                        node, stats,
-                        [FunctionDeclaration => Program],
-                        [ArrowFunction => FunctionDeclaration | Program],
-                        [IfStatement
-                            | ForStatement
-                            | ForInStatement
-                            | WhileStatement
-                            | DoStatement
-                            | SwitchStatement
-                            | CatchClause
-                            | TernaryExpression => FunctionDeclaration]
-                    );
+                    increase_nesting(stats,&mut nesting, depth, lambda);
                 }
                 Else /* else-if also */ => {
                     increment_by_one(stats);
@@ -420,10 +411,21 @@ macro_rules! js_cognitive {
                     stats.boolean_seq.not_operator(node.object().kind_id());
                 }
                 BinaryExpression => {
-                    compute_booleans!(node, stats, AMPAMP | PIPEPIPE);
+                    compute_booleans::<$lang>(node, stats, AMPAMP, PIPEPIPE);
+                }
+                FunctionDeclaration => {
+                    // Reset lambda nesting at function for JS
+                    nesting = 0;
+                    lambda = 0;
+                    // Increase depth function nesting if needed
+                    increment_function_depth::<$lang>(&mut depth, node, FunctionDeclaration);
+                }
+                ArrowFunction => {
+                    lambda += 1;
                 }
                 _ => {}
             }
+            nesting_map.insert(node.object().id(), (nesting, depth, lambda));
         }
     };
 }

diff --git a/src/spaces.rs b/src/spaces.rs
--- a/src/spaces.rs
+++ b/src/spaces.rs
@@ -1,3 +1,4 @@
+use fxhash::FxHashMap;
 use serde::Serialize;
 use std::fmt;
 use std::path::{Path, PathBuf};
@@ -293,7 +294,10 @@ pub fn metrics<'a, T: ParserTrait>(parser: &'a T, path: &'a Path) -> Option<Func
     let mut children = Vec::new();
     let mut state_stack: Vec<State> = Vec::new();
     let mut last_level = 0;
-
+    // Initialize nesting_map used for storing nesting information for cognitive
+    // Three type of nesting info: conditionals, functions and lambdas
+    let mut nesting_map = FxHashMap::<usize, (usize, usize, usize)>::default();
+    nesting_map.insert(node.object().id(), (0, 0, 0));
     stack.push((node, 0));
 
     while let Some((node, level)) = stack.pop() {
@@ -321,7 +325,7 @@ pub fn metrics<'a, T: ParserTrait>(parser: &'a T, path: &'a Path) -> Option<Func
 
         if let Some(state) = state_stack.last_mut() {
             let last = &mut state.space;
-            T::Cognitive::compute(&node, &mut last.metrics.cognitive);
+            T::Cognitive::compute(&node, &mut last.metrics.cognitive, &mut nesting_map);
             T::Cyclomatic::compute(&node, &mut last.metrics.cyclomatic);
             T::Halstead::compute(&node, code, &mut state.halstead_maps);
             T::Loc::compute(&node, &mut last.metrics.loc, func_space, unit);


</patch>

<TEST>
<Filename>src/spaces.rs</Filename>
<imports>use std::path::Path;
use super::metrics;
use crate::ParserTrait;
use crate::FuncSpace;</imports>
<Rust>#[test]
fn test_metrics_with_stack_approach() {
    struct MockParser;
    impl ParserTrait for MockParser {
        type Cognitive = MockCognitive;
        type Cyclomatic = ();
        type Halstead = ();
        type Loc = ();
    }

    struct MockCognitive;
    impl Cognitive for MockCognitive {
        fn compute(node: &Node, stats: &mut Stats, nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>) {
            // Simulate a simple computation for testing
            let (mut nesting, mut depth, mut lambda) = get_nesting_from_map(node, nesting_map);
            nesting += 1;
            stats.nesting = nesting;
            nesting_map.insert(node.object().id(), (nesting, depth, lambda));
        }
    }

    let parser = MockParser;
    let path = Path::new("test_path");
    let expected = Some(FuncSpace { /* expected values based on the mock computation */ });
    let actual = metrics(&parser, &path);
    assert_eq!(expected, actual);
}
</Rust>
</TEST>

<output>
error[E0405]: cannot find trait `Cognitive` in this scope
   --> src/spaces.rs:404:10
    |
404 |     impl Cognitive for MockCognitive {
    |          ^^^^^^^^^ not found in this scope
    |
help: consider importing this trait through its public re-export
    |
388 + use crate::spaces::Cognitive;
    |

error[E0412]: cannot find type `Node` in this scope
   --> src/spaces.rs:405:27
    |
405 |         fn compute(node: &Node, stats: &mut Stats, nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>) {
    |                           ^^^^ not found in this scope
    |
help: consider importing one of these structs
    |
388 + use crate::Node;
    |
388 + use petgraph::graph::Node;
    |
388 + use tree_sitter::Node;
    |

error[E0412]: cannot find type `Stats` in this scope
   --> src/spaces.rs:405:45
    |
405 |         fn compute(node: &Node, stats: &mut Stats, nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>) {
    |                                             ^^^^^ not found in this scope
    |
help: consider importing one of these structs
    |
388 + use crate::abc::Stats;
    |
388 + use crate::cognitive::Stats;
    |
388 + use crate::cyclomatic::Stats;
    |
388 + use crate::exit::Stats;
    |
      and 8 other candidates

error[E0412]: cannot find type `FxHashMap` in this scope
   --> src/spaces.rs:405:70
    |
405 |         fn compute(node: &Node, stats: &mut Stats, nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>) {
    |                                                                      ^^^^^^^^^ not found in this scope
    |
help: consider importing one of these type aliases
    |
388 + use crate::spaces::FxHashMap;
    |
388 + use fxhash::FxHashMap;
    |

error[E0425]: cannot find function `get_nesting_from_map` in this scope
   --> src/spaces.rs:407:56
    |
407 |             let (mut nesting, mut depth, mut lambda) = get_nesting_from_map(node, nesting_map);
    |                                                        ^^^^^^^^^^^^^^^^^^^^ not found in this scope
    |
note: function `crate::cognitive::get_nesting_from_map` exists but is inaccessible
   --> src/metrics/cognitive.rs:195:1
    |
195 | / fn get_nesting_from_map(
196 | |     node: &Node,
197 | |     nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>,
198 | | ) -> (usize, usize, usize) {
...   |
208 | | }
    | |_^ not accessible

error[E0277]: the trait bound `MockCognitive: Cognitive` is not satisfied
   --> src/spaces.rs:397:26
    |
397 |         type Cognitive = MockCognitive;
    |                          ^^^^^^^^^^^^^ the trait `Cognitive` is not implemented for `MockCognitive`
    |
    = help: the following other types implement trait `Cognitive`:
              langs::CcommentCode
              langs::CppCode
              langs::JavaCode
              langs::JavascriptCode
              langs::MozjsCode
              langs::PreprocCode
              langs::PythonCode
              langs::RustCode
            and 2 others
note: required by a bound in `traits::ParserTrait::Cognitive`
   --> src/traits.rs:58:21
    |
58  |     type Cognitive: Cognitive;
    |                     ^^^^^^^^^ required by this bound in `ParserTrait::Cognitive`

error[E0277]: the trait bound `(): Cyclomatic` is not satisfied
   --> src/spaces.rs:398:27
    |
398 |         type Cyclomatic = ();
    |                           ^^ the trait `Cyclomatic` is not implemented for `()`
    |
    = help: the following other types implement trait `Cyclomatic`:
              langs::CcommentCode
              langs::CppCode
              langs::JavaCode
              langs::JavascriptCode
              langs::MozjsCode
              langs::PreprocCode
              langs::PythonCode
              langs::RustCode
            and 2 others
note: required by a bound in `traits::ParserTrait::Cyclomatic`
   --> src/traits.rs:59:22
    |
59  |     type Cyclomatic: Cyclomatic;
    |                      ^^^^^^^^^^ required by this bound in `ParserTrait::Cyclomatic`

error[E0277]: the trait bound `(): Halstead` is not satisfied
   --> src/spaces.rs:399:25
    |
399 |         type Halstead = ();
    |                         ^^ the trait `Halstead` is not implemented for `()`
    |
    = help: the following other types implement trait `Halstead`:
              langs::CcommentCode
              langs::CppCode
              langs::JavaCode
              langs::JavascriptCode
              langs::MozjsCode
              langs::PreprocCode
              langs::PythonCode
              langs::RustCode
            and 2 others
note: required by a bound in `traits::ParserTrait::Halstead`
   --> src/traits.rs:60:20
    |
60  |     type Halstead: Halstead;
    |                    ^^^^^^^^ required by this bound in `ParserTrait::Halstead`

error[E0277]: the trait bound `(): Loc` is not satisfied
   --> src/spaces.rs:400:20
    |
400 |         type Loc = ();
    |                    ^^ the trait `Loc` is not implemented for `()`
    |
    = help: the following other types implement trait `Loc`:
              langs::CcommentCode
              langs::CppCode
              langs::JavaCode
              langs::JavascriptCode
              langs::MozjsCode
              langs::PreprocCode
              langs::PythonCode
              langs::RustCode
            and 2 others
note: required by a bound in `traits::ParserTrait::Loc`
   --> src/traits.rs:61:15
    |
61  |     type Loc: Loc;
    |               ^^^ required by this bound in `ParserTrait::Loc`

error[E0046]: not all trait items implemented, missing: `Checker`, `Getter`, `Nom`, `Mi`, `NArgs`, `Exit`, `Wmc`, `Abc`, `Npm`, `Npa`, `new`, `get_language`, `get_root`, `get_code`, `get_filters`
   --> src/spaces.rs:396:5
    |
396 |     impl ParserTrait for MockParser {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `Checker`, `Getter`, `Nom`, `Mi`, `NArgs`, `Exit`, `Wmc`, `Abc`, `Npm`, `Npa`, `new`, `get_language`, `get_root`, `get_code`, `get_filters` in implementation
    |
   ::: src/traits.rs:56:5
    |
56  |     type Checker: Alterator + Checker;
    |     --------------------------------- `Checker` from trait
57  |     type Getter: Getter;
    |     ------------------- `Getter` from trait
...
62  |     type Nom: Nom;
    |     ------------- `Nom` from trait
63  |     type Mi: Mi;
    |     ----------- `Mi` from trait
64  |     type NArgs: NArgs;
    |     ----------------- `NArgs` from trait
65  |     type Exit: Exit;
    |     --------------- `Exit` from trait
66  |     type Wmc: Wmc;
    |     ------------- `Wmc` from trait
67  |     type Abc: Abc;
    |     ------------- `Abc` from trait
68  |     type Npm: Npm;
    |     ------------- `Npm` from trait
69  |     type Npa: Npa;
    |     ------------- `Npa` from trait
70  |
71  |     fn new(code: Vec<u8>, path: &Path, pr: Option<Arc<PreprocResults>>) -> Self;
    |     ---------------------------------------------------------------------------- `new` from trait
72  |     fn get_language(&self) -> LANG;
    |     ------------------------------- `get_language` from trait
73  |     fn get_root(&self) -> Node;
    |     --------------------------- `get_root` from trait
74  |     fn get_code(&self) -> &[u8];
    |     ---------------------------- `get_code` from trait
75  |     fn get_filters(&self, filters: &[String]) -> Filter;
    |     ---------------------------------------------------- `get_filters` from trait
</output>

Function signatures
<Signatures>
fn increment_by_one(stats: &mut Stats) -> ()

pub fn metrics<'a, T: ParserTrait>(parser: &'a T, path: &'a Path) -> Option<FuncSpace>
</Signatures>

You are a software tester at rust-code-analysis and your are reviewing the above <patch> for the above <issue>.
A unit test has already been created for this PR and can be found alongside the filename and the imports used inside the <TEST> block.
It currently fails on codebase after the patch, which the errors in the <output> block.
Your task is to:
1. Identify and understand the errors introduced by the unit test.
2. Update the unit test in the <TEST> block in order for it to fail on the code before the patch, and pass after, hence verifying that the patch resolves the issue.
3. All 'use' declarations must be inside a <imports>...</imports> block. Additionally:
   - Do not use group imports.
  - Import only what is necessary for the test to run and make sure not to have colliding imports.
  - If the <patch> contains a 'mod tests' block with useful imports, do not add them to the <imports> block.
  - Use `use super::<function name> for the function under test.
.  - If multiple 'use' statements are needed, list each on a separate line.
4. To help you write the test, <Signatures> contains all modified function's:
  - name
  - parameters
  - Return type (assume '()' if empty)
5. Return only the absolute filename as it is in the <patch> block, the use statements, and rust test (no comments or explanations).

Follow this expected output format, do not deviate from this structure:
<Filename> ... </Filename>
<imports> ... </imports>
<Rust>
#[test]
fn test_<describe_behavior>() {
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
}</Rust>

