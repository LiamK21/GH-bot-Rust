Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Use a stack approach for cognitive complexity
Currently the cognitive complexity metric analyzes the nodes using ancestors. It would be helpful to analyze the nodes using a stack approach
</issue>

Patch:
<patch>
diff --git a/src/metrics/cognitive.rs b/src/metrics/cognitive.rs
--- a/src/metrics/cognitive.rs
+++ b/src/metrics/cognitive.rs
@@ -1,3 +1,4 @@
+use fxhash::FxHashMap;
 use serde::ser::{SerializeStruct, Serializer};
 use serde::Serialize;
 use std::fmt;
@@ -123,65 +124,28 @@ pub trait Cognitive
 where
     Self: Checker,
 {
-    fn compute(_node: &Node, _stats: &mut Stats) {}
+    fn compute(
+        _node: &Node,
+        _stats: &mut Stats,
+        _nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>,
+    ) {
+    }
 }
 
-macro_rules! compute_booleans {
-    ($node: ident, $stats: ident, $( $typs: pat_param )|*) => {
-        let mut cursor = $node.object().walk();
-        for child in $node.object().children(&mut cursor) {
-            if let $( $typs )|* = child.kind_id().into() {
-                $stats.structural = $stats
-                    .boolean_seq
-                    .eval_based_on_prev(child.kind_id(), $stats.structural);
-            }
+fn compute_booleans<T: std::cmp::PartialEq + std::convert::From<u16>>(
+    node: &Node,
+    stats: &mut Stats,
+    typs1: T,
+    typs2: T,
+) {
+    let mut cursor = node.object().walk();
+    for child in node.object().children(&mut cursor) {
+        if typs1 == child.kind_id().into() || typs2 == child.kind_id().into() {
+            stats.structural = stats
+                .boolean_seq
+                .eval_based_on_prev(child.kind_id(), stats.structural)
         }
-    };
-}
-
-macro_rules! nesting_levels {
-    ($node: ident, $stats: ident, [$nest_func: pat_param => $nest_func_stop: pat_param],
-     [$lambdas: pat => $( $lambdas_stop: pat_param )|*],
-     [$( $nest_level: pat_param )|* => $( $nest_level_stop: pat_param )|*]) => {
-        // Find the depth of a function (the most external function is
-        // not considered)
-        $stats.nesting = count_specific_ancestors!($node, $nest_func, $nest_func_stop).max(1) - 1;
-
-        // Find the depth of a lambda
-        let lambda_depth = count_specific_ancestors!($node, $lambdas, $( $lambdas_stop )|*);
-
-        // Find the nesting operator level
-        $stats.nesting += lambda_depth
-            + count_specific_ancestors!(
-                $node,
-                $( $nest_level )|*,
-                $( $nest_level_stop)|*
-            );
-
-        // Reset the boolean sequence
-        $stats.boolean_seq.reset();
-
-        increment($stats);
-    };
-    ($node: ident, $stats: ident,
-     [$lambdas: pat_param => $( $lambdas_stop: pat_param )|*],
-     [$( $nest_level: pat_param )|* => $( $nest_level_stop: pat_param )|*]) => {
-        // Find the depth of a lambda
-        let lambda_depth = count_specific_ancestors!($node, $lambdas, $( $lambdas_stop )|*);
-
-        // Find the nesting operator level
-        $stats.nesting = lambda_depth
-            + count_specific_ancestors!(
-                $node,
-                $( $nest_level )|*,
-                $( $nest_level_stop)|*
-            );
-
-        // Reset the boolean sequence
-        $stats.boolean_seq.reset();
-
-        increment($stats);
-    };
+    }
 }
 
 #[derive(Debug, Default, Clone)]
@@ -228,18 +192,59 @@ fn increment_by_one(stats: &mut Stats) {
     stats.structural += 1;
 }
 
+fn get_nesting_from_map(
+    node: &Node,
+    nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>,
+) -> (usize, usize, usize) {
+    if let Some(parent) = node.object().parent() {
+        if let Some(n) = nesting_map.get(&parent.id()) {
+            *n
+        } else {
+            (0, 0, 0)
+        }
+    } else {
+        (0, 0, 0)
+    }
+}
+
+fn increment_function_depth<T: std::cmp::PartialEq + std::convert::From<u16>>(
+    depth: &mut usize,
+    node: &Node,
+    stop: T,
+) {
+    // Increase depth function nesting if needed
+    let mut child = node.object();
+    while let Some(parent) = child.parent() {
+        if stop == parent.kind_id().into() {
+            *depth += 1;
+            break;
+        }
+        child = parent;
+    }
+}
+
+#[inline(always)]
+fn increase_nesting(stats: &mut Stats, nesting: &mut usize, depth: usize, lambda: usize) {
+    stats.nesting = *nesting + depth + lambda;
+    increment(stats);
+    *nesting += 1;
+    stats.boolean_seq.reset();
+}
+
 impl Cognitive for PythonCode {
-    fn compute(node: &Node, stats: &mut Stats) {
+    fn compute(
+        node: &Node,
+        stats: &mut Stats,
+        nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>,
+    ) {
         use Python::*;
 
+        // Get nesting of the parent
+        let (mut nesting, mut depth, mut lambda) = get_nesting_from_map(node, nesting_map);
+
         match node.object().kind_id().into() {
             IfStatement | ForStatement | WhileStatement | ConditionalExpression => {
-                nesting_levels!(
-                    node, stats,
-                    [FunctionDefinition => Module],
-                    [Lambda => FunctionDefinition | Module],
-                    [IfStatement | ForStatement | WhileStatement | ExceptClause => FunctionDefinition]
-                );
+                increase_nesting(stats, &mut nesting, depth, lambda);
             }
             ElifClause => {
                 // No nesting increment for them because their cost has already
@@ -254,6 +259,7 @@ impl Cognitive for PythonCode {
                 increment_by_one(stats);
             }
             ExceptClause => {
+                nesting += 1;
                 increment(stats);
             }
             ExpressionList | ExpressionStatement | Tuple => {
@@ -270,38 +276,46 @@ impl Cognitive for PythonCode {
                         ExpressionList | IfStatement | ForStatement | WhileStatement
                     );
                 }
-                compute_booleans!(node, stats, And | Or);
+                compute_booleans::<language_python::Python>(node, stats, And, Or);
+            }
+            Lambda => {
+                // Increase lambda nesting
+                lambda += 1;
+            }
+            FunctionDefinition => {
+                // Increase depth function nesting if needed
+                increment_function_depth::<language_python::Python>(
+                    &mut depth,
+                    node,
+                    FunctionDefinition,
+                );
             }
             _ => {}
         }
+        // Add node to nesting map
+        nesting_map.insert(node.object().id(), (nesting, depth, lambda));
     }
 }
 
 impl Cognitive for RustCode {
-    fn compute(node: &Node, stats: &mut Stats) {
+    fn compute(
+        node: &Node,
+        stats: &mut Stats,
+        nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>,
+    ) {
         use Rust::*;
-
         //TODO: Implement macros
+        let (mut nesting, mut depth, mut lambda) = get_nesting_from_map(node, nesting_map);
 
         match node.object().kind_id().into() {
             IfExpression | IfLetExpression => {
                 // Check if a node is not an else-if
                 if !Self::is_else_if(node) {
-                    nesting_levels!(
-                        node, stats,
-                        [FunctionItem => SourceFile],
-                        [ClosureExpression => SourceFile],
-                        [IfExpression | IfLetExpression | ForExpression | WhileExpression | MatchExpression => FunctionItem]
-                    );
+                    increase_nesting(stats,&mut nesting, depth, lambda);
                 }
             }
             ForExpression | WhileExpression | MatchExpression => {
-                nesting_levels!(
-                    node, stats,
-                    [FunctionItem => SourceFile],
-                    [ClosureExpression => SourceFile],
-                    [IfExpression | IfLetExpression | ForExpression | WhileExpression | MatchExpression => FunctionItem]
-                );
+                increase_nesting(stats,&mut nesting, depth, lambda);
             }
             Else /*else-if also */ => {
                 increment_by_one(stats);
@@ -317,45 +331,41 @@ impl Cognitive for RustCode {
                 stats.boolean_seq.not_operator(node.object().kind_id());
             }
             BinaryExpression => {
-                compute_booleans!(node, stats, AMPAMP | PIPEPIPE);
+                compute_booleans::<language_rust::Rust>(node, stats, AMPAMP, PIPEPIPE);
+            }
+            FunctionItem  => {
+                nesting = 0;
+                // Increase depth function nesting if needed
+                increment_function_depth::<language_rust::Rust>(&mut depth, node, FunctionItem);
+            }
+            ClosureExpression => {
+                lambda += 1;
             }
             _ => {}
         }
+        nesting_map.insert(node.object().id(), (nesting, depth, lambda));
     }
 }
 
 impl Cognitive for CppCode {
-    fn compute(node: &Node, stats: &mut Stats) {
+    fn compute(
+        node: &Node,
+        stats: &mut Stats,
+        nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>,
+    ) {
         use Cpp::*;
 
         //TODO: Implement macros
+        let (mut nesting, depth, mut lambda) = get_nesting_from_map(node, nesting_map);
 
         match node.object().kind_id().into() {
             IfStatement => {
                 if !Self::is_else_if(node) {
-                    nesting_levels!(
-                        node, stats,
-                        [LambdaExpression => TranslationUnit],
-                        [IfStatement
-                            | ForStatement
-                            | WhileStatement
-                            | DoStatement
-                            | SwitchStatement
-                            | CatchClause => FunctionDefinition]
-                    );
+                    increase_nesting(stats,&mut nesting, depth, lambda);
                 }
             }
             ForStatement | WhileStatement | DoStatement | SwitchStatement | CatchClause => {
-                nesting_levels!(
-                    node, stats,
-                    [LambdaExpression => TranslationUnit],
-                    [IfStatement
-                        | ForStatement
-                        | WhileStatement
-                        | DoStatement
-                        | SwitchStatement
-                        | CatchClause => FunctionDefinition]
-                );
+                increase_nesting(stats,&mut nesting, depth, lambda);
             }
             GotoStatement | Else /* else-if also */ => {
                 increment_by_one(stats);
@@ -364,50 +374,31 @@ impl Cognitive for CppCode {
                 stats.boolean_seq.not_operator(node.object().kind_id());
             }
             BinaryExpression2 => {
-                compute_booleans!(node, stats, AMPAMP | PIPEPIPE);
+                compute_booleans::<language_cpp::Cpp>(node, stats, AMPAMP, PIPEPIPE);
+            }
+            LambdaExpression => {
+                lambda += 1;
             }
             _ => {}
         }
+        nesting_map.insert(node.object().id(), (nesting, depth, lambda));
     }
 }
 
 macro_rules! js_cognitive {
     ($lang:ident) => {
-        fn compute(node: &Node, stats: &mut Stats) {
+        fn compute(node: &Node, stats: &mut Stats, nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>) {
             use $lang::*;
+            let (mut nesting, mut depth, mut lambda) = get_nesting_from_map(node, nesting_map);
 
             match node.object().kind_id().into() {
                 IfStatement => {
                     if !Self::is_else_if(&node) {
-                        nesting_levels!(
-                            node, stats,
-                            [FunctionDeclaration => Program],
-                            [ArrowFunction => FunctionDeclaration | Program],
-                            [IfStatement
-                                | ForStatement
-                                | ForInStatement
-                                | WhileStatement
-                                | DoStatement
-                                | SwitchStatement
-                                | CatchClause
-                                | TernaryExpression => FunctionDeclaration]
-                        );
+                        increase_nesting(stats,&mut nesting, depth, lambda);
                     }
                 }
                 ForStatement | ForInStatement | WhileStatement | DoStatement | SwitchStatement | CatchClause | TernaryExpression => {
-                    nesting_levels!(
-                        node, stats,
-                        [FunctionDeclaration => Program],
-                        [ArrowFunction => FunctionDeclaration | Program],
-                        [IfStatement
-                            | ForStatement
-                            | ForInStatement
-                            | WhileStatement
-                            | DoStatement
-                            | SwitchStatement
-                            | CatchClause
-                            | TernaryExpression => FunctionDeclaration]
-                    );
+                    increase_nesting(stats,&mut nesting, depth, lambda);
                 }
                 Else /* else-if also */ => {
                     increment_by_one(stats);
@@ -420,10 +411,21 @@ macro_rules! js_cognitive {
                     stats.boolean_seq.not_operator(node.object().kind_id());
                 }
                 BinaryExpression => {
-                    compute_booleans!(node, stats, AMPAMP | PIPEPIPE);
+                    compute_booleans::<$lang>(node, stats, AMPAMP, PIPEPIPE);
+                }
+                FunctionDeclaration => {
+                    // Reset lambda nesting at function for JS
+                    nesting = 0;
+                    lambda = 0;
+                    // Increase depth function nesting if needed
+                    increment_function_depth::<$lang>(&mut depth, node, FunctionDeclaration);
+                }
+                ArrowFunction => {
+                    lambda += 1;
                 }
                 _ => {}
             }
+            nesting_map.insert(node.object().id(), (nesting, depth, lambda));
         }
     };
 }

diff --git a/src/spaces.rs b/src/spaces.rs
--- a/src/spaces.rs
+++ b/src/spaces.rs
@@ -1,3 +1,4 @@
+use fxhash::FxHashMap;
 use serde::Serialize;
 use std::fmt;
 use std::path::{Path, PathBuf};
@@ -293,7 +294,10 @@ pub fn metrics<'a, T: ParserTrait>(parser: &'a T, path: &'a Path) -> Option<Func
     let mut children = Vec::new();
     let mut state_stack: Vec<State> = Vec::new();
     let mut last_level = 0;
-
+    // Initialize nesting_map used for storing nesting information for cognitive
+    // Three type of nesting info: conditionals, functions and lambdas
+    let mut nesting_map = FxHashMap::<usize, (usize, usize, usize)>::default();
+    nesting_map.insert(node.object().id(), (0, 0, 0));
     stack.push((node, 0));
 
     while let Some((node, level)) = stack.pop() {
@@ -321,7 +325,7 @@ pub fn metrics<'a, T: ParserTrait>(parser: &'a T, path: &'a Path) -> Option<Func
 
         if let Some(state) = state_stack.last_mut() {
             let last = &mut state.space;
-            T::Cognitive::compute(&node, &mut last.metrics.cognitive);
+            T::Cognitive::compute(&node, &mut last.metrics.cognitive, &mut nesting_map);
             T::Cyclomatic::compute(&node, &mut last.metrics.cyclomatic);
             T::Halstead::compute(&node, code, &mut state.halstead_maps);
             T::Loc::compute(&node, &mut last.metrics.loc, func_space, unit);


</patch>

<TEST>
<Filename>src/spaces.rs</Filename>
<imports>use std::path::Path;
use super::metrics;
use crate::traits::ParserTrait;
use crate::metrics::cognitive::{Cognitive, Stats};
use tree_sitter::Node;
use fxhash::FxHashMap;
use crate::FuncSpace;
use crate::LANG;
use std::sync::Arc;
use crate::PreprocResults;
use crate::Filter;</imports>
<Rust>#[test]
fn test_metrics_with_stack_approach() {
    struct MockParser;
    impl ParserTrait for MockParser {
        type Cognitive = MockCognitive;
        type Cyclomatic = MockCyclomatic;
        type Halstead = MockHalstead;
        type Loc = MockLoc;
        type Checker = MockChecker;
        type Getter = MockGetter;
        type Nom = MockNom;
        type Mi = MockMi;
        type NArgs = MockNArgs;
        type Exit = MockExit;
        type Wmc = MockWmc;
        type Abc = MockAbc;
        type Npm = MockNpm;
        type Npa = MockNpa;

        fn new(_code: Vec<u8>, _path: &Path, _pr: Option<Arc<PreprocResults>>) -> Self {
            MockParser
        }
        fn get_language(&self) -> LANG {
            LANG::Rust
        }
        fn get_root(&self) -> Node {
            unimplemented!()
        }
        fn get_code(&self) -> &[u8] {
            unimplemented!()
        }
        fn get_filters(&self, _filters: &[String]) -> Filter {
            unimplemented!()
        }
    }

    struct MockCognitive;
    impl Cognitive for MockCognitive {
        fn compute(node: &Node, stats: &mut Stats, nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>) {
            let (mut nesting, mut depth, mut lambda) = (0, 0, 0);
            if let Some(parent) = node.parent() {
                if let Some(n) = nesting_map.get(&parent.id()) {
                    nesting = n.0;
                    depth = n.1;
                    lambda = n.2;
                }
            }
            nesting += 1;
            stats.nesting = nesting;
            nesting_map.insert(node.id(), (nesting, depth, lambda));
        }
    }

    let parser = MockParser;
    let path = Path::new("test_path");
    let expected = Some(FuncSpace::new());
    let actual = metrics(&parser, &path);
    assert_eq!(expected, actual);
}
</Rust>
</TEST>

<output>
error[E0412]: cannot find type `MockCyclomatic` in this scope
   --> src/spaces.rs:405:27
    |
405 |         type Cyclomatic = MockCyclomatic;
    |                           ^^^^^^^^^^^^^^ not found in this scope

error[E0412]: cannot find type `MockHalstead` in this scope
   --> src/spaces.rs:406:25
    |
406 |         type Halstead = MockHalstead;
    |                         ^^^^^^^^^^^^ not found in this scope

error[E0412]: cannot find type `MockLoc` in this scope
   --> src/spaces.rs:407:20
    |
407 |         type Loc = MockLoc;
    |                    ^^^^^^^ not found in this scope

error[E0412]: cannot find type `MockChecker` in this scope
   --> src/spaces.rs:408:24
    |
408 |         type Checker = MockChecker;
    |                        ^^^^^^^^^^^ not found in this scope

error[E0412]: cannot find type `MockGetter` in this scope
   --> src/spaces.rs:409:23
    |
409 |         type Getter = MockGetter;
    |                       ^^^^^^^^^^ not found in this scope

error[E0412]: cannot find type `MockNom` in this scope
   --> src/spaces.rs:410:20
    |
410 |         type Nom = MockNom;
    |                    ^^^^^^^ not found in this scope

error[E0412]: cannot find type `MockMi` in this scope
   --> src/spaces.rs:411:19
    |
411 |         type Mi = MockMi;
    |                   ^^^^^^ not found in this scope

error[E0412]: cannot find type `MockNArgs` in this scope
   --> src/spaces.rs:412:22
    |
412 |         type NArgs = MockNArgs;
    |                      ^^^^^^^^^ not found in this scope

error[E0412]: cannot find type `MockExit` in this scope
   --> src/spaces.rs:413:21
    |
413 |         type Exit = MockExit;
    |                     ^^^^^^^^ not found in this scope

error[E0412]: cannot find type `MockWmc` in this scope
   --> src/spaces.rs:414:20
    |
414 |         type Wmc = MockWmc;
    |                    ^^^^^^^ not found in this scope

error[E0412]: cannot find type `MockAbc` in this scope
   --> src/spaces.rs:415:20
    |
415 |         type Abc = MockAbc;
    |                    ^^^^^^^ not found in this scope

error[E0412]: cannot find type `MockNpm` in this scope
   --> src/spaces.rs:416:20
    |
416 |         type Npm = MockNpm;
    |                    ^^^^^^^ not found in this scope

error[E0412]: cannot find type `MockNpa` in this scope
   --> src/spaces.rs:417:20
    |
417 |         type Npa = MockNpa;
    |                    ^^^^^^^ not found in this scope

error[E0277]: the trait bound `MockCognitive: checker::Checker` is not satisfied
   --> src/spaces.rs:404:26
    |
404 |         type Cognitive = MockCognitive;
    |                          ^^^^^^^^^^^^^ the trait `checker::Checker` is not implemented for `MockCognitive`
    |
    = help: the following other types implement trait `checker::Checker`:
              langs::CcommentCode
              langs::CppCode
              langs::JavaCode
              langs::JavascriptCode
              langs::MozjsCode
              langs::PreprocCode
              langs::PythonCode
              langs::RustCode
            and 2 others
note: required for `<MockParser as traits::ParserTrait>::Cognitive` to implement `Cognitive`
   --> src/metrics/cognitive.rs:123:11
    |
123 | pub trait Cognitive
    |           ^^^^^^^^^
note: required by a bound in `traits::ParserTrait::Cognitive`
   --> src/traits.rs:58:21
    |
58  |     type Cognitive: Cognitive;
    |                     ^^^^^^^^^ required by this bound in `ParserTrait::Cognitive`

error[E0053]: method `get_root` has an incompatible type for trait
   --> src/spaces.rs:425:31
    |
425 |         fn get_root(&self) -> Node {
    |                               ^^^^ expected `node::Node<'_>`, found `tree_sitter::Node<'_>`
    |
note: type in trait
   --> src/traits.rs:73:27
    |
73  |     fn get_root(&self) -> Node;
    |                           ^^^^
    = note: expected signature `fn(&MockParser) -> node::Node<'_>`
               found signature `fn(&MockParser) -> tree_sitter::Node<'_>`
help: change the output type to match the trait
    |
425 -         fn get_root(&self) -> Node {
425 +         fn get_root(&self) -> node::Node<'_> {
    |

error[E0277]: the trait bound `MockCognitive: checker::Checker` is not satisfied
   --> src/spaces.rs:437:24
    |
437 |     impl Cognitive for MockCognitive {
    |                        ^^^^^^^^^^^^^ the trait `checker::Checker` is not implemented for `MockCognitive`
    |
    = help: the following other types implement trait `checker::Checker`:
              langs::CcommentCode
              langs::CppCode
              langs::JavaCode
              langs::JavascriptCode
              langs::MozjsCode
              langs::PreprocCode
              langs::PythonCode
              langs::RustCode
            and 2 others
note: required by a bound in `Cognitive`
   --> src/metrics/cognitive.rs:125:11
    |
123 | pub trait Cognitive
    |           --------- required by a bound in this trait
124 | where
125 |     Self: Checker,
    |           ^^^^^^^ required by this bound in `Cognitive`
    = note: `Cognitive` is a "sealed trait", because to implement it you also need to implement `checker::Checker`, which is not accessible; this is usually done to force you to use one of the provided types that already implement it
    = help: the following types implement the trait:
              langs::PreprocCode
              langs::CcommentCode
              langs::CppCode
              langs::PythonCode
              langs::JavaCode
              langs::MozjsCode
              langs::JavascriptCode
              langs::TypescriptCode
            and 2 others

error[E0053]: method `compute` has an incompatible type for trait
   --> src/spaces.rs:438:26
    |
438 |         fn compute(node: &Node, stats: &mut Stats, nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>) {
    |                          ^^^^^ expected `node::Node<'_>`, found `tree_sitter::Node<'_>`
    |
note: type in trait
   --> src/metrics/cognitive.rs:128:16
    |
128 |         _node: &Node,
    |                ^^^^^
    = note: expected signature `fn(&node::Node<'_>, &mut metrics::cognitive::Stats, &mut HashMap<_, _, _>)`
               found signature `fn(&tree_sitter::Node<'_>, &mut metrics::cognitive::Stats, &mut HashMap<_, _, _>)`
help: change the parameter type to match the trait
    |
438 -         fn compute(node: &Node, stats: &mut Stats, nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>) {
438 +         fn compute(node: &node::Node<'_>, stats: &mut Stats, nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>) {
    |

error[E0061]: this function takes 3 arguments but 0 arguments were supplied
   --> src/spaces.rs:455:25
    |
455 |     let expected = Some(FuncSpace::new());
    |                         ^^^^^^^^^^^^^^-- three arguments of type `&node::Node<'_>`, `&[u8]`, and `spaces::SpaceKind` are missing
    |
note: associated function defined here
   --> src/spaces.rs:150:8
    |
150 |     fn new<T: Getter>(node: &Node, code: &[u8], kind: SpaceKind) -> Self {
    |        ^^^            -----------  -----------  ---------------
help: provide the arguments
    |
455 |     let expected = Some(FuncSpace::new(/* &node::Node<'_> */, /* &[u8] */, /* spaces::SpaceKind */));
    |                                        +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

error[E0369]: binary operation `==` cannot be applied to type `std::option::Option<spaces::FuncSpace>`
   --> src/spaces.rs:457:5
    |
457 |     assert_eq!(expected, actual);
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |     |
    |     std::option::Option<spaces::FuncSpace>
    |     std::option::Option<spaces::FuncSpace>
    |
note: an implementation of `PartialEq` might be missing for `spaces::FuncSpace`
   --> src/spaces.rs:131:1
    |
131 | pub struct FuncSpace {
    | ^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`
    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider annotating `spaces::FuncSpace` with `#[derive(PartialEq)]`
    |
131 + #[derive(PartialEq)]
132 | pub struct FuncSpace {
    |

error[E0616]: field `nesting` of struct `metrics::cognitive::Stats` is private
   --> src/spaces.rs:448:19
    |
448 |             stats.nesting = nesting;
    |                   ^^^^^^^ private field
</output>

Function signatures
<Signatures>
fn increment_by_one(stats: &mut Stats) -> ()

pub fn metrics<'a, T: ParserTrait>(parser: &'a T, path: &'a Path) -> Option<FuncSpace>
</Signatures>

You are a software tester at rust-code-analysis and your are reviewing the above <patch> for the above <issue>.
A unit test has already been created for this PR and can be found alongside the filename and the imports used inside the <TEST> block.
It currently fails on codebase after the patch, which the errors in the <output> block.
Your task is to:
1. Identify and understand the errors introduced by the unit test.
2. Update the unit test in the <TEST> block in order for it to fail on the code before the patch, and pass after, hence verifying that the patch resolves the issue.
3. All 'use' declarations must be inside a <imports>...</imports> block. Additionally:
   - Do not use group imports.
  - Import only what is necessary for the test to run and make sure not to have colliding imports.
  - If the <patch> contains a 'mod tests' block with useful imports, do not add them to the <imports> block.
  - Use `use super::<function name> for the function under test.
.  - If multiple 'use' statements are needed, list each on a separate line.
4. To help you write the test, <Signatures> contains all modified function's:
  - name
  - parameters
  - Return type (assume '()' if empty)
5. Return only the absolute filename as it is in the <patch> block, the use statements, and rust test (no comments or explanations).

Follow this expected output format, do not deviate from this structure:
<Filename> ... </Filename>
<imports> ... </imports>
<Rust>
#[test]
fn test_<describe_behavior>() {
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
}</Rust>

