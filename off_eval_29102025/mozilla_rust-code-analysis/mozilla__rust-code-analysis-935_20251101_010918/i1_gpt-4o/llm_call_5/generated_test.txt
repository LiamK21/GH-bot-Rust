#[test]
fn test_metrics_with_stack_approach() {
    struct MockParser;
    impl ParserTrait for MockParser {
        type Cognitive = MockCognitive;
        type Cyclomatic = MockCyclomatic;
        type Halstead = MockHalstead;
        type Loc = MockLoc;
        type Checker = MockChecker;
        type Getter = MockGetter;
        type Nom = MockNom;
        type Mi = MockMi;
        type NArgs = MockNArgs;
        type Exit = MockExit;
        type Wmc = MockWmc;
        type Abc = MockAbc;
        type Npm = MockNpm;
        type Npa = MockNpa;

        fn new(_code: Vec<u8>, _path: &Path, _pr: Option<Arc<PreprocResults>>) -> Self {
            MockParser
        }
        fn get_language(&self) -> LANG {
            LANG::Rust
        }
        fn get_root(&self) -> node::Node<'_> {
            unimplemented!()
        }
        fn get_code(&self) -> &[u8] {
            unimplemented!()
        }
        fn get_filters(&self, _filters: &[String]) -> Filter {
            unimplemented!()
        }
    }

    struct MockCognitive;
    impl Checker for MockCognitive {}
    impl Cognitive for MockCognitive {
        fn compute(node: &node::Node<'_>, stats: &mut Stats, nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>) {
            let (mut nesting, mut depth, mut lambda) = (0, 0, 0);
            if let Some(parent) = node.parent() {
                if let Some(n) = nesting_map.get(&parent.id()) {
                    nesting = n.0;
                    depth = n.1;
                    lambda = n.2;
                }
            }
            nesting += 1;
            stats.nesting = nesting;
            nesting_map.insert(node.id(), (nesting, depth, lambda));
        }
    }

    struct MockGetter;
    impl Getter for MockGetter {}

    struct MockCyclomatic;
    impl Checker for MockCyclomatic {}

    struct MockHalstead;
    impl Checker for MockHalstead {}

    struct MockLoc;
    impl Checker for MockLoc {}

    struct MockChecker;
    impl Alterator for MockChecker {}
    impl Checker for MockChecker {}

    struct MockNom;
    impl Checker for MockNom {}

    struct MockMi;
    impl Checker for MockMi {}

    struct MockNArgs;
    impl Checker for MockNArgs {}

    struct MockExit;
    impl Checker for MockExit {}

    struct MockWmc;
    impl Checker for MockWmc {}

    struct MockAbc;
    impl Checker for MockAbc {}

    struct MockNpm;
    impl Checker for MockNpm {}

    struct MockNpa;
    impl Checker for MockNpa {}

    let parser = MockParser;
    let path = Path::new("test_path");
    let node = node::Node::new();
    let code = b"";
    let kind = SpaceKind::Function;
    let expected = Some(FuncSpace::new(&node, code, kind));
    let actual = metrics(&parser, &path);
    assert_eq!(expected, actual);
}