Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Use a stack approach for cognitive complexity
Currently the cognitive complexity metric analyzes the nodes using ancestors. It would be helpful to analyze the nodes using a stack approach
</issue>

Patch:
<patch>
diff --git a/src/metrics/cognitive.rs b/src/metrics/cognitive.rs
--- a/src/metrics/cognitive.rs
+++ b/src/metrics/cognitive.rs
@@ -1,3 +1,4 @@
+use fxhash::FxHashMap;
 use serde::ser::{SerializeStruct, Serializer};
 use serde::Serialize;
 use std::fmt;
@@ -123,65 +124,28 @@ pub trait Cognitive
 where
     Self: Checker,
 {
-    fn compute(_node: &Node, _stats: &mut Stats) {}
+    fn compute(
+        _node: &Node,
+        _stats: &mut Stats,
+        _nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>,
+    ) {
+    }
 }
 
-macro_rules! compute_booleans {
-    ($node: ident, $stats: ident, $( $typs: pat_param )|*) => {
-        let mut cursor = $node.object().walk();
-        for child in $node.object().children(&mut cursor) {
-            if let $( $typs )|* = child.kind_id().into() {
-                $stats.structural = $stats
-                    .boolean_seq
-                    .eval_based_on_prev(child.kind_id(), $stats.structural);
-            }
+fn compute_booleans<T: std::cmp::PartialEq + std::convert::From<u16>>(
+    node: &Node,
+    stats: &mut Stats,
+    typs1: T,
+    typs2: T,
+) {
+    let mut cursor = node.object().walk();
+    for child in node.object().children(&mut cursor) {
+        if typs1 == child.kind_id().into() || typs2 == child.kind_id().into() {
+            stats.structural = stats
+                .boolean_seq
+                .eval_based_on_prev(child.kind_id(), stats.structural)
         }
-    };
-}
-
-macro_rules! nesting_levels {
-    ($node: ident, $stats: ident, [$nest_func: pat_param => $nest_func_stop: pat_param],
-     [$lambdas: pat => $( $lambdas_stop: pat_param )|*],
-     [$( $nest_level: pat_param )|* => $( $nest_level_stop: pat_param )|*]) => {
-        // Find the depth of a function (the most external function is
-        // not considered)
-        $stats.nesting = count_specific_ancestors!($node, $nest_func, $nest_func_stop).max(1) - 1;
-
-        // Find the depth of a lambda
-        let lambda_depth = count_specific_ancestors!($node, $lambdas, $( $lambdas_stop )|*);
-
-        // Find the nesting operator level
-        $stats.nesting += lambda_depth
-            + count_specific_ancestors!(
-                $node,
-                $( $nest_level )|*,
-                $( $nest_level_stop)|*
-            );
-
-        // Reset the boolean sequence
-        $stats.boolean_seq.reset();
-
-        increment($stats);
-    };
-    ($node: ident, $stats: ident,
-     [$lambdas: pat_param => $( $lambdas_stop: pat_param )|*],
-     [$( $nest_level: pat_param )|* => $( $nest_level_stop: pat_param )|*]) => {
-        // Find the depth of a lambda
-        let lambda_depth = count_specific_ancestors!($node, $lambdas, $( $lambdas_stop )|*);
-
-        // Find the nesting operator level
-        $stats.nesting = lambda_depth
-            + count_specific_ancestors!(
-                $node,
-                $( $nest_level )|*,
-                $( $nest_level_stop)|*
-            );
-
-        // Reset the boolean sequence
-        $stats.boolean_seq.reset();
-
-        increment($stats);
-    };
+    }
 }
 
 #[derive(Debug, Default, Clone)]
@@ -228,18 +192,59 @@ fn increment_by_one(stats: &mut Stats) {
     stats.structural += 1;
 }
 
+fn get_nesting_from_map(
+    node: &Node,
+    nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>,
+) -> (usize, usize, usize) {
+    if let Some(parent) = node.object().parent() {
+        if let Some(n) = nesting_map.get(&parent.id()) {
+            *n
+        } else {
+            (0, 0, 0)
+        }
+    } else {
+        (0, 0, 0)
+    }
+}
+
+fn increment_function_depth<T: std::cmp::PartialEq + std::convert::From<u16>>(
+    depth: &mut usize,
+    node: &Node,
+    stop: T,
+) {
+    // Increase depth function nesting if needed
+    let mut child = node.object();
+    while let Some(parent) = child.parent() {
+        if stop == parent.kind_id().into() {
+            *depth += 1;
+            break;
+        }
+        child = parent;
+    }
+}
+
+#[inline(always)]
+fn increase_nesting(stats: &mut Stats, nesting: &mut usize, depth: usize, lambda: usize) {
+    stats.nesting = *nesting + depth + lambda;
+    increment(stats);
+    *nesting += 1;
+    stats.boolean_seq.reset();
+}
+
 impl Cognitive for PythonCode {
-    fn compute(node: &Node, stats: &mut Stats) {
+    fn compute(
+        node: &Node,
+        stats: &mut Stats,
+        nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>,
+    ) {
         use Python::*;
 
+        // Get nesting of the parent
+        let (mut nesting, mut depth, mut lambda) = get_nesting_from_map(node, nesting_map);
+
         match node.object().kind_id().into() {
             IfStatement | ForStatement | WhileStatement | ConditionalExpression => {
-                nesting_levels!(
-                    node, stats,
-                    [FunctionDefinition => Module],
-                    [Lambda => FunctionDefinition | Module],
-                    [IfStatement | ForStatement | WhileStatement | ExceptClause => FunctionDefinition]
-                );
+                increase_nesting(stats, &mut nesting, depth, lambda);
             }
             ElifClause => {
                 // No nesting increment for them because their cost has already
@@ -254,6 +259,7 @@ impl Cognitive for PythonCode {
                 increment_by_one(stats);
             }
             ExceptClause => {
+                nesting += 1;
                 increment(stats);
             }
             ExpressionList | ExpressionStatement | Tuple => {
@@ -270,38 +276,46 @@ impl Cognitive for PythonCode {
                         ExpressionList | IfStatement | ForStatement | WhileStatement
                     );
                 }
-                compute_booleans!(node, stats, And | Or);
+                compute_booleans::<language_python::Python>(node, stats, And, Or);
+            }
+            Lambda => {
+                // Increase lambda nesting
+                lambda += 1;
+            }
+            FunctionDefinition => {
+                // Increase depth function nesting if needed
+                increment_function_depth::<language_python::Python>(
+                    &mut depth,
+                    node,
+                    FunctionDefinition,
+                );
             }
             _ => {}
         }
+        // Add node to nesting map
+        nesting_map.insert(node.object().id(), (nesting, depth, lambda));
     }
 }
 
 impl Cognitive for RustCode {
-    fn compute(node: &Node, stats: &mut Stats) {
+    fn compute(
+        node: &Node,
+        stats: &mut Stats,
+        nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>,
+    ) {
         use Rust::*;
-
         //TODO: Implement macros
+        let (mut nesting, mut depth, mut lambda) = get_nesting_from_map(node, nesting_map);
 
         match node.object().kind_id().into() {
             IfExpression | IfLetExpression => {
                 // Check if a node is not an else-if
                 if !Self::is_else_if(node) {
-                    nesting_levels!(
-                        node, stats,
-                        [FunctionItem => SourceFile],
-                        [ClosureExpression => SourceFile],
-                        [IfExpression | IfLetExpression | ForExpression | WhileExpression | MatchExpression => FunctionItem]
-                    );
+                    increase_nesting(stats,&mut nesting, depth, lambda);
                 }
             }
             ForExpression | WhileExpression | MatchExpression => {
-                nesting_levels!(
-                    node, stats,
-                    [FunctionItem => SourceFile],
-                    [ClosureExpression => SourceFile],
-                    [IfExpression | IfLetExpression | ForExpression | WhileExpression | MatchExpression => FunctionItem]
-                );
+                increase_nesting(stats,&mut nesting, depth, lambda);
             }
             Else /*else-if also */ => {
                 increment_by_one(stats);
@@ -317,45 +331,41 @@ impl Cognitive for RustCode {
                 stats.boolean_seq.not_operator(node.object().kind_id());
             }
             BinaryExpression => {
-                compute_booleans!(node, stats, AMPAMP | PIPEPIPE);
+                compute_booleans::<language_rust::Rust>(node, stats, AMPAMP, PIPEPIPE);
+            }
+            FunctionItem  => {
+                nesting = 0;
+                // Increase depth function nesting if needed
+                increment_function_depth::<language_rust::Rust>(&mut depth, node, FunctionItem);
+            }
+            ClosureExpression => {
+                lambda += 1;
             }
             _ => {}
         }
+        nesting_map.insert(node.object().id(), (nesting, depth, lambda));
     }
 }
 
 impl Cognitive for CppCode {
-    fn compute(node: &Node, stats: &mut Stats) {
+    fn compute(
+        node: &Node,
+        stats: &mut Stats,
+        nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>,
+    ) {
         use Cpp::*;
 
         //TODO: Implement macros
+        let (mut nesting, depth, mut lambda) = get_nesting_from_map(node, nesting_map);
 
         match node.object().kind_id().into() {
             IfStatement => {
                 if !Self::is_else_if(node) {
-                    nesting_levels!(
-                        node, stats,
-                        [LambdaExpression => TranslationUnit],
-                        [IfStatement
-                            | ForStatement
-                            | WhileStatement
-                            | DoStatement
-                            | SwitchStatement
-                            | CatchClause => FunctionDefinition]
-                    );
+                    increase_nesting(stats,&mut nesting, depth, lambda);
                 }
             }
             ForStatement | WhileStatement | DoStatement | SwitchStatement | CatchClause => {
-                nesting_levels!(
-                    node, stats,
-                    [LambdaExpression => TranslationUnit],
-                    [IfStatement
-                        | ForStatement
-                        | WhileStatement
-                        | DoStatement
-                        | SwitchStatement
-                        | CatchClause => FunctionDefinition]
-                );
+                increase_nesting(stats,&mut nesting, depth, lambda);
             }
             GotoStatement | Else /* else-if also */ => {
                 increment_by_one(stats);
@@ -364,50 +374,31 @@ impl Cognitive for CppCode {
                 stats.boolean_seq.not_operator(node.object().kind_id());
             }
             BinaryExpression2 => {
-                compute_booleans!(node, stats, AMPAMP | PIPEPIPE);
+                compute_booleans::<language_cpp::Cpp>(node, stats, AMPAMP, PIPEPIPE);
+            }
+            LambdaExpression => {
+                lambda += 1;
             }
             _ => {}
         }
+        nesting_map.insert(node.object().id(), (nesting, depth, lambda));
     }
 }
 
 macro_rules! js_cognitive {
     ($lang:ident) => {
-        fn compute(node: &Node, stats: &mut Stats) {
+        fn compute(node: &Node, stats: &mut Stats, nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>) {
             use $lang::*;
+            let (mut nesting, mut depth, mut lambda) = get_nesting_from_map(node, nesting_map);
 
             match node.object().kind_id().into() {
                 IfStatement => {
                     if !Self::is_else_if(&node) {
-                        nesting_levels!(
-                            node, stats,
-                            [FunctionDeclaration => Program],
-                            [ArrowFunction => FunctionDeclaration | Program],
-                            [IfStatement
-                                | ForStatement
-                                | ForInStatement
-                                | WhileStatement
-                                | DoStatement
-                                | SwitchStatement
-                                | CatchClause
-                                | TernaryExpression => FunctionDeclaration]
-                        );
+                        increase_nesting(stats,&mut nesting, depth, lambda);
                     }
                 }
                 ForStatement | ForInStatement | WhileStatement | DoStatement | SwitchStatement | CatchClause | TernaryExpression => {
-                    nesting_levels!(
-                        node, stats,
-                        [FunctionDeclaration => Program],
-                        [ArrowFunction => FunctionDeclaration | Program],
-                        [IfStatement
-                            | ForStatement
-                            | ForInStatement
-                            | WhileStatement
-                            | DoStatement
-                            | SwitchStatement
-                            | CatchClause
-                            | TernaryExpression => FunctionDeclaration]
-                    );
+                    increase_nesting(stats,&mut nesting, depth, lambda);
                 }
                 Else /* else-if also */ => {
                     increment_by_one(stats);
@@ -420,10 +411,21 @@ macro_rules! js_cognitive {
                     stats.boolean_seq.not_operator(node.object().kind_id());
                 }
                 BinaryExpression => {
-                    compute_booleans!(node, stats, AMPAMP | PIPEPIPE);
+                    compute_booleans::<$lang>(node, stats, AMPAMP, PIPEPIPE);
+                }
+                FunctionDeclaration => {
+                    // Reset lambda nesting at function for JS
+                    nesting = 0;
+                    lambda = 0;
+                    // Increase depth function nesting if needed
+                    increment_function_depth::<$lang>(&mut depth, node, FunctionDeclaration);
+                }
+                ArrowFunction => {
+                    lambda += 1;
                 }
                 _ => {}
             }
+            nesting_map.insert(node.object().id(), (nesting, depth, lambda));
         }
     };
 }

diff --git a/src/spaces.rs b/src/spaces.rs
--- a/src/spaces.rs
+++ b/src/spaces.rs
@@ -1,3 +1,4 @@
+use fxhash::FxHashMap;
 use serde::Serialize;
 use std::fmt;
 use std::path::{Path, PathBuf};
@@ -293,7 +294,10 @@ pub fn metrics<'a, T: ParserTrait>(parser: &'a T, path: &'a Path) -> Option<Func
     let mut children = Vec::new();
     let mut state_stack: Vec<State> = Vec::new();
     let mut last_level = 0;
-
+    // Initialize nesting_map used for storing nesting information for cognitive
+    // Three type of nesting info: conditionals, functions and lambdas
+    let mut nesting_map = FxHashMap::<usize, (usize, usize, usize)>::default();
+    nesting_map.insert(node.object().id(), (0, 0, 0));
     stack.push((node, 0));
 
     while let Some((node, level)) = stack.pop() {
@@ -321,7 +325,7 @@ pub fn metrics<'a, T: ParserTrait>(parser: &'a T, path: &'a Path) -> Option<Func
 
         if let Some(state) = state_stack.last_mut() {
             let last = &mut state.space;
-            T::Cognitive::compute(&node, &mut last.metrics.cognitive);
+            T::Cognitive::compute(&node, &mut last.metrics.cognitive, &mut nesting_map);
             T::Cyclomatic::compute(&node, &mut last.metrics.cyclomatic);
             T::Halstead::compute(&node, code, &mut state.halstead_maps);
             T::Loc::compute(&node, &mut last.metrics.loc, func_space, unit);


</patch>

<TEST>
<Filename>src/spaces.rs</Filename>
<imports>use std::path::Path;
use super::metrics;
use crate::traits::ParserTrait;
use crate::metrics::cognitive::{Cognitive, Stats};
use tree_sitter::Node;
use fxhash::FxHashMap;</imports>
<Rust>#[test]
fn test_metrics_with_stack_approach() {
    struct MockParser;
    impl ParserTrait for MockParser {
        type Cognitive = MockCognitive;
        type Cyclomatic = ();
        type Halstead = ();
        type Loc = ();
        type Checker = ();
        type Getter = ();
        type Nom = ();
        type Mi = ();
        type NArgs = ();
        type Exit = ();
        type Wmc = ();
        type Abc = ();
        type Npm = ();
        type Npa = ();

        fn new(_code: Vec<u8>, _path: &Path, _pr: Option<std::sync::Arc<crate::PreprocResults>>) -> Self {
            MockParser
        }
        fn get_language(&self) -> crate::LANG {
            crate::LANG::Rust
        }
        fn get_root(&self) -> Node {
            unimplemented!()
        }
        fn get_code(&self) -> &[u8] {
            unimplemented!()
        }
        fn get_filters(&self, _filters: &[String]) -> crate::Filter {
            unimplemented!()
        }
    }

    struct MockCognitive;
    impl Cognitive for MockCognitive {
        fn compute(node: &Node, stats: &mut Stats, nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>) {
            let (mut nesting, mut depth, mut lambda) = crate::metrics::cognitive::get_nesting_from_map(node, nesting_map);
            nesting += 1;
            stats.nesting = nesting;
            nesting_map.insert(node.object().id(), (nesting, depth, lambda));
        }
    }

    let parser = MockParser;
    let path = Path::new("test_path");
    let expected = Some(crate::FuncSpace::default());
    let actual = metrics(&parser, &path);
    assert_eq!(expected, actual);
}
</Rust>
</TEST>

<output>
error[E0603]: function `get_nesting_from_map` is private
   --> src/spaces.rs:434:83
    |
434 |             let (mut nesting, mut depth, mut lambda) = crate::metrics::cognitive::get_nesting_from_map(node, nesting_map);
    |                                                                                   ^^^^^^^^^^^^^^^^^^^^ private function
    |
note: the function `get_nesting_from_map` is defined here
   --> src/metrics/cognitive.rs:195:1
    |
195 | / fn get_nesting_from_map(
196 | |     node: &Node,
197 | |     nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>,
198 | | ) -> (usize, usize, usize) {
...   |
208 | | }
    | |_^

error[E0277]: the trait bound `MockCognitive: checker::Checker` is not satisfied
   --> src/spaces.rs:399:26
    |
399 |         type Cognitive = MockCognitive;
    |                          ^^^^^^^^^^^^^ the trait `checker::Checker` is not implemented for `MockCognitive`
    |
    = help: the following other types implement trait `checker::Checker`:
              langs::CcommentCode
              langs::CppCode
              langs::JavaCode
              langs::JavascriptCode
              langs::MozjsCode
              langs::PreprocCode
              langs::PythonCode
              langs::RustCode
            and 2 others
note: required for `<MockParser as traits::ParserTrait>::Cognitive` to implement `Cognitive`
   --> src/metrics/cognitive.rs:123:11
    |
123 | pub trait Cognitive
    |           ^^^^^^^^^
note: required by a bound in `traits::ParserTrait::Cognitive`
   --> src/traits.rs:58:21
    |
58  |     type Cognitive: Cognitive;
    |                     ^^^^^^^^^ required by this bound in `ParserTrait::Cognitive`

error[E0277]: the trait bound `(): Cyclomatic` is not satisfied
   --> src/spaces.rs:400:27
    |
400 |         type Cyclomatic = ();
    |                           ^^ the trait `Cyclomatic` is not implemented for `()`
    |
    = help: the following other types implement trait `Cyclomatic`:
              langs::CcommentCode
              langs::CppCode
              langs::JavaCode
              langs::JavascriptCode
              langs::MozjsCode
              langs::PreprocCode
              langs::PythonCode
              langs::RustCode
            and 2 others
note: required by a bound in `traits::ParserTrait::Cyclomatic`
   --> src/traits.rs:59:22
    |
59  |     type Cyclomatic: Cyclomatic;
    |                      ^^^^^^^^^^ required by this bound in `ParserTrait::Cyclomatic`

error[E0277]: the trait bound `(): Halstead` is not satisfied
   --> src/spaces.rs:401:25
    |
401 |         type Halstead = ();
    |                         ^^ the trait `Halstead` is not implemented for `()`
    |
    = help: the following other types implement trait `Halstead`:
              langs::CcommentCode
              langs::CppCode
              langs::JavaCode
              langs::JavascriptCode
              langs::MozjsCode
              langs::PreprocCode
              langs::PythonCode
              langs::RustCode
            and 2 others
note: required by a bound in `traits::ParserTrait::Halstead`
   --> src/traits.rs:60:20
    |
60  |     type Halstead: Halstead;
    |                    ^^^^^^^^ required by this bound in `ParserTrait::Halstead`

error[E0277]: the trait bound `(): Loc` is not satisfied
   --> src/spaces.rs:402:20
    |
402 |         type Loc = ();
    |                    ^^ the trait `Loc` is not implemented for `()`
    |
    = help: the following other types implement trait `Loc`:
              langs::CcommentCode
              langs::CppCode
              langs::JavaCode
              langs::JavascriptCode
              langs::MozjsCode
              langs::PreprocCode
              langs::PythonCode
              langs::RustCode
            and 2 others
note: required by a bound in `traits::ParserTrait::Loc`
   --> src/traits.rs:61:15
    |
61  |     type Loc: Loc;
    |               ^^^ required by this bound in `ParserTrait::Loc`

error[E0277]: the trait bound `(): alterator::Alterator` is not satisfied
   --> src/spaces.rs:403:24
    |
403 |         type Checker = ();
    |                        ^^ the trait `alterator::Alterator` is not implemented for `()`
    |
    = help: the following other types implement trait `alterator::Alterator`:
              langs::CcommentCode
              langs::CppCode
              langs::JavaCode
              langs::JavascriptCode
              langs::MozjsCode
              langs::PreprocCode
              langs::PythonCode
              langs::RustCode
            and 2 others
note: required by a bound in `traits::ParserTrait::Checker`
   --> src/traits.rs:56:19
    |
56  |     type Checker: Alterator + Checker;
    |                   ^^^^^^^^^ required by this bound in `ParserTrait::Checker`

error[E0277]: the trait bound `(): Getter` is not satisfied
   --> src/spaces.rs:404:23
    |
404 |         type Getter = ();
    |                       ^^ the trait `Getter` is not implemented for `()`
    |
    = help: the following other types implement trait `Getter`:
              langs::CcommentCode
              langs::CppCode
              langs::JavaCode
              langs::JavascriptCode
              langs::MozjsCode
              langs::PreprocCode
              langs::PythonCode
              langs::RustCode
            and 2 others
note: required by a bound in `traits::ParserTrait::Getter`
   --> src/traits.rs:57:18
    |
57  |     type Getter: Getter;
    |                  ^^^^^^ required by this bound in `ParserTrait::Getter`

error[E0277]: the trait bound `(): Nom` is not satisfied
   --> src/spaces.rs:405:20
    |
405 |         type Nom = ();
    |                    ^^ the trait `Nom` is not implemented for `()`
    |
    = help: the following other types implement trait `Nom`:
              langs::CcommentCode
              langs::CppCode
              langs::JavaCode
              langs::JavascriptCode
              langs::MozjsCode
              langs::PreprocCode
              langs::PythonCode
              langs::RustCode
            and 2 others
note: required by a bound in `traits::ParserTrait::Nom`
   --> src/traits.rs:62:15
    |
62  |     type Nom: Nom;
    |               ^^^ required by this bound in `ParserTrait::Nom`

error[E0277]: the trait bound `(): Mi` is not satisfied
   --> src/spaces.rs:406:19
    |
406 |         type Mi = ();
    |                   ^^ the trait `Mi` is not implemented for `()`
    |
    = help: the following other types implement trait `Mi`:
              langs::CcommentCode
              langs::CppCode
              langs::JavaCode
              langs::JavascriptCode
              langs::MozjsCode
              langs::PreprocCode
              langs::PythonCode
              langs::RustCode
            and 2 others
note: required by a bound in `traits::ParserTrait::Mi`
   --> src/traits.rs:63:14
    |
63  |     type Mi: Mi;
    |              ^^ required by this bound in `ParserTrait::Mi`

error[E0277]: the trait bound `(): NArgs` is not satisfied
   --> src/spaces.rs:407:22
    |
407 |         type NArgs = ();
    |                      ^^ the trait `NArgs` is not implemented for `()`
    |
    = help: the following other types implement trait `NArgs`:
              langs::CcommentCode
              langs::CppCode
              langs::JavaCode
              langs::JavascriptCode
              langs::MozjsCode
              langs::PreprocCode
              langs::PythonCode
              langs::RustCode
            and 2 others
note: required by a bound in `traits::ParserTrait::NArgs`
   --> src/traits.rs:64:17
    |
64  |     type NArgs: NArgs;
    |                 ^^^^^ required by this bound in `ParserTrait::NArgs`

error[E0277]: the trait bound `(): Exit` is not satisfied
   --> src/spaces.rs:408:21
    |
408 |         type Exit = ();
    |                     ^^ the trait `Exit` is not implemented for `()`
    |
    = help: the following other types implement trait `Exit`:
              langs::CcommentCode
              langs::CppCode
              langs::JavaCode
              langs::JavascriptCode
              langs::MozjsCode
              langs::PreprocCode
              langs::PythonCode
              langs::RustCode
            and 2 others
note: required by a bound in `traits::ParserTrait::Exit`
   --> src/traits.rs:65:16
    |
65  |     type Exit: Exit;
    |                ^^^^ required by this bound in `ParserTrait::Exit`

error[E0277]: the trait bound `(): Wmc` is not satisfied
   --> src/spaces.rs:409:20
    |
409 |         type Wmc = ();
    |                    ^^ the trait `Wmc` is not implemented for `()`
    |
    = help: the following other types implement trait `Wmc`:
              langs::CcommentCode
              langs::CppCode
              langs::JavaCode
              langs::JavascriptCode
              langs::MozjsCode
              langs::PreprocCode
              langs::PythonCode
              langs::RustCode
            and 2 others
note: required by a bound in `traits::ParserTrait::Wmc`
   --> src/traits.rs:66:15
    |
66  |     type Wmc: Wmc;
    |               ^^^ required by this bound in `ParserTrait::Wmc`

error[E0277]: the trait bound `(): Abc` is not satisfied
   --> src/spaces.rs:410:20
    |
410 |         type Abc = ();
    |                    ^^ the trait `Abc` is not implemented for `()`
    |
    = help: the following other types implement trait `Abc`:
              langs::CcommentCode
              langs::CppCode
              langs::JavaCode
              langs::JavascriptCode
              langs::MozjsCode
              langs::PreprocCode
              langs::PythonCode
              langs::RustCode
            and 2 others
note: required by a bound in `traits::ParserTrait::Abc`
   --> src/traits.rs:67:15
    |
67  |     type Abc: Abc;
    |               ^^^ required by this bound in `ParserTrait::Abc`

error[E0277]: the trait bound `(): Npm` is not satisfied
   --> src/spaces.rs:411:20
    |
411 |         type Npm = ();
    |                    ^^ the trait `Npm` is not implemented for `()`
    |
    = help: the following other types implement trait `Npm`:
              langs::CcommentCode
              langs::CppCode
              langs::JavaCode
              langs::JavascriptCode
              langs::MozjsCode
              langs::PreprocCode
              langs::PythonCode
              langs::RustCode
            and 2 others
note: required by a bound in `traits::ParserTrait::Npm`
   --> src/traits.rs:68:15
    |
68  |     type Npm: Npm;
    |               ^^^ required by this bound in `ParserTrait::Npm`

error[E0277]: the trait bound `(): Npa` is not satisfied
   --> src/spaces.rs:412:20
    |
412 |         type Npa = ();
    |                    ^^ the trait `Npa` is not implemented for `()`
    |
    = help: the following other types implement trait `Npa`:
              langs::CcommentCode
              langs::CppCode
              langs::JavaCode
              langs::JavascriptCode
              langs::MozjsCode
              langs::PreprocCode
              langs::PythonCode
              langs::RustCode
            and 2 others
note: required by a bound in `traits::ParserTrait::Npa`
   --> src/traits.rs:69:15
    |
69  |     type Npa: Npa;
    |               ^^^ required by this bound in `ParserTrait::Npa`

error[E0053]: method `get_root` has an incompatible type for trait
   --> src/spaces.rs:420:31
    |
420 |         fn get_root(&self) -> Node {
    |                               ^^^^ expected `node::Node<'_>`, found `tree_sitter::Node<'_>`
    |
note: type in trait
   --> src/traits.rs:73:27
    |
73  |     fn get_root(&self) -> Node;
    |                           ^^^^
    = note: expected signature `fn(&MockParser) -> node::Node<'_>`
               found signature `fn(&MockParser) -> tree_sitter::Node<'_>`
help: change the output type to match the trait
    |
420 -         fn get_root(&self) -> Node {
420 +         fn get_root(&self) -> node::Node<'_> {
    |

error[E0277]: the trait bound `MockCognitive: checker::Checker` is not satisfied
   --> src/spaces.rs:432:24
    |
432 |     impl Cognitive for MockCognitive {
    |                        ^^^^^^^^^^^^^ the trait `checker::Checker` is not implemented for `MockCognitive`
    |
    = help: the following other types implement trait `checker::Checker`:
              langs::CcommentCode
              langs::CppCode
              langs::JavaCode
              langs::JavascriptCode
              langs::MozjsCode
              langs::PreprocCode
              langs::PythonCode
              langs::RustCode
            and 2 others
note: required by a bound in `Cognitive`
   --> src/metrics/cognitive.rs:125:11
    |
123 | pub trait Cognitive
    |           --------- required by a bound in this trait
124 | where
125 |     Self: Checker,
    |           ^^^^^^^ required by this bound in `Cognitive`
    = note: `Cognitive` is a "sealed trait", because to implement it you also need to implement `checker::Checker`, which is not accessible; this is usually done to force you to use one of the provided types that already implement it
    = help: the following types implement the trait:
              langs::PreprocCode
              langs::CcommentCode
              langs::CppCode
              langs::PythonCode
              langs::JavaCode
              langs::MozjsCode
              langs::JavascriptCode
              langs::TypescriptCode
            and 2 others

error[E0053]: method `compute` has an incompatible type for trait
   --> src/spaces.rs:433:26
    |
433 |         fn compute(node: &Node, stats: &mut Stats, nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>) {
    |                          ^^^^^ expected `node::Node<'_>`, found `tree_sitter::Node<'_>`
    |
note: type in trait
   --> src/metrics/cognitive.rs:128:16
    |
128 |         _node: &Node,
    |                ^^^^^
    = note: expected signature `fn(&node::Node<'_>, &mut metrics::cognitive::Stats, &mut HashMap<_, _, _>)`
               found signature `fn(&tree_sitter::Node<'_>, &mut metrics::cognitive::Stats, &mut HashMap<_, _, _>)`
help: change the parameter type to match the trait
    |
433 -         fn compute(node: &Node, stats: &mut Stats, nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>) {
433 +         fn compute(node: &node::Node<'_>, stats: &mut Stats, nesting_map: &mut FxHashMap<usize, (usize, usize, usize)>) {
    |

error[E0599]: no function or associated item named `default` found for struct `spaces::FuncSpace` in the current scope
   --> src/spaces.rs:443:43
    |
131 | pub struct FuncSpace {
    | -------------------- function or associated item `default` not found for this struct
...
443 |     let expected = Some(crate::FuncSpace::default());
    |                                           ^^^^^^^ function or associated item not found in `spaces::FuncSpace`
    |
note: if you're trying to build a new `spaces::FuncSpace`, consider using `spaces::FuncSpace::new` which returns `spaces::FuncSpace`
   --> src/spaces.rs:150:5
    |
150 |     fn new<T: Getter>(node: &Node, code: &[u8], kind: SpaceKind) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `std::default::Default`

error[E0308]: mismatched types
   --> src/spaces.rs:434:104
    |
434 |             let (mut nesting, mut depth, mut lambda) = crate::metrics::cognitive::get_nesting_from_map(node, nesting_map);
    |                                                        ----------------------------------------------- ^^^^ expected `node::Node<'_>`, found `tree_sitter::Node<'_>`
    |                                                        |
    |                                                        arguments to this function are incorrect
    |
    = note: `tree_sitter::Node<'_>` and `node::Node<'_>` have similar names, but are actually distinct types
note: `tree_sitter::Node<'_>` is defined in crate `tree_sitter`
   --> /usr/local/cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tree-sitter-0.19.3/binding_rust/lib.rs:75:1
    |
75  | pub struct Node<'a>(ffi::TSNode, PhantomData<&'a ()>);
    | ^^^^^^^^^^^^^^^^^^^
note: `node::Node<'_>` is defined in the current crate
   --> src/node.rs:7:1
    |
7   | pub struct Node<'a>(OtherNode<'a>);
    | ^^^^^^^^^^^^^^^^^^^
note: function defined here
   --> src/metrics/cognitive.rs:195:4
    |
195 | fn get_nesting_from_map(
    |    ^^^^^^^^^^^^^^^^^^^^
196 |     node: &Node,
    |     -----------

error[E0616]: field `nesting` of struct `metrics::cognitive::Stats` is private
   --> src/spaces.rs:436:19
    |
436 |             stats.nesting = nesting;
    |                   ^^^^^^^ private field

error[E0599]: no method named `object` found for reference `&tree_sitter::Node<'_>` in the current scope
   --> src/spaces.rs:437:37
    |
437 |             nesting_map.insert(node.object().id(), (nesting, depth, lambda));
    |                                     ^^^^^^ method not found in `&tree_sitter::Node<'_>`
</output>

Function signatures
<Signatures>
fn increment_by_one(stats: &mut Stats) -> ()

pub fn metrics<'a, T: ParserTrait>(parser: &'a T, path: &'a Path) -> Option<FuncSpace>
</Signatures>

You are a software tester at rust-code-analysis and your are reviewing the above <patch> for the above <issue>.
A unit test has already been created for this PR and can be found alongside the filename and the imports used inside the <TEST> block.
It currently fails on codebase after the patch, which the errors in the <output> block.
Your task is to:
1. Identify and understand the errors introduced by the unit test.
2. Update the unit test in the <TEST> block in order for it to fail on the code before the patch, and pass after, hence verifying that the patch resolves the issue.
3. All 'use' declarations must be inside a <imports>...</imports> block. Additionally:
   - Do not use group imports.
  - Import only what is necessary for the test to run and make sure not to have colliding imports.
  - If the <patch> contains a 'mod tests' block with useful imports, do not add them to the <imports> block.
  - Use `use super::<function name> for the function under test.
.  - If multiple 'use' statements are needed, list each on a separate line.
4. To help you write the test, <Signatures> contains all modified function's:
  - name
  - parameters
  - Return type (assume '()' if empty)
5. Return only the absolute filename as it is in the <patch> block, the use statements, and rust test (no comments or explanations).

Follow this expected output format, do not deviate from this structure:
<Filename> ... </Filename>
<imports> ... </imports>
<Rust>
#[test]
fn test_<describe_behavior>() {
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
}</Rust>

