<Filename>src/spaces.rs</Filename>
<imports>
use super::compute_minmax;
use crate::spaces::State;
use crate::metrics::cyclomatic::Stats as CyclomaticStats;
use crate::metrics::exit::Stats as ExitStats;
use crate::FuncSpace;
</imports>
<Rust>
#[test]
fn test_compute_minmax_updates_minmax_values() {
    let mut state = State {
        space: FuncSpace::default(),
        halstead_maps: Default::default(),
    };

    state.space.metrics.cyclomatic = CyclomaticStats::default();
    state.space.metrics.cyclomatic.compute_minmax();

    state.space.metrics.nexits = ExitStats {
        exit: 3,
        exit_sum: 10,
        exit_min: 5,
        exit_max: 15,
        total_space_functions: 1,
    };
    state.space.metrics.nexits.compute_minmax();

    let expected_cyclomatic_min = state.space.metrics.cyclomatic.cyclomatic_min();
    let expected_cyclomatic_max = state.space.metrics.cyclomatic.cyclomatic_max();
    let expected_exit_min = 3.0;
    let expected_exit_max = 15.0;

    compute_minmax(&mut state);

    assert_eq!(state.space.metrics.cyclomatic.cyclomatic_min(), expected_cyclomatic_min);
    assert_eq!(state.space.metrics.cyclomatic.cyclomatic_max(), expected_cyclomatic_max);
    assert_eq!(state.space.metrics.nexits.exit_min(), expected_exit_min);
    assert_eq!(state.space.metrics.nexits.exit_max(), expected_exit_max);
}
</Rust>