<Filename>glean-core/rlb/src/test.rs</Filename>
<imports>
use super::initialize;
use super::register_ping_type;
use crate::private::PingType;
use std::panic;
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Once;
use std::sync::Mutex;
use std::sync::Arc;
use crossbeam_channel::bounded;
use std::thread;
use crate::Configuration;
use crate::ClientInfoMetrics;
</imports>
<Rust>
#[test]
fn test_register_ping_before_init() {
  let ping = PingType::new("test_ping", true, true, vec![]);
  let result = panic::catch_unwind(|| {
    register_ping_type(&ping);
  });
  assert!(result.is_err());
  let glean_initialized = AtomicBool::new(false);
  let glean_init = Arc::new(Mutex::new(glean_initialized));
  let glean_init_clone = glean_init.clone();
  let handle = std::thread::spawn(move || {
    initialize(Configuration { data_path: "".into(), application_id: "".into(), upload_enabled: true, max_events: None, delay_ping_lifetime_io: false, channel: None, server_endpoint: None, uploader: None }, ClientInfoMetrics { app_build: "".into(), app_display_version: "".into(), app_version: "".into(), architecture: "".into(), device_manufacturer: "".into(), device_model: "".into(), locale: "".into(), os: "".into(), os_version: "".into(), android_device: None });
    *glean_init_clone.lock().unwrap() = true;
  });
  while !glean_init.lock().unwrap().into_inner() {
    std::thread::yield_now();
  }
  handle.join().unwrap();
  let result = panic::catch_unwind(|| {
    register_ping_type(&ping);
  });
  assert!(result.is_ok());
}
</Rust>