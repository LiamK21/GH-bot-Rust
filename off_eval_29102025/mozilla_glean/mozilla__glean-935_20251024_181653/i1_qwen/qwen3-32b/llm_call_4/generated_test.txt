#[test]
fn test_log_if_error_logs_error_correctly() {
    struct TestLogger {
        output: Mutex<String>,
    }

    impl TestLogger {
        const fn new() -> Self {
            TestLogger {
                output: Mutex::new(String::new()),
            }
        }
    }

    impl Log for TestLogger {
        fn enabled(&self, _: &log::Metadata) -> bool {
            true
        }

        fn log(&self, record: &log::Record) {
            if record.level() == Level::Error {
                let mut output = self.output.lock().unwrap();
                *output = record.args().to_string();
            }
        }

        fn flush(&self) {}
    }

    static LOGGER: Lazy<TestLogger> = Lazy::new(|| TestLogger::new());

    fn init_logger() {
        set_max_level(LevelFilter::Error);
        set_logger(&*LOGGER).unwrap();
    }

    init_logger();

    let message = CString::new("Test message").unwrap();
    let error = super::ExternError {
        code: ErrorCode::Unknown,
        message: message.into_raw(),
    };

    super::log_if_error(error);

    let output = LOGGER.output.lock().unwrap();
    assert!(output.contains("Glean failed (Unknown): Test message"));
}