#[test]
fn test_log_if_error_uses_error_level() {
    struct TestLogger {
        output: Mutex<String>,
    }

    impl TestLogger {
        const fn new() -> Self {
            TestLogger {
                output: Mutex::new(String::new()),
            }
        }
    }

    impl Log for TestLogger {
        fn enabled(&self, _: &Metadata) -> bool {
            true
        }

        fn log(&self, record: &Record) {
            if record.level() == Level::Error {
                let mut output = self.output.lock().unwrap();
                *output = record.args().to_string();
            }
        }

        fn flush(&self) {}
    }

    static LOGGER: Lazy<TestLogger> = Lazy::new(|| TestLogger::new());

    fn init_logger() {
        set_max_level(LevelFilter::Error);
        set_logger(&*LOGGER).unwrap();
    }

    init_logger();

    // Use a known ErrorCode value that's guaranteed to exist
    let error_code = ErrorCode { code: 1 }; // Assuming numeric error code 1 is valid
    let message = CString::new("Test message").unwrap();
    let error = ExternError {
        code: error_code, 
        message: message.into_raw(),
    };

    super::log_if_error(error);

    let output = LOGGER.output.lock().unwrap();
    assert!(output.contains("Glean failed (1): Test message"));
}