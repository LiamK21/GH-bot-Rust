#[test]
fn test_log_if_error_logs_error_correctly() {
    // Simple logger to capture logs
    static mut LOGGER: TestLogger = TestLogger { output: String::new() };

    struct TestLogger {
        output: String,
    }

    impl TestLogger {
        fn new() -> Self {
            TestLogger { output: String::new() }
        }
    }

    impl Log for TestLogger {
        fn enabled(&self, _: &Record) -> bool { true }

        fn log(&self, record: &Record) {
            if record.level() == Level::Error {
                self.output.push_str(record.args().to_string().as_str());
            }
        }

        fn flush(&self) {}
    }

    // Set up environment logger
    unsafe {
        log::set_logger(&LOGGER).unwrap();
        log::set_max_level(log::LevelFilter::Error);
    }

    // Simulate a non-success error
    // (Assuming ExternError is a mocked type here for test)
    let error = ExternError {
        code: 1, // Non-success code
        message: "Test message".to_string(),
    };

    // Call the function under test
    log_if_error(error);

    // Check that the log contains the error message
    unsafe {
        assert!(LOGGER.output.contains("Glean failed (1): Test message"));
    }
}