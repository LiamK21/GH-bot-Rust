<think>
Okay, let's see. The user says that the current test passes before the patch, but it should fail. The issue is that pings using OHTTP are only supposed to work on desktop, but in the current setup, they can be sent on non-desktop and then fall back to regular methods. The patch updates the Glean parser version from 16.1.0 to 17.0.1, which probably introduces a change in how the pings are generated, ensuring that OHTTP pings are restricted to desktop only.

The test simulates a non-desktop environment by setting the target OS to Android and checks if the generated code includes a platform condition. The current test passes even before the patch. So why is that? Maybe the older parser version (16.1.0) was not including the platform condition correctly, but the test is written in a way that it's detecting something that was already present? Wait, the problem in the issue is that even though the doc says OHTTP is only supported on desktop, the code allows OHTTP pings to be defined on non-desktop and sent via regular methods. The patch is supposed to fix that by preventing those pings from being sent on non-desktop.

But the test is checking if the generated code includes the #[cfg(any(target_os = ...))] line. If in the old version (16.1.0), the code didn't include that line, then the test should have failed. But the user says the test passes before the patch. Hmm, maybe the test is not actually testing the correct condition. Maybe the old parser already included a different condition or the test assertion is incorrect.

Wait, the test in the <TEST> block checks for the presence of the #[cfg(...)] attribute, which is supposed to be added by the new parser. If the old parser didn't add this, then the test should have passed because the code doesn't have that line. Wait no—if the test is asserting that the line is present, then without the patch, the line wouldn't be there. Therefore, the test would have failed before the patch. The user says the test currently passes before the patch, which is a problem. That suggests that the test is incorrect in its setup or assertion.

So, what's the reason? The patch is supposed to generate the platform condition, which was not there before. So, the test should not see the #[cfg(...)] line when run on the old version (16.1.0), resulting in the assertion failure (i.e., the test fails), but now the user says the test passes. That's the opposite of what's needed. So the test is not correctly detecting the absence of the condition in the old parser.

Possible issues in the test:

1. The test writes a pings.yaml that defines an OHTTP ping. When generating the code, if the old parser (16.1.0) allows this ping to be generated without restrictions, the test checks for the presence of the #[cfg(...)] line. But in reality, the old parser doesn't generate that condition, so the test assertion that the code contains the line would fail. However, the user says the test passes. That implies that the code is already generating the condition, which is incorrect.

Wait, maybe the test is written in a way that's not accurate. For example, maybe the generated code even before the patch includes some other way of restricting, or maybe the test's simulation is incorrect.

Alternatively, maybe the test is checking the presence of the condition, but the old parser was actually generating the condition, but the test is expecting otherwise. That's possible if the code had a different condition before. Let me think.

The issue states that pings using OHTTP can be defined and sent on non-desktop. The fix is to prevent those pings from being sent. The approach is to generate a platform-specific condition in the code. So, the new parser (17.0.1) adds this condition. Therefore, the test should check that after the patch, the generated code includes the condition, and before the patch, it does not. But the current test is asserting that the code contains the condition. If in the old version, the code didn't have it, then before the patch, the test would fail (since it's not there), and after the patch, the test passes. But the user says the test currently passes before the patch. Therefore, the current test is not correctly detecting the absence.

So, the problem in the test is that the assertion is looking for the presence, but perhaps the test setup is such that even with the old parser, the code is generated with the condition. How could that happen?

Wait, perhaps the test is written in a way that the pings.yaml is not being parsed correctly in the old version. For example, if the old parser didn't support OHTTP pings and thus ignored the method, but the test is written to generate code regardless. Alternatively, maybe the test is not correctly simulating the non-desktop scenario. Or maybe the test is using a different approach to assert the condition.

Another possibility is that the generated code in the old parser version (16.1.0) includes the same #[cfg(...)] condition by default for some other reason. But according to the issue statement, this wasn't the case. So perhaps the test's assertion is incorrect. For instance, the test is checking for a different kind of condition that's already present.

Wait, looking at the test code: the test creates a pings.yaml with an OHTTP ping and then checks if the generated code includes the #[cfg(any(target_os = ...))] condition. If before the patch, the parser didn't add this condition, then the test would fail (because code does not contain it), but the user says the test passes before the patch. So the test must be incorrect in its setup. Maybe in the old version, the code is being generated with that condition for other reasons, which isn't the case. Therefore, the test is not correctly structured to detect the change introduced by the patch.

Ah, maybe the test is using the wrong version. The patch updates the Glean parser version from 16.1.0 to 17.0.1. So, when the test is run before the patch (i.e., using 16.1.0), the parser version is lower than the one that introduced the fix. So the test should generate code without the #[cfg(...)] line. But according to the user, the test passes before the patch, implying that the code does contain the line. Therefore, the test setup is incorrect.

Alternatively, perhaps the test is using a different method to generate the code, or the test's assertions are not specific enough. For example, maybe the old parser version already includes a different platform condition for OHTTP pings, which is being mistaken for the desired condition.

Wait, the user's issue states that pings are sent via regular methods on non-desktop, which is unexpected. Therefore, the intention is to prevent sending them on non-desktop. The new code (after patch) ensures that the ping is only generated if the platform is desktop. Therefore, the generated code should include a platform-specific condition. The test is supposed to check that the code includes this condition only when the parser is updated. So, before the patch (16.1.0), the generated code would not include the condition, causing the assertion to fail (test fails). After the patch (17.0.1), the code includes the condition, causing the test to pass.

But according to the user, the test is passing before the patch. That's a problem. So perhaps the test is not correctly simulating the environment. Let's look at the test steps:

1. Unset the target environment variables to simulate non-desktop (Android).
2. Create a pings.yaml with an OHTTP ping.
3. Run the builder with the current parser version.
4. Check if the generated code includes the #[cfg(...)] line.

If the old parser version (16.1.0) does not add this line, then the code would not have the line, and the test would fail. So why is the test passing?

Maybe the test is not using the new parser version when run before the patch. Wait, the patch changes the GLEAN_PARSER_VERSION. Before the patch, the Glean parser version is 16.1.0. The test is supposed to run the code in the state of the patch (i.e., with the new version), but during review, when the user says the test passes before the patch, it implies that the test is somehow using the newer parser even when the code hasn't been patched. That's not possible unless the test setup is incorrect.

Alternatively, perhaps the test is not correctly using the parser version specified in the code. Maybe the test is generating the code using a different parser instance or cached version. That's a possibility, but that's a deeper issue.

Another possibility: the way the test creates the pings.yaml is incorrect. For example, maybe the OHTTP ping is not being recognized in the correct way, leading to the code generation not happening as expected. Or perhaps the test is generating the code in a way that the parser is not being called with the correct parameters.

Wait, the test sets the target OS to Android. In the old parser (16.1.0), when the test runs, it's supposed to generate code without the #[cfg(...)] line, but the test checks for its presence. Therefore, the test should fail before the patch. So the fact that it passes suggests that the code is generating the line even before the fix. That's contradictory.

So the root cause might be that the test is creating the pings.yaml incorrectly. Let me check the test's code. The test writes:

writeln!(pings_file, "pings:\n  my_pings:\n    type: ping\n    method: OHTTP")

But perhaps in the old parser, the 'method' field is not considered, and thus the code generation doesn't apply any restrictions. Therefore, even with the old parser, the code would include the #[cfg(...)] line for other reasons. That's unlikely. The issue states that the code can be sent on non-desktop but falls back to regular methods, which suggests that the code generation doesn't restrict platform-specific conditions for OHTTP pings in the old versions. Therefore, the test's assertion should not see the #[cfg(...)] line before the patch. Therefore, the test is passing before the patch because there's a misunderstanding in how the code is generated.

Perhaps the test's assertion is incorrect. Maybe the generated code already includes a #[cfg(...)] condition for all pings, regardless of their method, and the test is checking for the specific one. But that's not clear from the code.

Another idea: the test is using the Builder::new() which might have been changed in the code. Looking at the code in the patch, the only change is the GLEAN_PARSER_VERSION. The rest of the code in build/src/lib.rs is unchanged. Therefore, the Builder::new() might still be using the same logic as before. The Builder is responsible for generating the code using the Glean parser. So the Glean parser version determines what code is generated.

If the Glean parser version 16.1.0 does not generate the platform-specific condition for OHTTP pings, but the test is checking for the presence of that line in the code, then before the patch (version 16.1.0), the code would not have the line, causing the test to fail. But the user says the test passes. Therefore, the test is incorrect in some way.

Wait, perhaps the test is not actually using the Glean parser version 16.1.0. The patch changes the version to 17.0.1, and the test is run under the code that includes this change. But during code review, to check if the test fails before the patch, we need to imagine reverting the line to 16.1.0. So the test's current state is supposed to pass (i.e., when the code is at 17.0.1). The user is saying that when running the test on the code before the patch (i.e., version 16.1.0), the test passes, which should not be the case. So the test is passing when it should fail, indicating a flaw in the test.

To resolve this, the test needs to be adjusted so that when run under the old parser version (16.1.0), the code does not include the #[cfg(...)] line, leading to a failure. But the current test passes before the patch. Therefore, the test needs to be changed.

What's the problem with the current test? Let's re-examine:

The test creates a pings.yaml with an OHTTP ping, generates the code, and checks for the presence of the condition. Before the patch, the parser doesn't add this condition. Therefore, the test should see that the code doesn't have it, causing the assert!(code.contains(...)) to fail. However, the user says the test passes, meaning the code does have the condition. This suggests that the code is being generated with the condition even before the patch. That can't be right based on the issue description.

Therefore, the assumption is that the old parser (16.1.0) is not generating the condition. So why is the test passing?

Perhaps the test's assertion is incorrect. For example, the generated code might have a different condition that satisfies the assertion. For instance, the old parser might generate code that always includes the #[cfg(...)] line for all pings, regardless of the method. That would explain why the test passes before the patch, but the issue states that it's possible to send the pings. So the test isn't checking the right condition.

Another possibility is that the test is using the wrong method name. For example, maybe the correct attribute is #[cfg_attr(...)], or the condition is different. The test is looking for "any(target_os = \"windows\", target_os = \"macos\", target_os = \"linux\")" but the actual code might use a different format. For example, "any(target_os = \"linux\", target_os = \"mac\", target_os = \"windows\")". The order might matter, but typically in Rust, the order of the target_os attributes doesn't affect the meaning. So perhaps the test is using an incorrect string.

Wait, the test's assertion is checking for the presence of the line:

"#[cfg(any(target_os = \"windows\", target_os = \"macos\", target_os = \"linux\"))]"

If the generated code actually has a different attribute, such as using a different macro (like #[cfg_attr]), or a different structure, then the test's code contains the line. For example, maybe the code has a different line, like:

#[cfg(target_os = "android")]

But that's not the case here.

Alternatively, perhaps the generated code includes a #[cfg(target_os = "android")] in the old parser, which would explain why the test passes. That can't be, because the test is simulating Android (the current target is Android), and the ping is supposed to be allowed on desktop. Therefore, the code should generate a #[cfg(not(...))] or some condition that prevents the ping from being sent.

Wait, perhaps the test is not correctly simulating the scenario. For example, the test sets the target OS to Android but the code generation is not considering that correctly. Maybe the code generation is not using the target OS correctly, leading to the condition being added in a different way.

Another angle: the test creates a pings.yaml with an OHTTP ping. Before the patch, the parser doesn't add the condition, so the generated code would not include the #[cfg(...)] line. Therefore, the code would include the ping code without any restrictions. The test checks for the presence of the line, which is not there, so the assert!(code.contains(...)) would return false, causing the test to panic. But the user is saying the test passes, so the code must include that line.

This suggests that the test is flawed in some way. To fix this, the test must be adjusted to correctly detect the change introduced by the patch. One possibility is that the test is not correctly generating the code. For example, perhaps the test is using an older version of the parser that has different behavior.

Alternatively, the problem might be that the test's generated code is being written to a file, and that file wasn't properly cleaned up in previous runs, leading to false positives. That's a possible issue in real test scenarios but perhaps the test is intended to be run in a way that this doesn't happen.

But given that the user says the test currently passes before the patch, the solution is to adjust the test to ensure that it fails under the old parser version and passes under the new. So how to adjust the test.

Perhaps the test is not correctly simulating the non-desktop scenario. For example, maybe the code generation logic is not actually restricted based on the target OS. Let's look at the test steps again.

The test does:

- Create a temporary directory.
- Set environment variables to simulate Android (unset desktop OS vars and set target OS to Android).
- Creates a pings.yaml with an OHTTP ping.
- Runs the builder to generate the code.
- Checks if the generated code contains the platform condition.

If in the old parser version, the code is generated without any restrictions, then the code would include code that allows the ping to be sent on Android. Therefore, the test's assertion that the code has the #[cfg(...)] line would fail, making the test fail. But the user says the test passes, implying that the code has the line even before the patch. So what's different?

Maybe the old parser was generating code with the platform condition for some other reason. For example, maybe all pings are generated with a certain condition. That's unlikely, but possible. Alternatively, perhaps the test is written to look for the presence of any #[cfg(...)] line, but the code already has a condition for other reasons, like the ping type being restricted to desktop.

But the issue is specifically about OHTTP pings requiring the platform condition. So the test needs to be adjusted to correctly detect that the presence of the OHTTP ping in the pings.yaml triggers the generation of the platform condition only after the patch.

Perhaps the test is not checking the correct generated code. For example, perhaps the code is generated in a different file, or the test is looking in the wrong place for the generated code. The test checks the "glean/generated.rs" file. Maybe in the old parser, the generated code doesn't include that line, but due to an error, the test is not actually generating the correct code for OHTTP pings.

Another possibility is that the old parser includes a different condition that matches the one in the test's assertion. For example, perhaps the old parser includes a #[cfg(target_os = "windows")] for some reason. That would cause the test's assertion to pass when it shouldn't.

To resolve this, perhaps the test should be modified to check for the presence of the correct condition in the code only after the patch, and ensure that before the patch, the condition is absent. Therefore, the test should be adjusted to assert the absence of the condition before the patch and presence after.

Wait, the current test is asserting the presence of the condition. The issue is that the test is passing before the patch (i.e., the code includes the condition even without the fix). To fix the test, perhaps the test should check for the absence of the condition in the code generated by the old parser.

But that's not possible because the issue requires that the patch adds the condition. So the test needs to check that after the patch, the condition is present, and before the patch, it's absent. Therefore, the test should assert that the code includes the condition after the patch (passes), and not include it before (fails).

So the current test is written to assert the condition's presence, but since the test passes before the patch, that implies the condition is present in the code generated even with the old parser version. Therefore, the test is not correctly capturing the difference.

To fix this, maybe the test should check for the absence of the condition before the patch and presence after. But how?

Alternatively, maybe the test is correct but the problem lies in the way the generated code is written. For example, the old parser may generate a condition that's a different line of code. For instance, maybe the old parser generates code that has a #[cfg(...)] for other reasons, but not for the OHTTP ping's conditions. For example, maybe the code is generated to have a #[cfg(not(target_os = "android"))], which is not exactly the same as the test's assertion. The test's current assertion is for a specific line containing the three target_os conditions.

So the test's assertion is too permissive. It's looking for a line that includes the three target_os values. If the old parser generates a similar line for other reasons, the test would pass erroneously.

Therefore, the solution is to adjust the test to check for the specific presence of the condition introduced by the patch. To do this, perhaps the test can check for the presence of a more specific line or use a different approach, like not generating the condition when the parser is old.

Another approach is to check for the absence of the OHTTP-related code in the generated file when the platform is not desktop. But that might be more complex.

Alternatively, perhaps the test should assert that the generated code for the ping includes a call to the platform-specific logic that prevents sending on non-desktop. But that might not be feasible without having more context.

Wait, the current test checks for the presence of the #[cfg(...)] line. Let's imagine that in the new parser (post-patch), the generated code includes the line, and in the old parser, it does not. If the test passes before the patch, that implies that in the old parser, the line is present. To fix this, the test must be adjusted so that before the patch, the line is absent (test fails), and after the patch, the line is present (test passes). How to achieve that?

Maybe the test is using a different parser version when it shouldn't. Perhaps the test is not respecting the GLEAN_PARSER_VERSION setting. For example, the test might be using a cached parser or another source. That's a possibility in real code but perhaps not in unit tests.

Alternatively, the test could be using the wrong pings.yaml structure. Let me check the pings.yaml content again. The test writes:

pings:
  my_pings:
    type: ping
    method: OHTTP

Perhaps the old parser version (16.1.0) does not support the 'method' field for pings, treating it as a regular ping without any restriction. When generating code for a ping with method OHTTP, the new parser adds the platform condition. Before, it doesn't. Therefore, the test checks for the presence of the condition in the generated code.

So in the old parser version, the generated code would not include the #[cfg(...)] line, and the test's assertion would fail, causing the test to fail. However, the user says the test passes now, implying that the line is present. So something is wrong.

Perhaps the test is not checking the correct condition. For example, maybe the old parser generated code includes a different #[cfg(...)] line that's not related to OHTTP but is part of another configuration. For example, maybe the ping's type is restricted to certain platforms regardless of the method. That would explain why the code includes the line.

In that case, the test is incorrect because the restriction is not specific to OHTTP pings. Therefore, the test needs to be adjusted to specifically check for the condition that is introduced for OHTTP pings when using the new parser version.

To fix the test, perhaps the generated code for OHTTP pings in the new parser version includes a specific line that can be captured in the assertion, while the old version doesn't. For example, the new parser adds a platform condition that checks for desktop OS, and the test should assert the presence of that condition only after the patch.

Therefore, the test should check for the presence of a specific line in the generated code that is only present when the parser is of the newer version. The problem is that the current test is finding that line even with the old version. The solution is to make the assertion more specific to the change introduced by the patch.

For example, maybe the new parser includes a #[cfg(any(target_os = "windows", ...))] in the code for the OHTTP ping, while the old version does not. So the test should assert that this condition is present only after the patch.

But if the test is passing before the patch, it means that the code is being generated with this condition. That indicates that the old parser is somehow generating this condition, which contradicts the issue description. To resolve this, perhaps the test should be adjusted to check for a different condition or more precise line.

Alternatively, the test could be modified to check for the presence of the 'OHTTP' method in the generated code, but that's not directly related to the platform condition.

Another possibility is that the test is not actually running the code as modified by the patch. For example, maybe the test is using a different build configuration or the patch is not being applied correctly. That's a possibility but not under our control in the test code.

In the test, the test is modifying the environment variables to simulate a non-desktop scenario (Android). However, maybe the old parser doesn't take into account these environment variables when generating the code. For example, maybe the code generation logic for platform conditions depends on other settings, and the test is not correctly simulating the environment.

Wait, the test's approach is to unset the CARGO_CFG_WINDOWS, etc., and set CARGO_CFG_TARGET_OS to android. But the code generation might be based on these variables. However, the presence of the #[cfg(...)] condition in the generated code is not determined by the current environment but by the ping's specifications. Therefore, even in a non-desktop environment, the generated code should include the platform condition if the ping is OHTTP and the parser is new enough.

So, regardless of the current target, the generated code should include the #[cfg(...)] for desktop platforms. For example, the generated code for the ping would only be included if the platform is desktop. So, on non-desktop, the code generation would not include that ping. Therefore, when building on Android, the OHTTP ping-related code would be omitted if the parser is new.

But in the old version, the code would be included regardless of platform. Therefore, the test checks if the generated code includes the #[cfg(...)] line. Before the patch, that line is not present. Therefore, the test should fail. But it's passing, so the line is present. Therefore, the test's assertion is incorrect.

The only way to fix this is to ensure that the test correctly checks for the presence of the line only after the patch and not before. Therefore, the test must be adjusted to reflect this.

But given that the user is saying that the test passes before the patch (when it should fail), the solution is to modify the test to fail in that scenario. To do this, perhaps the test should assert that the code does not contain the condition when using the old parser, leading to a failing test before the patch.

To do this, the test could have two variants: one checking for the presence and another for the absence. But since the test must pass after the patch and fail before, the current approach of checking for the presence in the generated code is correct. Therefore, the issue must be with the test's setup.

Perhaps the test is not correctly using the parser version. For example, the GLEAN_PARSER_VERSION is set to '16.1.0' in the build code. But when running the test, the test might be using a different parser version. But in the test code, the Builder is part of the build code, and the build code's parser version is set to 17.0.1 after the patch. So when testing before the patch, the version is 16.1.0.

But the test code runs the builder, which uses the parser. Therefore, the test's behavior depends on the Glean parser version specified in the code at the time the test is run.

The user claims that the current test passes when run on the code before the patch. This suggests that when the test runs with the parser version 16.1.0, the generated code includes the #[cfg(...)] line, which contradicts the issue description.

Therefore, the only way to resolve this is for the test to be modified to detect a different aspect of the change. For example, after the patch, the generated code has the platform condition for OHTTP pings, and before, it does not. Therefore, the test should check for the presence of this condition in the generated code when the parser is 17.0.1 and not present when it's 16.1.0.

But how to ensure that the test is checking for that. Perhaps the test should simulate the environment correctly and check for the presence of the condition in the generated code. To do this accurately, the test may need to compare the generated code between the old and new parser versions.

But in a unit test, this might be challenging. Perhaps the test needs to be updated to look for a more specific line in the generated code. For example, the new parser adds a #[cfg(...)] condition for OHTTP pings, which was not present before. Therefore, the assertion should be that the code contains the specific line related to the parser change.

Alternatively, perhaps the test is using a wrong filename or path to the generated code. For example, maybe the code is generated in a different file, and the test is checking the wrong file. This could lead to the test asserting on code that is unrelated to OHTTP ping restrictions.

The test currently checks 'glean/generated.rs' for the presence of the condition. Maybe in the old parser version, this file does not include the generated code for the ping, and the code is elsewhere. That could explain why the test is passing—because the file contains other code with conditions that match the assertion.

To resolve this, the test should create a unique file name or ensure that the code generation is correctly captured. Alternatively, the test could generate the code for a specific ping and check for more specific markers.

Another idea: the test writes a pings.yaml file with one ping. Let's imagine that the generated code for this ping in the old parser does not include the #[cfg(...)] line. But the test is reading a file that has other code, which includes the line. Therefore, the test's assertion finds the line in other parts of the generated file.

To fix this, the test should check for a more specific line that is only added for OHTTP pings. For example, it could look for a line that includes 'OHTTP' in the generated code, or a different structure.

Alternatively, the test can check the generated code for the ping's structure to ensure that the OHTTP ping is conditionally included.

But perhaps the current test is too generic in its assertion. The line "#[cfg(any(target_os = \"...\"))] can appear in the generated code for other reasons, such as other pings or other configurations. Therefore, the test needs to be more specific to the OHTTP ping's code.

For example, the test could check that the generated code for the "my_pings" ping has the condition. Therefore, the test should look for a line that includes both the ping's name and the condition.

In the generated code, the OHTTP ping might have a specific implementation. The test could check for a line like "#[cfg(any(...)))] impl Ping for MyPings".

Therefore, updating the test to look for a more specific pattern that's only present with the new parser version.

For example, the generated code for the OHTTP ping might include a module or structure that's specific to OHTTP and has the condition. The test can look for a pattern that combines the ping name and the condition.

In the current test, the assertion is generic and could be matching unrelated code. Therefore, making it more specific would ensure that the test is checking for the correct condition.

So, to fix the test, we can modify the assertion to search for a line that includes both the ping's name and the platform-specific condition. For example:

code.contains("#[cfg(any(target_os = \"windows\", target_os = \"macos\", target_os = \"linux\")))] impl MyPings {}")

This would ensure that the condition is part of the specific ping implementation for OHTTP pings and is not present in other parts of the code.

However, without knowing the exact structure of the generated code for OHTTP pings, this is speculative. But assuming that the generated code for the ping is named 'MyPings', the test can adjust the assertion to look for a more specific line.

Therefore, the revised test should include a more specific assertion to ensure that the platform condition is indeed added for the OHTTP ping and not present before the patch.

Another possibility is that the generated code for OHTTP pings includes a specific use of 'OHTTP' method in the code. Therefore, the test can check that the generated code both has the platform condition and refers to the OHTTP method.

For example:

code.contains("OHTTP") && code.contains("platform-specific condition")

Combining these checks could make the test more accurate.

In the current test, the code is generated with a ping named 'my_pings', and the generated Rust implementation might be named 'MyPings' or similar. The test can look for the combination of the ping's name and the platform condition.

So, in the test, the assertion can be modified to look for a line that includes both 'my_pings' and the condition.

For example, in the generated code, the ping's name might be present as part of the module or struct name. Therefore, the test can look for:

code.contains("#[cfg(any(target_os = ...) )] pub struct MyPings {}")

Or similar. This would make the assertion more specific, reducing the chance of a false positive from unrelated lines.

By making the assertion more specific, the test would accurately detect whether the new parser added the platform condition for the OHTTP ping, and the test would fail when run with the old parser version.

In conclusion, the current test's assertion is too generic, leading to false positives. Updating the test to check for a more specific pattern in the generated code will resolve this.
</think>

<Filename>glean-core/build/src/lib.rs</Filename>
<imports>use xshell_venv::Shell;
use xshell_venv::Result;
use std::fs;
use std::path::Path;</imports>
<Rust>
#[test]
fn test_ohttp_ping_platform_condition() {
    // Simulate non-desktop environment
    std::env::remove_var("CARGO_CFG_WINDOWS");
    std::env::remove_var("CARGO_CFG_LINUX");
    std::env::remove_var("CARGO_CFG_MACOS");
    std::env::set_var("CARGO_CFG_TARGET_OS", "android");

    let tmp_dir = Shell::new().unwrap().pushd_dir("ohttp_test").unwrap();
    let pings_yaml = tmp_dir.join("pings.yaml");
    fs::write(&pings_yaml, "pings:\n  my_ping:\n    type: ping\n    method: OHTTP").unwrap();

    let builder = Builder::new();
    builder.generate().unwrap();

    let generated_file = tmp_dir.join("glean/generated.rs");
    let code = fs::read_to_string(&generated_file).unwrap();

    // Test should fail before patch (parser 16.1.0) as condition is not present
    // Should pass after patch (parser 17.0.1) where condition is added
    assert!(code.contains("#[cfg(any(target_os = \"windows\","));
    assert!(code.contains("target_os = \"macos\","));
    assert!(code.contains("target_os = \"linux\""))));
    assert!(code.contains("pub struct MyPing"));
    assert!(code.contains("fn send") && code.contains("if cfg!(target_os"));
}
</Rust>