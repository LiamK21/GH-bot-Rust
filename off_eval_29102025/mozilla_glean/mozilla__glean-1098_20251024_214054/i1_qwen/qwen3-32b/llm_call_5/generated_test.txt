#[test]
fn test_ping_over_1mb_rejected() {
    let (glean, _) = new_glean(None);
    let dir = tempfile::tempdir().unwrap();
    let upload_manager = PingUploadManager::new(dir.path(), "Rust", false);

    // Wait for directory processing to complete
    while upload_manager.get_upload_task(&glean, false) == PingUploadTask::Wait {
        std::thread::sleep(std::time::Duration::from_millis(10));
    }

    // Create a ping payload with body size just over 1MB
    let doc_id = "over_1mb";
    let path = format!("/submit/app_id/test/1/{}", doc_id);
    let body_size = 1024 * 1024 + 1;
    let body = String::from_utf8(vec![b'x'; body_size]).unwrap();

    // Add the payload to pending pings
    upload_manager.pending_pings.write().unwrap().push((
        doc_id.to_string(),
        path,
        body,
        None,
    ));

    // Process pending pings
    while upload_manager.get_upload_task(&glean, false) == PingUploadTask::Wait {
        std::thread::sleep(std::time::Duration::from_millis(10));
    }

    // Verify ping was not enqueued
    match upload_manager.get_upload_task(&glean, false) {
        PingUploadTask::Done => {}
        _ => panic!("Unexpected upload task"),
    }

    // Verify discard metric was recorded in the correct storage
    let discarded_metric = &upload_manager.upload_metrics.discarded_exceeding_pings_size;
    let samples = discarded_metric.test_get_value(&glean, "metrics").unwrap();
    assert_eq!(samples.values.len(), 1);
    assert_eq!(*samples.values.get(&1024).unwrap(), 1);
}