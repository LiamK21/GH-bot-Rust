#[test]
fn test_upload_triggered_on_max_events() {
    static STATE: OnceCell<Mutex<StateMock>> = OnceCell::new();

    // Setup a mock state with a counter to track upload triggers
    struct StateMock {
        upload_counter: Cell<u8>,
    }

    impl StateMock {
        fn new() -> Self {
            Self {
                upload_counter: Cell::new(0),
            }
        }
    }

    impl<'a> crate::State for StateMock {
        fn callbacks(&'a self) -> &'a dyn Callbacks {
            self
        }
    }

    impl Callbacks for StateMock {
        fn trigger_upload(&self) -> Result<(), ()> {
            self.upload_counter.set(self.upload_counter.get() + 1);
            Ok(())
        }
    }

    // Initialize global state with our mock
    STATE.set(Mutex::new(StateMock::new())).unwrap();

    // Create a Glean instance with upload enabled
    let glean = Glean::new(true).unwrap();

    // Create a metric with max_events = 1
    let metric = EventMetric::new(crate::private::CommonMetricDataInternal {
        name: "test_event".into(),
        category: "test".into(),
        send_in_pings: vec!["events".into()],
        dynamic_children_send_in_pings: vec![],
        disabled: false,
        lifetime: crate::Lifetime::Application,
        max_events: Some(1),
        allowed_extra_keys: None,
    });

    // First event: should not trigger upload
    metric.record_with_time(0, HashMap::new());

    // Second event: should trigger upload due to max_events limit
    metric.record_with_time(1, HashMap::new());

    // Get the mock state and verify the counter
    let state = STATE.get().unwrap().lock().unwrap();
    assert_eq!(state.upload_counter.get(), 1);
}