Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Audit log levels of log messages in glean-core
Error logs might be alarming to users and developers, when they are neither actionable nor signal an actual error in the code flow.
We should audit our messages and 1) ensure they still make sense, 2) their log level is appropriate and 3) at best are actionable for those that see them.
</issue>

Patch:
<patch>
diff --git a/glean-core/ffi/src/lib.rs b/glean-core/ffi/src/lib.rs
--- a/glean-core/ffi/src/lib.rs
+++ b/glean-core/ffi/src/lib.rs
@@ -146,7 +146,7 @@ pub extern "C" fn glean_enable_logging() {
                     .with_min_level(log::Level::Debug)
                     .with_tag("libglean_ffi"),
             );
-            log::debug!("Android logging should be hooked up!")
+            log::trace!("Android logging should be hooked up!")
         });
     }
 
@@ -163,11 +163,11 @@ pub extern "C" fn glean_enable_logging() {
         let logger = oslog::OsLogger::new("org.mozilla.glean", "glean_core").level_filter(level);
 
         match logger.init() {
-            Ok(_) => log::debug!("os_log should be hooked up!"),
+            Ok(_) => log::trace!("os_log should be hooked up!"),
             // Please note that this is only expected to fail during unit tests,
             // where the logger might have already been initialized by a previous
             // test. So it's fine to print with the "logger".
-            Err(_) => log::debug!("os_log was already initialized"),
+            Err(_) => log::warn!("os_log was already initialized"),
         };
     }
 
@@ -177,11 +177,11 @@ pub extern "C" fn glean_enable_logging() {
     #[cfg(all(not(target_os = "android"), not(target_os = "ios")))]
     {
         match env_logger::try_init() {
-            Ok(_) => log::debug!("stdout logging should be hooked up!"),
+            Ok(_) => log::trace!("stdout logging should be hooked up!"),
             // Please note that this is only expected to fail during unit tests,
             // where the logger might have already been initialized by a previous
             // test. So it's fine to print with the "logger".
-            Err(_) => log::debug!("stdout was already initialized"),
+            Err(_) => log::warn!("stdout logging was already initialized"),
         };
     }
 }

diff --git a/glean-core/src/database/mod.rs b/glean-core/src/database/mod.rs
--- a/glean-core/src/database/mod.rs
+++ b/glean-core/src/database/mod.rs
@@ -531,7 +531,7 @@ impl Database {
             let mut res = Ok(());
             for to_delete in metrics {
                 if let Err(e) = store.delete(&mut writer, to_delete) {
-                    log::error!("Can't delete from store: {:?}", e);
+                    log::warn!("Can't delete from store: {:?}", e);
                     res = Err(e);
                 }
             }
@@ -606,7 +606,7 @@ impl Database {
             Ok(())
         });
         if let Err(e) = res {
-            log::error!("Could not clear store for lifetime {:?}: {:?}", lifetime, e);
+            log::warn!("Could not clear store for lifetime {:?}: {:?}", lifetime, e);
         }
     }

diff --git a/glean-core/src/debug.rs b/glean-core/src/debug.rs
--- a/glean-core/src/debug.rs
+++ b/glean-core/src/debug.rs
@@ -151,7 +151,7 @@ where
             self.value = Some(value);
             return true;
         }
-        log::info!("Invalid value for debug option {}.", self.env);
+        log::error!("Invalid value for debug option {}.", self.env);
         false
     }

diff --git a/glean-core/src/event_database/mod.rs b/glean-core/src/event_database/mod.rs
--- a/glean-core/src/event_database/mod.rs
+++ b/glean-core/src/event_database/mod.rs
@@ -121,7 +121,7 @@ impl EventDatabase {
         match self.load_events_from_disk() {
             Ok(_) => self.send_all_events(glean),
             Err(err) => {
-                log::error!("Error loading events from disk: {}", err);
+                log::warn!("Error loading events from disk: {}", err);
                 false
             }
         }
@@ -156,7 +156,7 @@ impl EventDatabase {
         let mut ping_sent = false;
         for store_name in store_names {
             if let Err(err) = glean.submit_ping_by_name(&store_name, Some("startup")) {
-                log::error!(
+                log::warn!(
                     "Error flushing existing events to the '{}' ping: {}",
                     store_name,
                     err
@@ -220,7 +220,7 @@ impl EventDatabase {
         // containing those events immediately.
         for store_name in stores_to_submit {
             if let Err(err) = glean.submit_ping_by_name(store_name, Some("max_capacity")) {
-                log::error!(
+                log::warn!(
                     "Got more than {} events, but could not send {} ping: {}",
                     glean.get_max_events(),
                     store_name,
@@ -244,7 +244,7 @@ impl EventDatabase {
             .open(self.path.join(store_name))
             .and_then(|mut file| writeln!(file, "{}", event_json))
         {
-            log::error!("IO error writing event to store '{}': {}", store_name, err);
+            log::warn!("IO error writing event to store '{}': {}", store_name, err);
         }
     }
 
@@ -275,7 +275,7 @@ impl EventDatabase {
                         store.iter().map(|e| e.serialize_relative(first_timestamp)),
                     ))
                 } else {
-                    log::error!("Unexpectly got empty event store for '{}'", store_name);
+                    log::warn!("Unexpectly got empty event store for '{}'", store_name);
                     None
                 }
             })
@@ -293,7 +293,7 @@ impl EventDatabase {
                     std::io::ErrorKind::NotFound => {
                         // silently drop this error, the file was already non-existing
                     }
-                    _ => log::error!("Error removing events queue file '{}': {}", store_name, err),
+                    _ => log::warn!("Error removing events queue file '{}': {}", store_name, err),
                 }
             }
         }

diff --git a/glean-core/src/lib.rs b/glean-core/src/lib.rs
--- a/glean-core/src/lib.rs
+++ b/glean-core/src/lib.rs
@@ -95,7 +95,7 @@ pub fn setup_glean(glean: Glean) -> Result<()> {
     // initialized.
     if GLEAN.get().is_none() {
         if GLEAN.set(Mutex::new(glean)).is_err() {
-            log::error!(
+            log::warn!(
                 "Global Glean object is initialized already. This probably happened concurrently."
             )
         }
@@ -453,7 +453,7 @@ impl Glean {
         // Clear any pending pings.
         let ping_maker = PingMaker::new();
         if let Err(err) = ping_maker.clear_pending_pings(self.get_data_path()) {
-            log::error!("Error clearing pending pings: {}", err);
+            log::warn!("Error clearing pending pings: {}", err);
         }
 
         // Delete all stored metrics.
@@ -463,7 +463,7 @@ impl Glean {
             data.clear_all()
         }
         if let Err(err) = self.event_data_store.clear_all() {
-            log::error!("Error clearing pending events: {}", err);
+            log::warn!("Error clearing pending events: {}", err);
         }
 
         // This does not clear the experiments store (which isn't managed by the
@@ -741,7 +741,7 @@ impl Glean {
     ///
     /// Clears all the metrics that have `Lifetime::Application`.
     pub fn clear_application_lifetime_metrics(&self) {
-        log::debug!("Clearing Lifetime::Application metrics");
+        log::trace!("Clearing Lifetime::Application metrics");
         if let Some(data) = self.data_store.as_ref() {
             data.clear_lifetime(Lifetime::Application);
         }

diff --git a/glean-core/src/storage/mod.rs b/glean-core/src/storage/mod.rs
--- a/glean-core/src/storage/mod.rs
+++ b/glean-core/src/storage/mod.rs
@@ -100,7 +100,7 @@ impl StorageManager {
 
         if clear_store {
             if let Err(e) = storage.clear_ping_lifetime_storage(store_name) {
-                log::error!("Failed to clear lifetime storage: {:?}", e);
+                log::warn!("Failed to clear lifetime storage: {:?}", e);
             }
         }

diff --git a/glean-core/src/upload/directory.rs b/glean-core/src/upload/directory.rs
--- a/glean-core/src/upload/directory.rs
+++ b/glean-core/src/upload/directory.rs
@@ -122,14 +122,14 @@ impl PingDirectoryManager {
         let path = match self.get_file_path(uuid) {
             Some(path) => path,
             None => {
-                log::error!("Cannot find ping file to delete {}", uuid);
+                log::warn!("Cannot find ping file to delete {}", uuid);
                 return false;
             }
         };
 
         match fs::remove_file(&path) {
             Err(e) => {
-                log::error!("Error deleting file {}. {}", path.display(), e);
+                log::warn!("Error deleting file {}. {}", path.display(), e);
                 return false;
             }
             _ => log::info!("File was deleted {}", path.display()),
@@ -149,14 +149,14 @@ impl PingDirectoryManager {
         let path = match self.get_file_path(document_id) {
             Some(path) => path,
             None => {
-                log::error!("Cannot find ping file to process {}", document_id);
+                log::warn!("Cannot find ping file to process {}", document_id);
                 return None;
             }
         };
         let file = match File::open(&path) {
             Ok(file) => file,
             Err(e) => {
-                log::error!("Error reading ping file {}. {}", path.display(), e);
+                log::warn!("Error reading ping file {}. {}", path.display(), e);
                 return None;
             }
         };
@@ -202,7 +202,7 @@ impl PingDirectoryManager {
     ///
     /// A vector of tuples with the file size and payload of each ping file in the directory.
     fn process_dir(&self, dir: &Path) -> Vec<(u64, PingPayload)> {
-        log::info!("Processing persisted pings.");
+        log::trace!("Processing persisted pings.");
 
         let entries = match dir.read_dir() {
             Ok(entries) => entries,

diff --git a/glean-core/src/upload/mod.rs b/glean-core/src/upload/mod.rs
--- a/glean-core/src/upload/mod.rs
+++ b/glean-core/src/upload/mod.rs
@@ -271,7 +271,7 @@ impl PingUploadManager {
         match request.build() {
             Ok(request) => Some(request),
             Err(e) => {
-                log::error!("Error trying to build ping request: {}", e);
+                log::warn!("Error trying to build ping request: {}", e);
                 self.directory_manager.delete_file(&document_id);
 
                 // Record the error.
@@ -305,7 +305,7 @@ impl PingUploadManager {
             .iter()
             .any(|request| request.document_id == document_id)
         {
-            log::trace!(
+            log::warn!(
                 "Attempted to enqueue a duplicate ping {} at {}.",
                 document_id,
                 path
@@ -621,7 +621,7 @@ impl PingUploadManager {
             }
 
             UnrecoverableFailure | HttpStatus(400..=499) => {
-                log::error!(
+                log::warn!(
                     "Unrecoverable upload failure while attempting to send ping {}. Error was {:?}",
                     document_id,
                     status
@@ -630,7 +630,7 @@ impl PingUploadManager {
             }
 
             RecoverableFailure | HttpStatus(_) => {
-                log::info!(
+                log::warn!(
                     "Recoverable upload failure while attempting to send ping {}, will retry. Error was {:?}",
                     document_id,
                     status

diff --git a/glean-core/src/upload/request.rs b/glean-core/src/upload/request.rs
--- a/glean-core/src/upload/request.rs
+++ b/glean-core/src/upload/request.rs
@@ -49,7 +49,7 @@ fn gzip_content(path: &str, content: &[u8]) -> Option<Vec<u8>> {
 
     // Attempt to add the content to the gzipper.
     if let Err(e) = gzipper.write_all(content) {
-        log::error!("Failed to write to the gzipper: {} - {:?}", path, e);
+        log::warn!("Failed to write to the gzipper: {} - {:?}", path, e);
         return None;
     }


</patch>

Function signatures
<Signatures>
fn glean_enable_logging() -> ()

pub fn setup_glean(glean: Glean) -> Result<()>

fn gzip_content(path: &str, content: &[u8]) -> Option<Vec<u8>>
</Signatures>

You are a software tester at glean and your are reviewing the above <patch> for the above <issue>.
Identify whether a unit test is needed.
If there is no test needed or you believe you need additional testing resources beyond the Rust standard library (e.g., mocking libraries) to write a useful unit test, return <NO>.
If a test is needed, your task is:
1. Write exactly one rust test `#[test]fn test_...(){...}` block. Do NOT wrap the test inside a 'mod tests' block.
If the file you are adding the test already contains a test in the <patch>, ensure that the test name is unique.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. All 'use' declarations must be inside a <imports>...</imports> block. Additionally:
   - Do not use group imports.
  - Import only what is necessary for the test to run and make sure not to have colliding imports.
  - If the <patch> contains a 'mod tests' block with useful imports, do not add them to the <imports> block.
  - Use `use super::<function name> for the function under test.
.  - If multiple 'use' statements are needed, list each on a separate line.
5. To help you write the test, <Signatures> contains all modified function's:
  - name
  - parameters
  - Return type (assume '()' if empty)
6. Return only the absolute filename as it is in the <patch> block, the use statements, and rust test (no comments or explanations).

Follow this expected output format, do not deviate from this structure:
<Filename> ... </Filename>
<imports> ... </imports>
<Rust>
#[test]
fn test_<describe_behavior>() {
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
}</Rust>

