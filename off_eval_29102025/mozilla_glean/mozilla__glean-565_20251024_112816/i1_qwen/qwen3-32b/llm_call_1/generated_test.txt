#[test]
fn test_clear_ping_lifetime_data_after_clear() {
    // Create a temporary directory and database with delay_ping_lifetime_io enabled.
    let dir = tempdir().unwrap();
    let db_path = dir.path().to_path_lossy().into_owned();
    let db = Database::new(&db_path, true).unwrap();

    let storage_name = "storage_name";
    let metric_id = "metric_id";
    let metric_value = Metric::String("value".to_string());

    // Record a metric to ensure it's in memory.
    db.record_per_lifetime(
        Lifetime::Ping, 
        storage_name, 
        metric_id, 
        &metric_value
    ).unwrap();

    // Get the expected key.
    let key = format!("{}#{}", storage_name, metric_id);

    // Verify the metric exists in ping_lifetime_data.
    let ping_data = db.ping_lifetime_data.as_ref().unwrap().read().unwrap();
    assert!(ping_data.contains_key(&key), "Metric should be present before clear");

    // Clear the storage.
    db.clear_ping_lifetime_storage(storage_name).unwrap();

    // Verify the metric is removed from ping_lifetime_data.
    let ping_data = db.ping_lifetime_data.as_ref().unwrap().read().unwrap();
    assert!(!ping_data.contains_key(&key), "Metric should be cleared after clear");
}