Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Move Glean state into glean-core crate
We need to move the global Glean instance into the glean-core crate and make glean-ffi set and use that.
</issue>

Patch:
<patch>
diff --git a/glean-core/ffi/src/boolean.rs b/glean-core/ffi/src/boolean.rs
--- a/glean-core/ffi/src/boolean.rs
+++ b/glean-core/ffi/src/boolean.rs
@@ -4,7 +4,7 @@
 
 use ffi_support::FfiStr;
 
-use crate::{define_metric, handlemap_ext::HandleMapExtension, GLEAN};
+use crate::{define_metric, handlemap_ext::HandleMapExtension, with_glean_value};
 
 define_metric!(BooleanMetric => BOOLEAN_METRICS {
     new           -> glean_new_boolean_metric(),
@@ -12,8 +12,8 @@ define_metric!(BooleanMetric => BOOLEAN_METRICS {
 });
 
 #[no_mangle]
-pub extern "C" fn glean_boolean_set(glean_handle: u64, metric_id: u64, value: u8) {
-    GLEAN.call_infallible(glean_handle, |glean| {
+pub extern "C" fn glean_boolean_set(metric_id: u64, value: u8) {
+    with_glean_value(|glean| {
         BOOLEAN_METRICS.call_infallible(metric_id, |metric| {
             metric.set(glean, value != 0);
         })
@@ -21,12 +21,8 @@ pub extern "C" fn glean_boolean_set(glean_handle: u64, metric_id: u64, value: u8
 }
 
 #[no_mangle]
-pub extern "C" fn glean_boolean_test_has_value(
-    glean_handle: u64,
-    metric_id: u64,
-    storage_name: FfiStr,
-) -> u8 {
-    GLEAN.call_infallible(glean_handle, |glean| {
+pub extern "C" fn glean_boolean_test_has_value(metric_id: u64, storage_name: FfiStr) -> u8 {
+    with_glean_value(|glean| {
         BOOLEAN_METRICS.call_infallible(metric_id, |metric| {
             metric
                 .test_get_value(glean, storage_name.as_str())
@@ -36,12 +32,8 @@ pub extern "C" fn glean_boolean_test_has_value(
 }
 
 #[no_mangle]
-pub extern "C" fn glean_boolean_test_get_value(
-    glean_handle: u64,
-    metric_id: u64,
-    storage_name: FfiStr,
-) -> u8 {
-    GLEAN.call_infallible(glean_handle, |glean| {
+pub extern "C" fn glean_boolean_test_get_value(metric_id: u64, storage_name: FfiStr) -> u8 {
+    with_glean_value(|glean| {
         BOOLEAN_METRICS.call_infallible(metric_id, |metric| {
             metric.test_get_value(glean, storage_name.as_str()).unwrap()
         })

diff --git a/glean-core/ffi/src/counter.rs b/glean-core/ffi/src/counter.rs
--- a/glean-core/ffi/src/counter.rs
+++ b/glean-core/ffi/src/counter.rs
@@ -4,7 +4,7 @@
 
 use ffi_support::FfiStr;
 
-use crate::{define_metric, handlemap_ext::HandleMapExtension, GLEAN};
+use crate::{define_metric, handlemap_ext::HandleMapExtension, with_glean_value};
 
 define_metric!(CounterMetric => COUNTER_METRICS {
     new           -> glean_new_counter_metric(),
@@ -15,29 +15,23 @@ define_metric!(CounterMetric => COUNTER_METRICS {
 });
 
 #[no_mangle]
-pub extern "C" fn glean_counter_test_has_value(
-    glean_handle: u64,
-    metric_id: u64,
-    storage_name: FfiStr,
-) -> u8 {
-    GLEAN.call_infallible(glean_handle, |glean| {
+pub extern "C" fn glean_counter_test_has_value(metric_id: u64, storage_name: FfiStr) -> u8 {
+    with_glean_value(|glean| {
         COUNTER_METRICS.call_infallible(metric_id, |metric| {
             metric
-                .test_get_value(glean, storage_name.as_str())
+                .test_get_value(&glean, storage_name.as_str())
                 .is_some()
         })
     })
 }
 
 #[no_mangle]
-pub extern "C" fn glean_counter_test_get_value(
-    glean_handle: u64,
-    metric_id: u64,
-    storage_name: FfiStr,
-) -> i32 {
-    GLEAN.call_infallible(glean_handle, |glean| {
+pub extern "C" fn glean_counter_test_get_value(metric_id: u64, storage_name: FfiStr) -> i32 {
+    with_glean_value(|glean| {
         COUNTER_METRICS.call_infallible(metric_id, |metric| {
-            metric.test_get_value(glean, storage_name.as_str()).unwrap()
+            metric
+                .test_get_value(&glean, storage_name.as_str())
+                .unwrap()
         })
     })
 }

diff --git a/glean-core/ffi/src/custom_distribution.rs b/glean-core/ffi/src/custom_distribution.rs
--- a/glean-core/ffi/src/custom_distribution.rs
+++ b/glean-core/ffi/src/custom_distribution.rs
@@ -7,7 +7,8 @@ use std::os::raw::c_char;
 use ffi_support::FfiStr;
 
 use crate::{
-    define_metric, from_raw_int64_array, handlemap_ext::HandleMapExtension, RawInt64Array, GLEAN,
+    define_metric, from_raw_int64_array, handlemap_ext::HandleMapExtension, with_glean_value,
+    RawInt64Array,
 };
 
 define_metric!(CustomDistributionMetric => CUSTOM_DISTRIBUTION_METRICS {
@@ -18,12 +19,11 @@ define_metric!(CustomDistributionMetric => CUSTOM_DISTRIBUTION_METRICS {
 
 #[no_mangle]
 pub extern "C" fn glean_custom_distribution_accumulate_samples(
-    glean_handle: u64,
     metric_id: u64,
     raw_samples: RawInt64Array,
     num_samples: i32,
 ) {
-    GLEAN.call_infallible(glean_handle, |glean| {
+    with_glean_value(|glean| {
         CUSTOM_DISTRIBUTION_METRICS.call_infallible_mut(metric_id, |metric| {
             // The Kotlin code is sending Long(s), which are 64 bits, as there's
             // currently no stable UInt type. The positive part of [Int] would not
@@ -38,11 +38,10 @@ pub extern "C" fn glean_custom_distribution_accumulate_samples(
 
 #[no_mangle]
 pub extern "C" fn glean_custom_distribution_test_has_value(
-    glean_handle: u64,
     metric_id: u64,
     storage_name: FfiStr,
 ) -> u8 {
-    GLEAN.call_infallible(glean_handle, |glean| {
+    with_glean_value(|glean| {
         CUSTOM_DISTRIBUTION_METRICS.call_infallible(metric_id, |metric| {
             metric
                 .test_get_value(glean, storage_name.as_str())
@@ -53,11 +52,10 @@ pub extern "C" fn glean_custom_distribution_test_has_value(
 
 #[no_mangle]
 pub extern "C" fn glean_custom_distribution_test_get_value_as_json_string(
-    glean_handle: u64,
     metric_id: u64,
     storage_name: FfiStr,
 ) -> *mut c_char {
-    GLEAN.call_infallible(glean_handle, |glean| {
+    with_glean_value(|glean| {
         CUSTOM_DISTRIBUTION_METRICS.call_infallible(metric_id, |metric| {
             metric
                 .test_get_value_as_json_string(glean, storage_name.as_str())

diff --git a/glean-core/ffi/src/datetime.rs b/glean-core/ffi/src/datetime.rs
--- a/glean-core/ffi/src/datetime.rs
+++ b/glean-core/ffi/src/datetime.rs
@@ -6,7 +6,7 @@ use std::os::raw::c_char;
 
 use ffi_support::FfiStr;
 
-use crate::{define_metric, handlemap_ext::HandleMapExtension, GLEAN};
+use crate::{define_metric, handlemap_ext::HandleMapExtension, with_glean_value};
 
 define_metric!(DatetimeMetric => DATETIME_METRICS {
     new           -> glean_new_datetime_metric(time_unit: i32),
@@ -16,7 +16,6 @@ define_metric!(DatetimeMetric => DATETIME_METRICS {
 
 #[no_mangle]
 pub extern "C" fn glean_datetime_set(
-    glean_handle: u64,
     metric_id: u64,
     year: i32,
     month: u32,
@@ -37,7 +36,7 @@ pub extern "C" fn glean_datetime_set(
 
     // We are within the u32 boundaries for nano, we should be ok converting.
     let converted_nanos = nano as u32;
-    GLEAN.call_infallible(glean_handle, |glean| {
+    with_glean_value(|glean| {
         DATETIME_METRICS.call_infallible(metric_id, |metric| {
             metric.set_with_details(
                 glean,
@@ -55,12 +54,8 @@ pub extern "C" fn glean_datetime_set(
 }
 
 #[no_mangle]
-pub extern "C" fn glean_datetime_test_has_value(
-    glean_handle: u64,
-    metric_id: u64,
-    storage_name: FfiStr,
-) -> u8 {
-    GLEAN.call_infallible(glean_handle, |glean| {
+pub extern "C" fn glean_datetime_test_has_value(metric_id: u64, storage_name: FfiStr) -> u8 {
+    with_glean_value(|glean| {
         DATETIME_METRICS.call_infallible(metric_id, |metric| {
             metric
                 .test_get_value_as_string(glean, storage_name.as_str())
@@ -71,11 +66,10 @@ pub extern "C" fn glean_datetime_test_has_value(
 
 #[no_mangle]
 pub extern "C" fn glean_datetime_test_get_value_as_string(
-    glean_handle: u64,
     metric_id: u64,
     storage_name: FfiStr,
 ) -> *mut c_char {
-    GLEAN.call_infallible(glean_handle, |glean| {
+    with_glean_value(|glean| {
         DATETIME_METRICS.call_infallible(metric_id, |metric| {
             metric
                 .test_get_value_as_string(glean, storage_name.as_str())

diff --git a/glean-core/ffi/src/event.rs b/glean-core/ffi/src/event.rs
--- a/glean-core/ffi/src/event.rs
+++ b/glean-core/ffi/src/event.rs
@@ -13,8 +13,8 @@ use glean_core::{CommonMetricData, Lifetime};
 use crate::ffi_string_ext::FallibleToString;
 use crate::handlemap_ext::HandleMapExtension;
 use crate::{
-    define_metric, from_raw_int_array_and_string_array, from_raw_string_array, RawIntArray,
-    RawStringArray, GLEAN,
+    define_metric, from_raw_int_array_and_string_array, from_raw_string_array, with_glean_value,
+    RawIntArray, RawStringArray,
 };
 
 define_metric!(EventMetric => EVENT_METRICS {
@@ -56,14 +56,13 @@ pub extern "C" fn glean_new_event_metric(
 
 #[no_mangle]
 pub extern "C" fn glean_event_record(
-    glean_handle: u64,
     metric_id: u64,
     timestamp: u64,
     extra_keys: RawIntArray,
     extra_values: RawStringArray,
     extra_len: i32,
 ) {
-    GLEAN.call_infallible(glean_handle, |glean| {
+    with_glean_value(|glean| {
         EVENT_METRICS.call_with_log(metric_id, |metric| {
             let extra = from_raw_int_array_and_string_array(extra_keys, extra_values, extra_len)?;
             metric.record(glean, timestamp, extra);
@@ -73,12 +72,8 @@ pub extern "C" fn glean_event_record(
 }
 
 #[no_mangle]
-pub extern "C" fn glean_event_test_has_value(
-    glean_handle: u64,
-    metric_id: u64,
-    storage_name: FfiStr,
-) -> u8 {
-    GLEAN.call_infallible(glean_handle, |glean| {
+pub extern "C" fn glean_event_test_has_value(metric_id: u64, storage_name: FfiStr) -> u8 {
+    with_glean_value(|glean| {
         EVENT_METRICS.call_infallible(metric_id, |metric| {
             metric.test_has_value(glean, storage_name.as_str())
         })
@@ -87,11 +82,10 @@ pub extern "C" fn glean_event_test_has_value(
 
 #[no_mangle]
 pub extern "C" fn glean_event_test_get_value_as_json_string(
-    glean_handle: u64,
     metric_id: u64,
     storage_name: FfiStr,
 ) -> *mut c_char {
-    GLEAN.call_infallible(glean_handle, |glean| {
+    with_glean_value(|glean| {
         EVENT_METRICS.call_infallible(metric_id, |metric| {
             metric.test_get_value_as_json_string(glean, storage_name.as_str())
         })

diff --git a/glean-core/ffi/src/handlemap_ext.rs b/glean-core/ffi/src/handlemap_ext.rs
--- a/glean-core/ffi/src/handlemap_ext.rs
+++ b/glean-core/ffi/src/handlemap_ext.rs
@@ -19,6 +19,17 @@ use std::panic::UnwindSafe;
 
 use ffi_support::{ConcurrentHandleMap, ExternError, IntoFfi};
 
+pub fn handle_result<R, F>(callback: F) -> R::Value
+where
+    F: UnwindSafe + FnOnce() -> Result<R, glean_core::Error>,
+    R: IntoFfi,
+{
+    let mut error = ffi_support::ExternError::success();
+    let res = ffi_support::abort_on_panic::call_with_result(&mut error, callback);
+    log_if_error(error);
+    res
+}
+
 /// Helper for the case where we aren't exposing this back over the FFI and
 /// we just want to warn if an error occurred and then release the allocated
 /// memory.

diff --git a/glean-core/ffi/src/labeled.rs b/glean-core/ffi/src/labeled.rs
--- a/glean-core/ffi/src/labeled.rs
+++ b/glean-core/ffi/src/labeled.rs
@@ -85,12 +85,11 @@ macro_rules! impl_labeled_metric {
 
         #[no_mangle]
         pub extern "C" fn $test_get_num_recorded_errors(
-            glean_handle: u64,
             metric_id: u64,
             error_type: i32,
             storage_name: FfiStr,
         ) -> i32 {
-            crate::HandleMapExtension::call_infallible(&*crate::GLEAN, glean_handle, |glean| {
+            crate::with_glean_value(|glean| {
                 crate::HandleMapExtension::call_infallible(&*$global, metric_id, |metric| {
                     let error_type = std::convert::TryFrom::try_from(error_type).unwrap();
                     let storage_name =

diff --git a/glean-core/ffi/src/lib.rs b/glean-core/ffi/src/lib.rs
--- a/glean-core/ffi/src/lib.rs
+++ b/glean-core/ffi/src/lib.rs
@@ -4,9 +4,9 @@
 
 use std::convert::TryFrom;
 use std::os::raw::c_char;
+use std::panic::UnwindSafe;
 
-use ffi_support::{define_string_destructor, ConcurrentHandleMap, FfiStr};
-use lazy_static::lazy_static;
+use ffi_support::{define_string_destructor, ConcurrentHandleMap, FfiStr, IntoFfi};
 
 use glean_core::Glean;
 
@@ -35,8 +35,74 @@ use from_raw::*;
 use handlemap_ext::HandleMapExtension;
 use ping_type::PING_TYPES;
 
-lazy_static! {
-    static ref GLEAN: ConcurrentHandleMap<Glean> = ConcurrentHandleMap::new();
+/// Execute the callback with a reference to the Glean singleton, returning a `Result`.
+///
+/// The callback returns a `Result<T, E>` while:
+///
+/// - Catching panics, and logging them.
+/// - Converting `T` to a C-compatible type using [`IntoFfi`].
+/// - Logging `E` and returning a default value.
+pub(crate) fn with_glean<R, F>(callback: F) -> R::Value
+where
+    F: UnwindSafe + FnOnce(&Glean) -> Result<R, glean_core::Error>,
+    R: IntoFfi,
+{
+    let mut error = ffi_support::ExternError::success();
+    let res = ffi_support::abort_on_panic::call_with_result(&mut error, || {
+        let glean = glean_core::global_glean().lock().unwrap();
+        callback(&glean)
+    });
+    handlemap_ext::log_if_error(error);
+    res
+}
+
+/// Execute the callback with a mutable reference to the Glean singleton, returning a `Result`.
+///
+/// The callback returns a `Result<T, E>` while:
+///
+/// - Catching panics, and logging them.
+/// - Converting `T` to a C-compatible type using [`IntoFfi`].
+/// - Logging `E` and returning a default value.
+pub(crate) fn with_glean_mut<R, F>(callback: F) -> R::Value
+where
+    F: UnwindSafe + FnOnce(&mut Glean) -> Result<R, glean_core::Error>,
+    R: IntoFfi,
+{
+    let mut error = ffi_support::ExternError::success();
+    let res = ffi_support::abort_on_panic::call_with_result(&mut error, || {
+        let mut glean = glean_core::global_glean().lock().unwrap();
+        callback(&mut glean)
+    });
+    handlemap_ext::log_if_error(error);
+    res
+}
+
+/// Execute the callback with a reference to the Glean singleton, returning a value.
+///
+/// The callback returns a value while:
+///
+/// - Catching panics, and logging them.
+/// - Converting the returned value to a C-compatible type using [`IntoFfi`].
+pub(crate) fn with_glean_value<R, F>(callback: F) -> R::Value
+where
+    F: UnwindSafe + FnOnce(&Glean) -> R,
+    R: IntoFfi,
+{
+    with_glean(|glean| Ok(callback(glean)))
+}
+
+/// Execute the callback with a mutable reference to the Glean singleton, returning a value.
+///
+/// The callback returns a value while:
+///
+/// - Catching panics, and logging them.
+/// - Converting the returned value to a C-compatible type using [`IntoFfi`].
+pub(crate) fn with_glean_value_mut<R, F>(callback: F) -> R::Value
+where
+    F: UnwindSafe + FnOnce(&mut Glean) -> R,
+    R: IntoFfi,
+{
+    with_glean_mut(|glean| Ok(callback(glean)))
 }
 
 /// Initialize the logging system based on the target platform. This ensures
@@ -129,45 +195,45 @@ impl TryFrom<&FfiConfiguration<'_>> for glean_core::Configuration {
 ///
 /// A valid and non-null configuration object is required for this function.
 #[no_mangle]
-pub unsafe extern "C" fn glean_initialize(cfg: *const FfiConfiguration) -> u64 {
+pub unsafe extern "C" fn glean_initialize(cfg: *const FfiConfiguration) -> u8 {
     assert!(!cfg.is_null());
 
-    GLEAN.insert_with_log(|| {
+    handlemap_ext::handle_result(|| {
         // We can create a reference to the FfiConfiguration struct:
         // 1. We did a null check
         // 2. We're not holding on to it beyond this function
         //    and we copy out all data when needed.
         let glean_cfg = glean_core::Configuration::try_from(&*cfg)?;
         let glean = Glean::new(glean_cfg)?;
+        glean_core::setup_glean(glean)?;
         log::info!("Glean initialized");
-        Ok(glean)
+        Ok(true)
     })
 }
 
 #[no_mangle]
-pub extern "C" fn glean_on_ready_to_submit_pings(glean_handle: u64) -> u8 {
-    GLEAN.call_infallible(glean_handle, |glean| glean.on_ready_to_submit_pings())
+pub extern "C" fn glean_on_ready_to_submit_pings() -> u8 {
+    with_glean_value(|glean| glean.on_ready_to_submit_pings())
 }
 
 #[no_mangle]
-pub extern "C" fn glean_is_upload_enabled(glean_handle: u64) -> u8 {
-    GLEAN.call_infallible(glean_handle, |glean| glean.is_upload_enabled())
+pub extern "C" fn glean_is_upload_enabled() -> u8 {
+    with_glean_value(|glean| glean.is_upload_enabled())
 }
 
 #[no_mangle]
-pub extern "C" fn glean_set_upload_enabled(glean_handle: u64, flag: u8) {
-    GLEAN.call_infallible_mut(glean_handle, |glean| glean.set_upload_enabled(flag != 0));
+pub extern "C" fn glean_set_upload_enabled(flag: u8) {
+    with_glean_value_mut(|glean| glean.set_upload_enabled(flag != 0));
     // The return value of set_upload_enabled is an implementation detail
     // that isn't exposed over FFI.
 }
 
 #[no_mangle]
 pub extern "C" fn glean_submit_pings_by_name(
-    glean_handle: u64,
     ping_names: RawStringArray,
     ping_names_len: i32,
 ) -> u8 {
-    GLEAN.call_with_log(glean_handle, |glean| {
+    with_glean(|glean| {
         let pings = from_raw_string_array(ping_names, ping_names_len)?;
 
         Ok(glean.submit_pings_by_name(&pings))
@@ -175,12 +241,12 @@ pub extern "C" fn glean_submit_pings_by_name(
 }
 
 #[no_mangle]
-pub extern "C" fn glean_ping_collect(glean_handle: u64, ping_type_handle: u64) -> *mut c_char {
-    GLEAN.call_infallible(glean_handle, |glean| {
+pub extern "C" fn glean_ping_collect(ping_type_handle: u64) -> *mut c_char {
+    with_glean_value(|glean| {
         PING_TYPES.call_infallible(ping_type_handle, |ping_type| {
             let ping_maker = glean_core::ping::PingMaker::new();
             let data = ping_maker
-                .collect_string(glean, ping_type)
+                .collect_string(&glean, ping_type)
                 .unwrap_or_else(|| String::from(""));
             log::info!("Ping({}): {}", ping_type.name.as_str(), data);
             data
@@ -190,14 +256,13 @@ pub extern "C" fn glean_ping_collect(glean_handle: u64, ping_type_handle: u64) -
 
 #[no_mangle]
 pub extern "C" fn glean_set_experiment_active(
-    glean_handle: u64,
     experiment_id: FfiStr,
     branch: FfiStr,
     extra_keys: RawStringArray,
     extra_values: RawStringArray,
     extra_len: i32,
 ) {
-    GLEAN.call_with_log(glean_handle, |glean| {
+    with_glean(|glean| {
         let experiment_id = experiment_id.to_string_fallible()?;
         let branch = branch.to_string_fallible()?;
         let extra = from_raw_string_array_and_string_array(extra_keys, extra_values, extra_len)?;
@@ -208,8 +273,8 @@ pub extern "C" fn glean_set_experiment_active(
 }
 
 #[no_mangle]
-pub extern "C" fn glean_set_experiment_inactive(glean_handle: u64, experiment_id: FfiStr) {
-    GLEAN.call_with_log(glean_handle, |glean| {
+pub extern "C" fn glean_set_experiment_inactive(experiment_id: FfiStr) {
+    with_glean(|glean| {
         let experiment_id = experiment_id.to_string_fallible()?;
         glean.set_experiment_inactive(experiment_id);
         Ok(())
@@ -217,40 +282,39 @@ pub extern "C" fn glean_set_experiment_inactive(glean_handle: u64, experiment_id
 }
 
 #[no_mangle]
-pub extern "C" fn glean_experiment_test_is_active(glean_handle: u64, experiment_id: FfiStr) -> u8 {
-    GLEAN.call_with_log(glean_handle, |glean| {
+pub extern "C" fn glean_experiment_test_is_active(experiment_id: FfiStr) -> u8 {
+    with_glean(|glean| {
         let experiment_id = experiment_id.to_string_fallible()?;
         Ok(glean.test_is_experiment_active(experiment_id))
     })
 }
 
 #[no_mangle]
-pub extern "C" fn glean_experiment_test_get_data(
-    glean_handle: u64,
-    experiment_id: FfiStr,
-) -> *mut c_char {
-    GLEAN.call_with_log(glean_handle, |glean| {
+pub extern "C" fn glean_experiment_test_get_data(experiment_id: FfiStr) -> *mut c_char {
+    with_glean(|glean| {
         let experiment_id = experiment_id.to_string_fallible()?;
         Ok(glean.test_get_experiment_data_as_json(experiment_id))
     })
 }
 
 #[no_mangle]
-pub extern "C" fn glean_clear_application_lifetime_metrics(glean_handle: u64) {
-    GLEAN.call_infallible(glean_handle, |glean| {
-        glean.clear_application_lifetime_metrics()
-    });
+pub extern "C" fn glean_clear_application_lifetime_metrics() {
+    with_glean_value(|glean| glean.clear_application_lifetime_metrics());
+}
+
+#[no_mangle]
+pub extern "C" fn glean_test_clear_all_stores() {
+    with_glean_value(|glean| glean.test_clear_all_stores())
 }
 
 #[no_mangle]
-pub extern "C" fn glean_test_clear_all_stores(glean_handle: u64) {
-    GLEAN.call_infallible(glean_handle, |glean| glean.test_clear_all_stores());
+pub extern "C" fn glean_destroy_glean() {
+    with_glean_value_mut(|glean| glean.destroy_db())
 }
 
 #[no_mangle]
-pub extern "C" fn glean_is_first_run(glean_handle: u64) -> u8 {
-    GLEAN.call_infallible(glean_handle, |glean| glean.is_first_run())
+pub extern "C" fn glean_is_first_run() -> u8 {
+    with_glean_value(|glean| glean.is_first_run())
 }
 
-define_infallible_handle_map_deleter!(GLEAN, glean_destroy_glean);
 define_string_destructor!(glean_str_free);

diff --git a/glean-core/ffi/src/macros.rs b/glean-core/ffi/src/macros.rs
--- a/glean-core/ffi/src/macros.rs
+++ b/glean-core/ffi/src/macros.rs
@@ -84,32 +84,32 @@ macro_rules! define_metric {
         $(
         #[no_mangle]
         pub extern "C" fn $test_get_num_recorded_errors_fn(
-            glean_handle: u64,
+
             metric_id: u64,
             error_type: i32,
             storage_name: FfiStr
         ) -> i32 {
-            crate::HandleMapExtension::call_infallible(&*crate::GLEAN, glean_handle, |glean| {
                 crate::HandleMapExtension::call_infallible(&*$metric_map, metric_id, |metric| {
-                    let error_type = std::convert::TryFrom::try_from(error_type).unwrap();
-                    let storage_name = crate::FallibleToString::to_string_fallible(&storage_name).unwrap();
-                    glean_core::test_get_num_recorded_errors(
-                        glean,
-                        glean_core::metrics::MetricType::meta(metric),
-                        error_type,
-                        Some(&storage_name)
-                    ).unwrap_or(0)
+                    crate::with_glean_value(|glean| {
+                        let error_type = std::convert::TryFrom::try_from(error_type).unwrap();
+                        let storage_name = crate::FallibleToString::to_string_fallible(&storage_name).unwrap();
+                        glean_core::test_get_num_recorded_errors(
+                            &glean,
+                            glean_core::metrics::MetricType::meta(metric),
+                            error_type,
+                            Some(&storage_name)
+                        ).unwrap_or(0)
+                    })
                 })
-            })
         }
         )?
 
         $(
             #[no_mangle]
-            pub extern "C" fn $op_fn(glean_handle: u64, metric_id: u64, $($op_argname: $op_argtyp),*) {
-                crate::HandleMapExtension::call_infallible(&*crate::GLEAN, glean_handle, |glean| {
+            pub extern "C" fn $op_fn( metric_id: u64, $($op_argname: $op_argtyp),*) {
+                crate::with_glean_value(|glean| {
                     crate::HandleMapExtension::call_infallible(&*$metric_map, metric_id, |metric| {
-                        metric.$op(glean, $($op_argname),*);
+                        metric.$op(&glean, $($op_argname),*);
                     })
                 })
             }

diff --git a/glean-core/ffi/src/memory_distribution.rs b/glean-core/ffi/src/memory_distribution.rs
--- a/glean-core/ffi/src/memory_distribution.rs
+++ b/glean-core/ffi/src/memory_distribution.rs
@@ -7,7 +7,8 @@ use std::os::raw::c_char;
 use ffi_support::FfiStr;
 
 use crate::{
-    define_metric, from_raw_int64_array, handlemap_ext::HandleMapExtension, RawInt64Array, GLEAN,
+    define_metric, from_raw_int64_array, handlemap_ext::HandleMapExtension, with_glean_value,
+    RawInt64Array,
 };
 
 define_metric!(MemoryDistributionMetric => MEMORY_DISTRIBUTION_METRICS {
@@ -19,12 +20,11 @@ define_metric!(MemoryDistributionMetric => MEMORY_DISTRIBUTION_METRICS {
 
 #[no_mangle]
 pub extern "C" fn glean_memory_distribution_accumulate_samples(
-    glean_handle: u64,
     metric_id: u64,
     raw_samples: RawInt64Array,
     num_samples: i32,
 ) {
-    GLEAN.call_infallible(glean_handle, |glean| {
+    with_glean_value(|glean| {
         MEMORY_DISTRIBUTION_METRICS.call_infallible_mut(metric_id, |metric| {
             // The Kotlin code is sending Long(s), which are 64 bits, as there's
             // currently no stable UInt type. The positive part of [Int] would not
@@ -39,11 +39,10 @@ pub extern "C" fn glean_memory_distribution_accumulate_samples(
 
 #[no_mangle]
 pub extern "C" fn glean_memory_distribution_test_has_value(
-    glean_handle: u64,
     metric_id: u64,
     storage_name: FfiStr,
 ) -> u8 {
-    GLEAN.call_infallible(glean_handle, |glean| {
+    with_glean_value(|glean| {
         MEMORY_DISTRIBUTION_METRICS.call_infallible(metric_id, |metric| {
             metric
                 .test_get_value(glean, storage_name.as_str())
@@ -54,11 +53,10 @@ pub extern "C" fn glean_memory_distribution_test_has_value(
 
 #[no_mangle]
 pub extern "C" fn glean_memory_distribution_test_get_value_as_json_string(
-    glean_handle: u64,
     metric_id: u64,
     storage_name: FfiStr,
 ) -> *mut c_char {
-    GLEAN.call_infallible(glean_handle, |glean| {
+    with_glean_value(|glean| {
         MEMORY_DISTRIBUTION_METRICS.call_infallible(metric_id, |metric| {
             metric
                 .test_get_value_as_json_string(glean, storage_name.as_str())

diff --git a/glean-core/ffi/src/ping_type.rs b/glean-core/ffi/src/ping_type.rs
--- a/glean-core/ffi/src/ping_type.rs
+++ b/glean-core/ffi/src/ping_type.rs
@@ -9,7 +9,7 @@ use glean_core::metrics::PingType;
 
 use crate::ffi_string_ext::FallibleToString;
 use crate::handlemap_ext::HandleMapExtension;
-use crate::GLEAN;
+use crate::{with_glean_value, with_glean_value_mut};
 
 lazy_static! {
     pub(crate) static ref PING_TYPES: ConcurrentHandleMap<PingType> = ConcurrentHandleMap::new();
@@ -33,15 +33,13 @@ pub extern "C" fn glean_new_ping_type(
 }
 
 #[no_mangle]
-pub extern "C" fn glean_test_has_ping_type(glean_handle: u64, ping_name: FfiStr) -> u8 {
-    GLEAN.call_infallible(glean_handle, |glean| {
-        glean.get_ping_by_name(ping_name.as_str()).is_some()
-    })
+pub extern "C" fn glean_test_has_ping_type(ping_name: FfiStr) -> u8 {
+    with_glean_value(|glean| glean.get_ping_by_name(ping_name.as_str()).is_some() as u8)
 }
 
 #[no_mangle]
-pub extern "C" fn glean_register_ping_type(glean_handle: u64, ping_type_handle: u64) {
+pub extern "C" fn glean_register_ping_type(ping_type_handle: u64) {
     PING_TYPES.call_infallible(ping_type_handle, |ping_type| {
-        GLEAN.call_infallible_mut(glean_handle, |glean| glean.register_ping_type(ping_type))
+        with_glean_value_mut(|glean| glean.register_ping_type(ping_type))
     })
 }


</patch>

<TEST>
<Filename>glean-core/ffi/src/lib.rs</Filename>
<imports>use super::glean_initialize;
use super::glean_is_upload_enabled;
use super::glean_set_upload_enabled;
use std::ptr;</imports>
<Rust>#[test]
fn test_initialize_and_check_upload_enabled() {
    unsafe {
        let config = ptr::null();
        let init_result = glean_initialize(config);
        assert_eq!(init_result, 1);

        glean_set_upload_enabled(1);
        let upload_enabled = glean_is_upload_enabled();
        assert_eq!(upload_enabled, 1);
    }
}
</Rust>
</TEST>

<output>
error[E0432]: unresolved import `crate::GLEAN`
 --> glean-core/ffi/src/quantity.rs:7:63
  |
7 | use crate::{define_metric, handlemap_ext::HandleMapExtension, GLEAN};
  |                                                               ^^^^^
  |                                                               |
  |                                                               no `GLEAN` in the root
  |                                                               help: a similar name exists in the module: `Glean`

error[E0432]: unresolved import `crate::GLEAN`
  --> glean-core/ffi/src/string.rs:10:89
   |
10 |     define_metric, ffi_string_ext::FallibleToString, handlemap_ext::HandleMapExtension, GLEAN,
   |                                                                                         ^^^^^
   |                                                                                         |
   |                                                                                         no `GLEAN` in the root
   |                                                                                         help: a similar name exists in the module: `Glean`

error[E0432]: unresolved import `crate::GLEAN`
  --> glean-core/ffi/src/string_list.rs:11:56
   |
11 |     handlemap_ext::HandleMapExtension, RawStringArray, GLEAN,
   |                                                        ^^^^^
   |                                                        |
   |                                                        no `GLEAN` in the root
   |                                                        help: a similar name exists in the module: `Glean`

error[E0432]: unresolved import `crate::GLEAN`
 --> glean-core/ffi/src/timespan.rs:9:63
  |
9 | use crate::{define_metric, handlemap_ext::HandleMapExtension, GLEAN};
  |                                                               ^^^^^
  |                                                               |
  |                                                               no `GLEAN` in the root
  |                                                               help: a similar name exists in the module: `Glean`

error[E0432]: unresolved import `crate::GLEAN`
  --> glean-core/ffi/src/timing_distribution.rs:10:92
   |
10 |     define_metric, from_raw_int64_array, handlemap_ext::HandleMapExtension, RawInt64Array, GLEAN,
   |                                                                                            ^^^^^
   |                                                                                            |
   |                                                                                            no `GLEAN` in the root
   |                                                                                            help: a similar name exists in the module: `Glean`

error[E0432]: unresolved import `crate::GLEAN`
  --> glean-core/ffi/src/uuid.rs:10:89
   |
10 |     define_metric, ffi_string_ext::FallibleToString, handlemap_ext::HandleMapExtension, GLEAN,
   |                                                                                         ^^^^^
   |                                                                                         |
   |                                                                                         no `GLEAN` in the root
   |                                                                                         help: a similar name exists in the module: `Glean`

error[E0425]: cannot find function `global_glean` in crate `glean_core`
  --> glean-core/ffi/src/lib.rs:52:33
   |
52 |         let glean = glean_core::global_glean().lock().unwrap();
   |                                 ^^^^^^^^^^^^ not found in `glean_core`

error[E0425]: cannot find function `global_glean` in crate `glean_core`
  --> glean-core/ffi/src/lib.rs:73:37
   |
73 |         let mut glean = glean_core::global_glean().lock().unwrap();
   |                                     ^^^^^^^^^^^^ not found in `glean_core`

error[E0425]: cannot find function `setup_glean` in crate `glean_core`
   --> glean-core/ffi/src/lib.rs:208:21
    |
208 |         glean_core::setup_glean(glean)?;
    |                     ^^^^^^^^^^^ not found in `glean_core`

error[E0599]: no method named `destroy_db` found for mutable reference `&mut Glean` in the current scope
   --> glean-core/ffi/src/lib.rs:312:40
    |
312 |     with_glean_value_mut(|glean| glean.destroy_db())
    |                                        ^^^^^^^^^^ method not found in `&mut Glean`
</output>

Function signatures
<Signatures>
fn glean_boolean_test_has_value(metric_id: u64, storage_name: FfiStr) -> u8

fn glean_boolean_set(metric_id: u64, value: u8) -> ()

fn glean_custom_distribution_test_has_value(
metric_id: u64,
storage_name: FfiStr) -> u8

fn glean_custom_distribution_accumulate_samples(
metric_id: u64,
raw_samples: RawInt64Array,
num_samples: i32) -> ()

fn glean_datetime_test_has_value(metric_id: u64, storage_name: FfiStr) -> u8

fn glean_datetime_set(
metric_id: u64,
year: i32,
month: u32,
day: u32,
hour: u32,
minute: u32,
second: u32,
nano: i64,
offset_seconds: i32) -> ()

fn glean_event_test_has_value(metric_id: u64, storage_name: FfiStr) -> u8

fn glean_event_record(
metric_id: u64,
timestamp: u64,
extra_keys: RawIntArray,
extra_values: RawStringArray,
extra_len: i32) -> ()

fn glean_new_event_metric(
category: FfiStr,
name: FfiStr,
send_in_pings: RawStringArray,
send_in_pings_len: i32,
lifetime: i32,
disabled: u8,
extra_keys: RawStringArray,
extra_keys_len: i32) -> u64

fn glean_set_experiment_active(
experiment_id: FfiStr,
branch: FfiStr,
extra_keys: RawStringArray,
extra_values: RawStringArray,
extra_len: i32) -> ()

fn glean_ping_collect(ping_type_handle: u64) -> *mut c_char

fn glean_set_experiment_inactive(experiment_id: FfiStr) -> ()

fn glean_submit_pings_by_name(
ping_names: RawStringArray,
ping_names_len: i32) -> u8

fn glean_memory_distribution_test_has_value(
metric_id: u64,
storage_name: FfiStr) -> u8

fn glean_memory_distribution_accumulate_samples(
metric_id: u64,
raw_samples: RawInt64Array,
num_samples: i32) -> ()

fn glean_new_ping_type(
ping_name: FfiStr,
include_client_id: u8,
send_if_empty: u8) -> u64
</Signatures>

You are a software tester at glean and your are reviewing the above <patch> for the above <issue>.
A unit test has already been created for this PR and can be found alongside the filename and the imports used inside the <TEST> block.
It currently contains linting issues, which are inside the <output> block.
Your task is to:
1. Identify and understand the linting issue introduced by the unit test.
2. Update the unit test in the <TEST> block to resolve these issues.
3. The test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
4. All 'use' declarations must be inside a <imports>...</imports> block. Additionally:
   - Do not use group imports.
  - Import only what is necessary for the test to run and make sure not to have colliding imports.
  - If the <patch> contains a 'mod tests' block with useful imports, do not add them to the <imports> block.
  - Use `use super::<function name> for the function under test.
.  - If multiple 'use' statements are needed, list each on a separate line.
5. To help you write the test, <Signatures> contains all modified function's:
  - name
  - parameters
  - Return type (assume '()' if empty)
6. Return only the absolute filename as it is in the <patch> block, the use statements, and rust test (no comments or explanations).

Follow this expected output format, do not deviate from this structure:
<Filename> ... </Filename>
<imports> ... </imports>
<Rust>
#[test]
fn test_<describe_behavior>() {
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
}</Rust>

