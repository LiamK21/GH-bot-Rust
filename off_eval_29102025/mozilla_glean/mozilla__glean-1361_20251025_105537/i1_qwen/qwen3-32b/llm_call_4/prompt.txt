Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Implement events for the RLB
As the title says.

Note that this will also require dealing with the TODO tests in ["tests.rs"](https://searchfox.org/glean/source/glean-core/rlb/src/test.rs)
</issue>

Patch:
<patch>
diff --git a/glean-core/rlb/src/lib.rs b/glean-core/rlb/src/lib.rs
--- a/glean-core/rlb/src/lib.rs
+++ b/glean-core/rlb/src/lib.rs
@@ -47,8 +47,9 @@ pub use configuration::Configuration;
 use configuration::DEFAULT_GLEAN_ENDPOINT;
 pub use core_metrics::ClientInfoMetrics;
 pub use glean_core::{
-    global_glean, metrics::TimeUnit, setup_glean, CommonMetricData, Error, ErrorType, Glean,
-    Lifetime, Result,
+    global_glean,
+    metrics::{RecordedEvent, TimeUnit},
+    setup_glean, CommonMetricData, Error, ErrorType, Glean, Lifetime, Result,
 };
 use private::RecordedExperimentData;

diff --git a/glean-core/rlb/src/private/event.rs b/glean-core/rlb/src/private/event.rs
--- a/glean-core/rlb/src/private/event.rs
+++ b/glean-core/rlb/src/private/event.rs
@@ -0,0 +1,173 @@
+// This Source Code Form is subject to the terms of the Mozilla Public
+// License, v. 2.0. If a copy of the MPL was not distributed with this
+// file, You can obtain one at https://mozilla.org/MPL/2.0/.
+
+use inherent::inherent;
+use std::{collections::HashMap, marker::PhantomData, sync::Arc};
+
+use glean_core::metrics::MetricType;
+use glean_core::traits;
+
+use crate::{dispatcher, ErrorType, RecordedEvent};
+
+pub use glean_core::traits::NoExtraKeys;
+
+// We need to wrap the glean-core type: otherwise if we try to implement
+// the trait for the metric in `glean_core::metrics` we hit error[E0117]:
+// only traits defined in the current crate can be implemented for arbitrary
+// types.
+
+/// This implements the developer facing API for recording event metrics.
+///
+/// Instances of this class type are automatically generated by the parsers
+/// at build time, allowing developers to record values that were previously
+/// registered in the metrics.yaml file.
+#[derive(Clone)]
+pub struct EventMetric<K> {
+    pub(crate) inner: Arc<glean_core::metrics::EventMetric>,
+    extra_keys: PhantomData<K>,
+}
+
+impl<K: traits::ExtraKeys> EventMetric<K> {
+    /// The public constructor used by automatically generated metrics.
+    pub fn new(meta: glean_core::CommonMetricData) -> Self {
+        let allowed_extra_keys = K::ALLOWED_KEYS.iter().map(|s| s.to_string()).collect();
+        let inner = Arc::new(glean_core::metrics::EventMetric::new(
+            meta,
+            allowed_extra_keys,
+        ));
+        Self {
+            inner,
+            extra_keys: PhantomData,
+        }
+    }
+}
+
+#[inherent(pub)]
+impl<K: traits::ExtraKeys> traits::Event for EventMetric<K> {
+    type Extra = K;
+
+    fn record<M: Into<Option<HashMap<<Self as traits::Event>::Extra, String>>>>(&self, extra: M) {
+        const NANOS_PER_MILLI: u64 = 1_000_000;
+        let now = time::precise_time_ns() / NANOS_PER_MILLI;
+
+        // Translate from [ExtraKey -> String] to a [Int -> String] map
+        let extra = extra
+            .into()
+            .map(|h| h.into_iter().map(|(k, v)| (k.index(), v)).collect());
+        let metric = Arc::clone(&self.inner);
+        dispatcher::launch(move || crate::with_glean(|glean| metric.record(glean, now, extra)));
+    }
+
+    fn test_get_value<'a, S: Into<Option<&'a str>>>(
+        &self,
+        ping_name: S,
+    ) -> Option<Vec<RecordedEvent>> {
+        dispatcher::block_on_queue();
+
+        let queried_ping_name = ping_name
+            .into()
+            .unwrap_or_else(|| &self.inner.meta().send_in_pings[0]);
+
+        crate::with_glean(|glean| self.inner.test_get_value(glean, queried_ping_name))
+    }
+
+    fn test_get_num_recorded_errors<'a, S: Into<Option<&'a str>>>(
+        &self,
+        error: ErrorType,
+        ping_name: S,
+    ) -> i32 {
+        dispatcher::block_on_queue();
+
+        crate::with_glean_mut(|glean| {
+            glean_core::test_get_num_recorded_errors(
+                &glean,
+                self.inner.meta(),
+                error,
+                ping_name.into(),
+            )
+            .unwrap_or(0)
+        })
+    }
+}
+
+#[cfg(test)]
+mod test {
+    use super::*;
+    use crate::common_test::{lock_test, new_glean};
+    use crate::CommonMetricData;
+
+    #[test]
+    fn no_extra_keys() {
+        let _lock = lock_test();
+        let _t = new_glean(None, true);
+
+        let metric: EventMetric<NoExtraKeys> = EventMetric::new(CommonMetricData {
+            name: "event".into(),
+            category: "test".into(),
+            send_in_pings: vec!["test1".into()],
+            ..Default::default()
+        });
+
+        metric.record(None);
+        metric.record(None);
+
+        let data = metric.test_get_value(None).expect("no event recorded");
+        assert_eq!(2, data.len());
+        assert!(data[0].timestamp <= data[1].timestamp);
+    }
+
+    #[test]
+    fn with_extra_keys() {
+        let _lock = lock_test();
+        let _t = new_glean(None, true);
+
+        #[derive(Debug, Clone, Copy, Hash, Eq, PartialEq)]
+        enum SomeExtra {
+            Key1,
+            Key2,
+        }
+
+        impl glean_core::traits::ExtraKeys for SomeExtra {
+            const ALLOWED_KEYS: &'static [&'static str] = &["key1", "key2"];
+
+            fn index(self) -> i32 {
+                self as i32
+            }
+        }
+
+        let metric: EventMetric<SomeExtra> = EventMetric::new(CommonMetricData {
+            name: "event".into(),
+            category: "test".into(),
+            send_in_pings: vec!["test1".into()],
+            ..Default::default()
+        });
+
+        let mut map1 = HashMap::new();
+        map1.insert(SomeExtra::Key1, "1".into());
+        metric.record(map1);
+
+        let mut map2 = HashMap::new();
+        map2.insert(SomeExtra::Key1, "1".into());
+        map2.insert(SomeExtra::Key2, "2".into());
+        metric.record(map2);
+
+        metric.record(None);
+
+        let data = metric.test_get_value(None).expect("no event recorded");
+        assert_eq!(3, data.len());
+        assert!(data[0].timestamp <= data[1].timestamp);
+        assert!(data[1].timestamp <= data[2].timestamp);
+
+        let mut map = HashMap::new();
+        map.insert("key1".into(), "1".into());
+        assert_eq!(Some(map), data[0].extra);
+
+        let mut map = HashMap::new();
+        map.insert("key1".into(), "1".into());
+        map.insert("key2".into(), "2".into());
+        assert_eq!(Some(map), data[1].extra);
+
+        assert_eq!(None, data[2].extra);
+    }
+}

diff --git a/glean-core/rlb/src/private/mod.rs b/glean-core/rlb/src/private/mod.rs
--- a/glean-core/rlb/src/private/mod.rs
+++ b/glean-core/rlb/src/private/mod.rs
@@ -6,6 +6,7 @@
 
 mod boolean;
 mod counter;
+mod event;
 mod labeled;
 mod ping;
 mod quantity;
@@ -17,6 +18,7 @@ mod uuid;
 pub use self::uuid::UuidMetric;
 pub use boolean::BooleanMetric;
 pub use counter::CounterMetric;
+pub use event::EventMetric;
 pub use labeled::{AllowLabeled, LabeledMetric};
 pub use ping::PingType;
 pub use quantity::QuantityMetric;

diff --git a/glean-core/src/traits/event.rs b/glean-core/src/traits/event.rs
--- a/glean-core/src/traits/event.rs
+++ b/glean-core/src/traits/event.rs
@@ -3,14 +3,86 @@
 // file, You can obtain one at https://mozilla.org/MPL/2.0/.
 
 use std::collections::HashMap;
+use std::convert::TryFrom;
+use std::hash::Hash;
 
 use crate::event_database::RecordedEvent;
+use crate::ErrorType;
+
+/// Extra keys for events.
+///
+/// Extra keys need to be pre-defined and map to a string representation.
+///
+/// For user-defined `EventMetric`s these will be defined as `enums`.
+/// Each variant will correspond to an entry in the `ALLOWED_KEYS` list.
+/// The Glean SDK requires the keys as strings for submission in pings,
+/// whereas in code we want to provide users a type to work with
+/// (e.g. to avoid typos or misuse of the API).
+pub trait ExtraKeys: Hash + Eq + PartialEq + Copy {
+    /// List of allowed extra keys as strings.
+    const ALLOWED_KEYS: &'static [&'static str];
+
+    /// The index of the extra key.
+    ///
+    /// It corresponds to its position in the associated `ALLOWED_KEYS` list.
+    ///
+    /// *Note*: An index of `-1` indicates an invalid / non-existing extra key.
+    /// Invalid / non-existing extra keys will be recorded as an error.
+    /// This cannot happen for generated code.
+    fn index(self) -> i32;
+}
+
+/// Default of no extra keys for events.
+///
+/// An enum with no values for convenient use as the default set of extra keys
+/// that an `EventMetric` can accept.
+///
+/// *Note*: There exist no values for this enum, it can never exist.
+/// It its equivalent to the [`never / !` type](https://doc.rust-lang.org/std/primitive.never.html).
+#[derive(Clone, Copy, Debug, Hash, Eq, PartialEq)]
+pub enum NoExtraKeys {}
+
+impl ExtraKeys for NoExtraKeys {
+    const ALLOWED_KEYS: &'static [&'static str] = &[];
+
+    fn index(self) -> i32 {
+        // This index will never be used.
+        -1
+    }
+}
+
+/// The possible errors when parsing to an extra key.
+pub enum EventRecordingError {
+    /// The id doesn't correspond to a valid extra key
+    InvalidId,
+    /// The value doesn't correspond to a valid extra key
+    InvalidExtraKey,
+}
+
+impl TryFrom<i32> for NoExtraKeys {
+    type Error = EventRecordingError;
+
+    fn try_from(_value: i32) -> Result<Self, Self::Error> {
+        Err(EventRecordingError::InvalidExtraKey)
+    }
+}
+
+impl TryFrom<&str> for NoExtraKeys {
+    type Error = EventRecordingError;
+
+    fn try_from(_value: &str) -> Result<Self, Self::Error> {
+        Err(EventRecordingError::InvalidExtraKey)
+    }
+}
 
 /// A description for the `EventMetric` type.
 ///
 /// When changing this trait, make sure all the operations are
 /// implemented in the related type in `../metrics/`.
 pub trait Event {
+    /// The type of the allowed extra keys for this event.
+    type Extra: ExtraKeys;
+
     /// Records an event.
     ///
     /// # Arguments
@@ -19,7 +91,7 @@ pub trait Event {
     ///   the metric's `allowed_extra_keys` vector where the key's string is
     ///   looked up. If any key index is out of range, an error is reported and
     ///   no event is recorded.
-    fn record<M: Into<Option<HashMap<i32, String>>>>(&self, extra: M);
+    fn record<M: Into<Option<HashMap<Self::Extra, String>>>>(&self, extra: M);
 
     /// **Exported for test purposes.**
     ///
@@ -38,16 +110,20 @@ pub trait Event {
 
     /// **Exported for test purposes.**
     ///
-    /// Gets the currently stored events for this event metric as a JSON-encoded string.
-    ///
-    /// This doesn't clear the stored value.
+    /// Gets the number of recorded errors for the given metric and error type.
     ///
     /// # Arguments
     ///
+    /// * `error` - The type of error
     /// * `ping_name` - represents the optional name of the ping to retrieve the
     ///   metric for. Defaults to the first value in `send_in_pings`.
-    fn test_get_value_as_json_string<'a, S: Into<Option<&'a str>>>(
+    ///
+    /// # Returns
+    ///
+    /// The number of errors reported.
+    fn test_get_num_recorded_errors<'a, S: Into<Option<&'a str>>>(
         &self,
+        error: ErrorType,
         ping_name: S,
-    ) -> Option<String>;
+    ) -> i32;
 }

diff --git a/glean-core/src/traits/mod.rs b/glean-core/src/traits/mod.rs
--- a/glean-core/src/traits/mod.rs
+++ b/glean-core/src/traits/mod.rs
@@ -22,13 +22,14 @@ mod timespan;
 mod timing_distribution;
 mod uuid;
 
-pub use crate::event_database::RecordedEvent;
-
 pub use self::boolean::Boolean;
 pub use self::counter::Counter;
 pub use self::custom_distribution::CustomDistribution;
 pub use self::datetime::Datetime;
 pub use self::event::Event;
+pub use self::event::EventRecordingError;
+pub use self::event::ExtraKeys;
+pub use self::event::NoExtraKeys;
 pub use self::jwe::Jwe;
 pub use self::labeled::Labeled;
 pub use self::memory_distribution::MemoryDistribution;


</patch>

<TEST>
<Filename>glean-core/rlb/src/private/event.rs</Filename>
<imports>use crate::common_test::{lock_test, new_glean};
use glean_core::ErrorType;</imports>
<Rust>#[test]
fn test_invalid_extra_key_records_error() {
    let _lock = lock_test();
    let _t = new_glean(None, true);

    #[derive(Debug, Clone, Copy, Hash, Eq, PartialEq)]
    enum TestExtra {
        ValidKey,
        InvalidKey,
    }

    impl ExtraKeys for TestExtra {
        const ALLOWED_KEYS: &'static [&'static str] = &["valid_key"];
        fn index(self) -> i32 { self as i32 }
    }

    let metric: EventMetric<TestExtra> = EventMetric::new(glean_core::CommonMetricData {
        name: "event".into(),
        category: "test".into(),
        send_in_pings: vec!["test1".into()],
        ..Default::default()
    });

    let mut invalid_map = std::collections::HashMap::new();
    invalid_map.insert(TestExtra::InvalidKey, "value".into());

    metric.record(invalid_map);

    let errors = metric.test_get_num_recorded_errors(ErrorType::InvalidExtraKey, None);
    assert_eq!(1, errors);
}
</Rust>
</TEST>

<output>
error[E0252]: the name `lock_test` is defined multiple times
   --> glean-core/rlb/src/private/event.rs:100:30
    |
97  |     use crate::common_test::{lock_test, new_glean};
    |                              --------- previous import of the value `lock_test` here
...
100 |     use crate::common_test::{lock_test, new_glean};
    |                              ^^^^^^^^^--
    |                              |
    |                              `lock_test` reimported here
    |                              help: remove unnecessary import
    |
    = note: `lock_test` must be defined only once in the value namespace of this module

error[E0252]: the name `new_glean` is defined multiple times
   --> glean-core/rlb/src/private/event.rs:100:41
    |
97  |     use crate::common_test::{lock_test, new_glean};
    |                                         --------- previous import of the value `new_glean` here
...
100 |     use crate::common_test::{lock_test, new_glean};
    |                                         ^^^^^^^^^ `new_glean` reimported here
    |
    = note: `new_glean` must be defined only once in the value namespace of this module

error[E0405]: cannot find trait `ExtraKeys` in this scope
   --> glean-core/rlb/src/private/event.rs:188:14
    |
188 |         impl ExtraKeys for TestExtra {
    |              ^^^^^^^^^ not found in this scope
    |
help: consider importing one of these traits
    |
96  +     use crate::private::event::traits::ExtraKeys;
    |
96  +     use glean_core::traits::ExtraKeys;
    |
</output>

Function signatures
<Signatures>

</Signatures>

You are a software tester at glean and your are reviewing the above <patch> for the above <issue>.
A unit test has already been created for this PR and can be found alongside the filename and the imports used inside the <TEST> block.
It currently fails on codebase after the patch, which the errors in the <output> block.
Your task is to:
1. Identify and understand the errors introduced by the unit test.
2. Update the unit test in the <TEST> block in order for it to fail on the code before the patch, and pass after, hence verifying that the patch resolves the issue.
3. All 'use' declarations must be inside a <imports>...</imports> block. Additionally:
   - Do not use group imports.
  - Import only what is necessary for the test to run and make sure not to have colliding imports.
  - If the <patch> contains a 'mod tests' block with useful imports, do not add them to the <imports> block.
  - Use `use super::<function name> for the function under test.
.  - If multiple 'use' statements are needed, list each on a separate line.
4. To help you write the test, <Signatures> contains all modified function's:
  - name
  - parameters
  - Return type (assume '()' if empty)
5. Return only the absolute filename as it is in the <patch> block, the use statements, and rust test (no comments or explanations).

Follow this expected output format, do not deviate from this structure:
<Filename> ... </Filename>
<imports> ... </imports>
<Rust>
#[test]
fn test_<describe_behavior>() {
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
}</Rust>

