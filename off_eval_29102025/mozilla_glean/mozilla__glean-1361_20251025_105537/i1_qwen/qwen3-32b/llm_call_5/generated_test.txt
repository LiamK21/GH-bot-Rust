#[test]
fn test_invalid_extra_key_records_error() {
    let _lock = lock_test();
    let _t = new_glean(None, true);

    #[derive(Debug, Clone, Copy, Hash, Eq, PartialEq)]
    enum TestExtra {
        ValidKey,      // index 0 for allowed key
        InvalidKey,    // index 1 (out of range)
    }

    impl ExtraKeys for TestExtra {
        const ALLOWED_KEYS: &'static [&'static str] = &["valid_key"];
        fn index(self) -> i32 { self as i32 }
    }

    let metric: EventMetric<TestExtra> = EventMetric::new(glean_core::CommonMetricData {
        name: "event".into(),
        category: "test".into(),
        send_in_pings: vec!["test1".into()],
        ..Default::default()
    });

    // Attempt to record a valid key (allowed)
    {
        let mut map = std::collections::HashMap::new();
        map.insert(TestExtra::ValidKey, "value".into());
        metric.record(map);
    }

    // Attempt to record an invalid key (index 1 vs allowed length 1)
    {
        let mut map = std::collections::HashMap::new();
        map.insert(TestExtra::InvalidKey, "value".into());
        metric.record(map);
    }

    // Expect an ErrorType::InvalidValue due to invalid key index
    let errors = metric.test_get_num_recorded_errors(ErrorType::InvalidValue, None);
    assert_eq!(1, errors);
}