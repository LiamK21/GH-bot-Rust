<Filename>glean-core/src/lib_unit_tests.rs</Filename>
<imports>
use super::Glean;
use super::MetricsEnabledConfig;
use super::StringMetric;
use super::CommonMetricData;
use super::new_glean;
use serde_json::json;
</imports>
<Rust>
#[test]
fn test_merge_metrics_enabled_config() {
  let (glean, _t) = new_glean(None);
  let metric1 = StringMetric::new(CommonMetricData {
      category: "category1".to_string(),
      name: "metric1".to_string(),
      send_in_pings: vec!["baseline".to_string()],
      ..Default::default()
  });
  let metric2 = StringMetric::new(CommonMetricData {
      category: "category2".to_string(),
      name: "metric2".to_string(),
      send_in_pings: vec!["baseline".to_string()],
      ..Default::default()
  });
  let metrics_enabled_config1 = json!({
      "category1.metric1": true,
  }).to_string();
  let metrics_enabled_config2 = json!({
      "category2.metric2": true,
  }).to_string();
  glean.set_metrics_enabled_config(
      MetricsEnabledConfig::try_from(metrics_enabled_config1).unwrap(),
  );
  metric1.set_sync(&glean, "VALUE");
  assert_eq!(
      "VALUE",
      metric1.get_value(&glean, "baseline").unwrap(),
      "Should set when enabled"
  );
  assert_eq!(
      None,
      metric2.get_value(&glean, "baseline"),
      "Should not set when disabled"
  );
  glean.set_metrics_enabled_config(
      MetricsEnabledConfig::try_from(metrics_enabled_config2).unwrap(),
  );
  assert_eq!(
      None,
      metric1.get_value(&glean, "baseline"),
      "Should not be set when config is overwritten"
  );
  metric2.set_sync(&glean, "VALUE");
  assert_eq!(
      "VALUE",
      metric2.get_value(&glean, "baseline").unwrap(),
      "Should set when enabled"
  );
}
</Rust>