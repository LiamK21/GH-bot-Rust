#[test]
fn test_merge_metrics_enabled_config() {
    let (glean, _t) = new_glean(None);
    let metric = StringMetric::new(CommonMetricData {
        category: "category".to_string(),
        name: "string_metric".to_string(),
        send_in_pings: vec!["baseline".to_string()],
        ..Default::default()
    });
    let another_metric = LabeledMetric::new(CommonMetricData {
        category: "category".to_string(),
        name: "labeled_string_metric".to_string(),
        send_in_pings: vec!["baseline".to_string()],
        ..Default::default()
    });

    let metrics_enabled_config = json!({
        "category.string_metric": true,
    })
    .to_string();
    glean.set_metrics_enabled_config(
        MetricsEnabledConfig::try_from(metrics_enabled_config).unwrap(),
    );

    metric.set_sync(&glean, "INITIAL VALUE");
    assert_eq!(
        "INITIAL VALUE",
        metric.get_value(&glean, "baseline").unwrap(),
        "First metric should be enabled"
    );

    another_metric.get("label1").set_sync(&glean, "SHOULD NOT SET");
    assert_eq!(
        None,
        another_metric.get("label1").get_value(&glean, "baseline"),
        "Second metric should not be enabled"
    );

    let metrics_enabled_config = json!({
        "category.labeled_string_metric": true,
    })
    .to_string();
    glean.set_metrics_enabled_config(
        MetricsEnabledConfig::try_from(metrics_enabled_config).unwrap(),
    );

    metric.set_sync(&glean, "FINAL VALUE");
    assert_eq!(
        "FINAL VALUE",
        metric.get_value(&glean, "baseline").unwrap(),
        "First metric should still be enabled"
    );
    another_metric.get("label1").set_sync(&glean, "FINAL VALUE");
    assert_eq!(
        "FINAL VALUE",
        another_metric.get("label1").get_value(&glean, "baseline").unwrap(),
        "Second metric should now be enabled"
    );
}