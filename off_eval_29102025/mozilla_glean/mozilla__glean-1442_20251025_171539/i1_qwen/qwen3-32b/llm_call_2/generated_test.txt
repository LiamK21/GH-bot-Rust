#[test]
#[cfg(unix)]
fn test_glean_flush_rlb_dispatcher_calls_symbol() {
    // Define a mock RLB dispatcher function at the top level, visible to dlsym
    #[no_mangle]
    pub extern "C" fn rlb_flush_dispatcher() {
        static mut MOCK_FLAG: AtomicUsize = AtomicUsize::new(0);
        unsafe { MOCK_FLAG.store(1, Ordering::SeqCst); }
    }

    // Reset the mock flag
    unsafe {
        // Reuse the mock function's static to avoid duplication
        // SAFETY: Only accessed in this test
        if let Some(flag) = std::ptr::addr_of_mut!(rlb_flush_dispatcher::MOCK_FLAG) {
            flag.write(0);
        }
    }

    // Call the function under test
    unsafe { glean_flush_rlb_dispatcher() };

    // Verify that the mock rlb_flush_dispatcher was called
    let called = unsafe {
        // SAFETY: Only accessed in this test
        let flag = &rlb_flush_dispatcher::MOCK_FLAG as *const AtomicUsize;
        (*flag).load(Ordering::SeqCst)
    };
    assert_eq!(called, 1);
}