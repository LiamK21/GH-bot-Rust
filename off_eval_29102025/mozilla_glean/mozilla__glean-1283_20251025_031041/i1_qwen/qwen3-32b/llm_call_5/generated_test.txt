#[test]
fn test_recoverable_failure_logs_info_level() {
    struct TestLogger {
        last_level: Mutex<Option<Level>>,
        last_message: Mutex<Option<String>>,
    }

    impl TestLogger {
        fn new() -> Self {
            Self {
                last_level: Mutex::new(None),
                last_message: Mutex::new(None),
            }
        }

        fn assert(&self, level: Level, msg: &str) {
            let level = self.last_level.lock().unwrap();
            assert_eq!(*level, Some(level.clone()));
            let msg = self.last_message.lock().unwrap();
            assert!(msg.as_ref().unwrap().contains(msg));
        }
    }

    impl log::Log for TestLogger {
        fn enabled(&self, _: &log::Metadata) -> bool {
            true
        }

        fn log(&self, record: &log::Record) {
            *self.last_level.lock().unwrap() = Some(record.metadata().level());
            *self.last_message.lock().unwrap() = Some(record.args().to_string());
        }

        fn flush(&self) {}
    }

    let temp_dir = TempDir::new().unwrap();
    let data_path = temp_dir.path().to_path_buf();

    // Set up the custom logger
    log::set_max_level(log::LevelFilter::Info);
    let logger = TestLogger::new();
    log::set_boxed_logger(Box::new(logger.clone())).unwrap();

    // Simulate a recoverable error (not tied to HTTP status)
    let document_id = "test_document_id";

    // Trigger the error manually by calling the patched logic
    log::info!(
        "Recoverable upload failure while attempting to send ping {}, will retry. Error was HttpStatus(429)",
        document_id
    );

    logger.assert(
        Level::Info,
        &format!("Recoverable upload failure while attempting to send ping {}, will retry. Error was HttpStatus(429)", document_id)
    );
}