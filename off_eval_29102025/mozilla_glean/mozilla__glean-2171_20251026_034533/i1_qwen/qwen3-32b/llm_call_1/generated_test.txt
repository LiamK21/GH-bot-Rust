#[test]
fn test_concurrent_lock_release_safety() {
    let lock_signal = Arc::new(AtomicBool::new(false));
    let lock_signal_clone = lock_signal.clone();

    let handles: Vec<_> = (0..5)
        .map(|_| {
            let lock_signal = lock_signal_clone.clone();
            thread::spawn(move || {
                let _lock = lock_test();
                // Simulate concurrent access
                for _ in 0..10 {
                    lock_signal.store(true, Ordering::Relaxed);
                    thread::sleep(Duration::from_millis(50));
                    lock_signal.store(false, Ordering::Relaxed);
                }
            })
        })
        .collect();

    for handle in handles {
        handle.join().unwrap();
    }

    // Ensure threads executed without deadlock
    assert!(lock_signal.load(Ordering::Relaxed));
}