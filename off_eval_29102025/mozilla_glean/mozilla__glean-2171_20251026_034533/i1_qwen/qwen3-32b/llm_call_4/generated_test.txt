#[test]
fn test_concurrent_lock_release_safety_with_timeout() {
    let lock_signal = Arc::new(AtomicBool::new(false));
    let lock_signal_clone = lock_signal.clone();

    const NUM_THREADS: usize = 20;
    const ITERATIONS: usize = 100;
    const MAX_ALLOWED_DURATION: Duration = Duration::from_secs(30);

    let handles: Vec<_> = (0..NUM_THREADS)
        .map(|_| {
            let lock_signal = lock_signal_clone.clone();
            thread::spawn(move || {
                for _ in 0..ITERATIONS {
                    let _lock = lock_test();
                    lock_signal.store(true, Ordering::Relaxed);
                    lock_signal.store(false, Ordering::Relaxed);
                }
            })
        })
        .collect();

    let start_time = Instant::now();
    for handle in handles {
        if start_time.elapsed() > MAX_ALLOWED_DURATION {
            panic!("Test took longer than {} seconds", MAX_ALLOWED_DURATION.as_secs());
        }
        handle.join().unwrap();
    }
}