#[test]
fn test_process_ping_upload_response_with_noop_handling() {
    let (mut glean, dir) = new_glean(None);
    let ping_type = PingType::new("test", true, true, vec![]);
    glean.register_ping_type(&ping_type);
    glean.submit_ping(&ping_type, None).unwrap();

    // Create a new upload manager to avoid using Glean's internal one
    let upload_manager = PingUploadManager::new(&dir.path());
    let mut upload_task = upload_manager.get_upload_task();
    while upload_task == PingUploadTask::Wait {
        thread::sleep(Duration::from_millis(10));
        upload_task = upload_manager.get_upload_task();
    }

    let pending_pings_dir = dir.path().join(PENDING_PINGS_DIRECTORY);
    match upload_task {
        PingUploadTask::Upload(request) => {
            let uuid = request.uuid;
            // Pre-patch: status was u16, can't encode HTTP status with flag
            // Post-patch: UploadResult handles HTTP status with flag
            let status = ffi_upload_result::UPLOAD_RESULT_HTTP_STATUS | 404;
            let upload_result = UploadResult::from(status);
            upload_manager.process_ping_upload_response(&uuid, upload_result);
            assert!(!pending_pings_dir.join(uuid).exists());
        }
        _ => panic!("Expected upload task"),
    }

    assert_eq!(upload_manager.get_upload_task(), PingUploadTask::Done);
}