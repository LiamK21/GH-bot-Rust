#[test]
fn test_process_ping_upload_response_with_noop_handling() {
    let (mut glean, dir) = new_glean(None);
    let ping_type = PingType::new("test", true, true, vec![]);
    glean.register_ping_type(&ping_type);
    glean.submit_ping(&ping_type, None).unwrap();

    // Create a new upload manager to avoid using Glean's internal one
    let upload_manager = PingUploadManager::new(&dir.path());
    let mut upload_task = upload_manager.get_upload_task();
    while upload_task == PingUploadTask::Wait {
        thread::sleep(Duration::from_millis(10));
        upload_task = upload_manager.get_upload_task();
    }

    let pending_pings_dir = dir.path().join(PENDING_PINGS_DIRECTORY);
    match upload_task {
        PingUploadTask::Upload(request) => {
            let uuid = request.uuid;
            // Pre-patch: this would cause a compile error due to using UploadResult
            // Post-patch: correctly handles UploadResult with HTTP status flag
            let status = ffi_upload_result::UPLOAD_RESULT_HTTP_STATUS | 404;
            let upload_result = UploadResult::from(status);
            upload_manager.process_ping_upload_response(&uuid, upload_result);
            assert!(!pending_pings_dir.join(uuid).exists());
        }
        _ => panic!("Expected upload task"),
    }

    // Clear queue to avoid lock warnings
    drop(upload_manager.clear_ping_queue());
    drop(glean.upload_manager.clear_ping_queue());
    assert_eq!(upload_manager.get_upload_task(), PingUploadTask::Done);
}