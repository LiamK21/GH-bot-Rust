<Filename>glean-core/src/traits/timing_distribution.rs</Filename>
<imports>
use super::TimingDistribution;
use std::sync::Arc;
use std::sync::Mutex;
use crate::TimerId;
use crate::ErrorType;
use crate::DistributionData;
</imports>
<Rust>
#[test]
fn test_accumulate_samples() {
    struct MockTimingDistribution {
        samples: Arc<Mutex<Vec<i64>>>,
    }

    impl TimingDistribution for MockTimingDistribution {
        fn start(&self) -> TimerId {
            TimerId(0)
        }

        fn stop_and_accumulate(&self, _id: TimerId) {}

        fn cancel(&self, _id: TimerId) {}

        fn accumulate_samples(&self, samples: Vec<i64>) {
            let mut stored_samples = self.samples.lock().unwrap();
            for sample in samples {
                if sample >= 0 {
                    stored_samples.push(sample);
                }
            }
        }

        fn accumulate_raw_samples_nanos(&self, _samples: Vec<u64>) {}

        fn test_get_value<'a, S: Into<Option<&'a str>>>(
            &self,
            _ping_name: S,
        ) -> Option<DistributionData> {
            None
        }

        fn test_get_num_recorded_errors(&self, _error: ErrorType) -> i32 {
            0
        }
    }

    let samples = Arc::new(Mutex::new(Vec::new()));
    let mock = MockTimingDistribution {
        samples: Arc::clone(&samples),
    };

    let input_samples = vec![100, -50, 200, -10, 300];
    mock.accumulate_samples(input_samples);

    let expected_samples = vec![100, 200, 300];
    let actual_samples = samples.lock().unwrap().clone();
    assert_eq!(expected_samples, actual_samples);
}
</Rust>