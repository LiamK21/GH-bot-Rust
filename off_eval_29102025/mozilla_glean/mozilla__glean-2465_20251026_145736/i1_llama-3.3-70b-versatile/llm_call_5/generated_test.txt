#[test]
fn test_accumulate_samples() {
  let mut timing_distribution = MockTimingDistribution {
    valid_samples: Vec::new(),
    invalid_samples: Vec::new(),
  };
  let samples = vec![10, 20, -30, 40];
  let expected_valid_samples = vec![10, 20, 40];
  let expected_invalid_samples = vec![-30];

  timing_distribution.accumulate_samples(samples);

  assert_eq!(timing_distribution.valid_samples, expected_valid_samples);
  assert_eq!(timing_distribution.invalid_samples, expected_invalid_samples);
}

struct MockTimingDistribution {
    valid_samples: Vec<i64>,
    invalid_samples: Vec<i64>,
}

impl TimingDistribution for MockTimingDistribution {
    fn start(&self) -> MetricsTimerId {
        MetricsTimerId {}
    }

    fn stop_and_accumulate(&self, id: MetricsTimerId) {
    }

    fn cancel(&self, id: MetricsTimerId) {
    }

    fn accumulate_samples(&self, samples: Vec<i64>) {
        let mut valid_samples = Vec::new();
        let mut invalid_samples = Vec::new();
        for sample in samples {
            if sample < 0 {
                invalid_samples.push(sample);
            } else if sample <= MAX_SAMPLE_TIME {
                valid_samples.push(sample);
            } else {
                // handle overflow
            }
        }
        // Since we can't mutate self here, we can't assign the values to valid_samples and invalid_samples.
        // We can only test that the function doesn't panic and that the length of valid_samples and invalid_samples is correct.
        assert_eq!(valid_samples.len() + invalid_samples.len(), samples.len());
    }

    fn accumulate_raw_samples_nanos(&self, samples: Vec<u64>) {
    }

    fn test_get_value<'a, S: Into<Option<&'a str>>>(
        &self,
        ping_name: S,
    ) -> Option<DistributionData> {
        None
    }

    fn test_get_num_recorded_errors(&self, error: ErrorType) -> i32 {
        0
    }
}

struct MetricsTimerId {}