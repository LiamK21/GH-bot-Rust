#[test]
fn test_accumulate_samples() {
  let mut timing_distribution = MockTimingDistribution {};
  let samples = vec![10, 20, -30, 40];
  let expected_valid_samples = vec![10, 20, 40];
  let expected_invalid_samples = vec![-30];

  timing_distribution.accumulate_samples(samples);

  assert_eq!(timing_distribution.get_valid_samples(), expected_valid_samples);
  assert_eq!(timing_distribution.get_invalid_samples(), expected_invalid_samples);
}
struct MockTimingDistribution {
    valid_samples: Vec<i64>,
    invalid_samples: Vec<i64>,
}
impl TimingDistribution for MockTimingDistribution {
    fn accumulate_samples(&self, samples: Vec<i64>) {
        for sample in samples {
            if sample < 0 {
                self.invalid_samples.push(sample);
            } else if sample <= MAX_SAMPLE_TIME {
                self.valid_samples.push(sample);
            } else {
                // handle overflow
            }
        }
    }
    fn get_valid_samples(&self) -> Vec<i64> {
        self.valid_samples.clone()
    }
    fn get_invalid_samples(&self) -> Vec<i64> {
        self.invalid_samples.clone()
    }
    fn cancel(&self, id: TimerId) {}
}
impl MockTimingDistribution {
    fn new() -> Self {
        MockTimingDistribution {
            valid_samples: Vec::new(),
            invalid_samples: Vec::new(),
        }
    }
}