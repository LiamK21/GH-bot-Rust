<Filename>glean-core/src/traits/timing_distribution.rs</Filename>
<imports>
use super::TimingDistribution;
use super::TimerId;
use super::ErrorType;
use super::MAX_SAMPLE_TIME;
use std::vec::Vec;
use std::collections::HashMap;
</imports>
<Rust>
#[test]
fn test_accumulate_samples() {
  let mut timing_distribution = MockTimingDistribution {
    valid_samples: Vec::new(),
    invalid_samples: Vec::new(),
  };
  let samples = vec![10, 20, -30, 40];
  let expected_valid_samples = vec![10, 20, 40];
  let expected_invalid_samples = vec![-30];

  timing_distribution.accumulate_samples(samples);

  assert_eq!(timing_distribution.valid_samples, expected_valid_samples);
  assert_eq!(timing_distribution.invalid_samples, expected_invalid_samples);
}

struct MockTimingDistribution {
    valid_samples: Vec<i64>,
    invalid_samples: Vec<i64>,
}

impl TimingDistribution for MockTimingDistribution {
    fn start(&self) -> TimerId {
        TimerId {}
    }

    fn stop_and_accumulate(&self, id: TimerId) {
    }

    fn cancel(&self, id: TimerId) {
    }

    fn accumulate_samples(&mut self, samples: Vec<i64>) {
        for sample in samples {
            if sample < 0 {
                self.invalid_samples.push(sample);
            } else if sample <= MAX_SAMPLE_TIME {
                self.valid_samples.push(sample);
            } else {
                // handle overflow
            }
        }
    }

    fn accumulate_raw_samples_nanos(&self, samples: Vec<u64>) {
    }

    fn test_get_value<'a, S: Into<Option<&'a str>>>(
        &self,
        ping_name: S,
    ) -> Option<DistributionData> {
        None
    }

    fn test_get_num_recorded_errors(&self, error: ErrorType) -> i32 {
        0
    }
}

struct TimerId {}

struct DistributionData {}
</Rust>