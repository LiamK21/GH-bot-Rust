<think>
Okay, let's see. The user says that the existing test passes before the patch, but it should fail. The problem is that when a parent ping is disabled, the child pings following its schedule aren't submitted. The patch is supposed to fix that.

Looking at the provided test in the <TEST> block, the test is called test_scheduled_pings_after_disabled_ping. It creates a parent ping that's disabled and a child that's enabled. Then it submits the parent ping and checks if the child's URL is received.

But why is this test passing before the patch? The original code had the check for ping.enabled before scheduling. So if the parent is disabled, it shouldn't schedule the child. However, the test might not be triggering the schedule correctly.

Wait, in the original code, the parent_ping is disabled. So when submitting it, the submit_sync function would disable it and return false, not scheduling the child. But in the test, the test is checking for the child ping's URL. How is that possible?

Ah, maybe the test is incorrectly submitting the child_ping directly. Let me check the test again.

In the test, after creating parent and child pings, they call Glean::submit_ping_by_name("parent_ping"). If the parent is disabled, the original code would not schedule the child. However, maybe the test isn't actually triggering the schedule. Or perhaps the way the ping_schedule is set up is different.

Wait in the test, the ping_schedule is a HashMap with "parent_ping" mapping to "child_ping". So when the parent ping is submitted, if it's disabled, the original code would not schedule the child. But the test expects the child to be submitted. So in the original code, the child shouldn't be submitted, but the test is passing. That implies that the child is being submitted even when the parent is disabled before the patch. But the issue says that when the parent is disabled, the children should not be scheduled. So the test is passing before the patch because maybe the code is allowing the scheduling regardless of the parent's enabled status.

Looking at the original code in the submit_sync function before the patch: the scheduling logic was inside the block where the ping was enabled. So if the parent was disabled, the scheduling wasn't happening. Therefore, the test would not receive the child ping's URL, and the test would fail. But the user says the test is passing before the patch. So there's a discrepancy here.

Wait, in the test, the parent ping is disabled, but the test submits it. The code before the patch would check if the ping is enabled. Since it's not, it returns false. But the code would also handle the ping schedule as part of that check. Wait, in the patch, they moved the enabled check. Let me look at the original code before the patch.

In the original code (before the patch), the submit_sync function would first check if the ping is enabled. If not, it returns false. Then, after that, if the ping is enabled, it proceeds to collect the ping data. The scheduling was happening only if the ping was successfully submitted.

But in the patch, the scheduling is now done before the enabled check returns, but only if the ping is not enabled. Wait, in the patched code, the scheduling is called in the branch where the ping is disabled. So, the handle_ping_schedule is called even if the ping is disabled.

Ah, so in the original code, the scheduling is only done when the ping is enabled and collected. But the patch changes it so that even if the ping is disabled, it still schedules the children. Therefore, the original test would not trigger the scheduling because the parent is disabled. But in the test, the parent is disabled, and the test expects the child to be submitted. So why does the test pass before the patch?

Hmm. Let me think again. In the original code, the scheduling of child pings (via ride-along) is tied to the submission of the parent ping. If the parent is disabled, the code doesn't queue it, and thus doesn't trigger the scheduling. But in the test, the parent_ping is disabled. So when submitting it, the original code would not schedule the child. But the test is expecting the child's URL. So the test should fail on the original code, but it's passing. That suggests that the scheduling is happening even when the parent is disabled in the original code. Which would be a problem.

But why would that be happening? Maybe because the parent ping is registered with schedules_pings, and even if disabled, the scheduling is done. Wait, in the original code, the scheduling happens after collecting the ping data, which is only done if the ping is enabled. So if the parent is disabled, the scheduling doesn't happen.

But in the test, the test is using ping_schedule in the configuration, which is a map. The ping_schedule is used in the parent_ping's metadata to schedule the child. So when the parent is disabled, the code in the original code should not schedule the child. But perhaps in the test setup, the parent ping is annotated with a schedule, and when the parent is submitted (even if disabled), it schedules the child. So maybe the original code is allowing the schedule regardless of the ping's enabled state.

Wait, in the original code, the code for handling ping schedule is inside the if block where the ping is enabled. Let me look at the patch again. In the original code, the handle_ping_schedule was called after the enabled check. Wait, in the original code (before the patch), the code for scheduling child pings is after the check for ping enabled. So if a parent ping is disabled, the code doesn't run the scheduling.

But in the test, the parent_ping is disabled. So when the test submits the parent_ping, since it's disabled, the code would not schedule the child. Therefore, the test should fail. But the user says that the test currently passes before the patch. So that suggests that the scheduling is being done even when the parent is disabled in the original code.

This implies that there's a mistake in the original code analysis. Perhaps the scheduling is not dependent on the ping being enabled. Let me check the code again.

In the original code, in the submit_sync function, after the ping is enabled, it proceeds to collect the ping data. But in the patched code, the code moved the handle_ping_schedule to be called before the enabled check. Wait, in the original code, the scheduling code was inside the case where the ping was enabled. The patch moves the scheduling to be done even if the ping is disabled.

Wait, the original code had the scheduling code inside the enabled-check block. For example, in the original code, the scheduling is part of the code that is executed after collecting the ping data (which requires the ping to be enabled). So if the parent is disabled, the code doesn't reach that point. The patched code moves the scheduling code to be called even if the ping is disabled. Wait, no. Wait, the patch adds the handle_ping_schedule call in the case where the ping is disabled. So the code in the original code didn't handle the scheduling if the ping was disabled.

But the test is testing the scenario where the parent is disabled. So in the original code, the child should not be scheduled. But the test expects the child to be submitted. Therefore, the test is failing in the original code. But the user says that the test is passing before the patch. So that's a contradiction. Therefore, there must be something wrong with the test setup.

Wait, looking at the test code in the <TEST> block, the parent_ping is disabled. Then, the test submits it. Then, the test waits for the child_ping's URL. In the original code, this should not happen. But perhaps in the original code, the parent_ping's ping_schedule is being processed even when the ping is disabled.

Wait, maybe the parent_ping is not actually disabled. The test code has parent_ping.set_enabled(false), but maybe the PingType is initialized with some default enabled value. Let me check.

The parent_ping is created with the parameters: (name, true, false, false, false, true, vec![], vec![], false, vec![]). The second parameter is 'disabled' (assuming the parameters are correctly mapped). The second parameter is 'disabled' (if the first is name, then the second could be 'disabled', but I need to confirm.

Wait, looking at the code of PingType::new. The parameters for PingType::new in the test are:

fn new(
    name: &str,
    disabled: bool,
    include_client_id: bool,
    send_with_toplevel: bool,
    is_stable: bool,
    included_in_cs: bool,
    scheduled_pings: Vec<&str>,
    // ... maybe other parameters
) -> Self {

But in the test code, the parent_ping is created as:

PingType::new(
    "parent_ping",
    true, // disabled
    false, // include_client_id
    false, // send_with_toplevel
    false, // is_stable
    true, // included_in_cs
    vec![],
    vec![],
    false,
    vec![],
)

So the parent_ping is disabled. The test then calls parent_ping.submit_ping_by_name. The parent_ping is disabled, but in the original code, when a ping is disabled, the scheduling is not done. So the child should not be submitted. But the test is expecting the child's URL, suggesting that in the original code, the child is being submitted.

So why is that happening? Maybe because the parent_ping is not actually disabled in the code. Or perhaps the test is structured incorrectly.

Alternatively, the test may be causing the child_ping to be submitted for reasons unrelated to the parent_ping's scheduling. For example, maybe the child_ping is being submitted because of some other reason, not due to the ping_schedule.

Wait, in the test, after setting up the ping_schedule, the test calls Glean::submit_ping_by_name("parent_ping", None). But the parent_ping is disabled, so in the original code, it would not be submitted. However, the ping_schedule is a configuration that tells the parent_ping to schedule the child_ping. So the original code would not schedule the child_ping if the parent is disabled. But the test expects the child to be submitted. Therefore, the test should fail in the original code. But according to the user, it's passing. So the test must be flawed.

Ah, perhaps the test is not properly triggering the ping_schedule configuration. Let me look at the test code again. The ping_schedule is created as HashMap::from([("parent_ping".to_string(), vec!["child_ping".to_string()])]).

But the PingType for the parent_ping is created with schedules_pings as an empty vec. So the code uses the ping_schedule from the configuration. In the original code, the code checks if ping.schedules_pings is empty. If yes, it uses the ping_schedule HashMap. So in the original code, when the parent_ping is submitted, even if it's disabled, the code would use the ping_schedule to schedule the child_ping. But wait, no. In the original code, the scheduling code is inside the block where the ping is enabled. 

Let me check the original code again. In the submit_sync function before the patch, the scheduling code is after the ping is enabled. Let me look at the original code's relevant part.

Before the patch, the code in submit_sync has:

match ping_maker.collect(...) {
    Some(ping) => {
        // ... some code
        // Then the scheduling
        if ping.schedules_pings.is_empty() {
            let ping_schedule = glean.ping_schedule.get(ping.name).map(|v| &v[..]).unwrap_or(&[]);
            if !ping_schedule.is_empty() {
                for scheduled_ping_name in ping_schedule {
                    glean.submit_ping_by_name(...)
                }
            }
        }
        else { ... }
    }
}

So the code for scheduling via ping_schedule is only done if the ping is enabled (since collect is done after enabled check) and then the scheduling is done based on the ping_schedule.

So in the original code, when the parent_ping is disabled (parent_ping.enabled is false), the code will not process the ping_schedule. Therefore, the test should not see the child_ping's URL. But according to the user, the test is passing before the patch. So that implies that the scheduling is happening even when the parent_ping is disabled. Therefore, the original code's logic is flawed, and the patch is correct. But the test is not triggering the problem because in the original code, the scheduling may still happen even when the parent is disabled.

Wait, how? Let me re-examine the original code. The code in the submit_sync function before the patch:

- Checks if the ping is enabled. If not, returns false.
- Then, proceeds to collect the ping data.
- Then, after collecting, the code checks the ping_schedule and schedules other pings.

So if the parent_ping is disabled, the code returns early and doesn't proceed to schedule the child. Therefore, the test should not see the child_ping. However, the test is passing before the patch. So that implies that the code in the original version is allowing the scheduling even when the parent is disabled.

This suggests that there's a mistake in how the ping_schedule is applied or the test setup is incorrect. For example, maybe the PingType for the parent_ping is not actually disabled. Or perhaps the test is structured to submit the child_ping in a different way.

Looking back at the test code, the parent_ping is created with disabled set to true. The test then calls set_enabled(false). So the parent_ping's enabled state is false. Then, when submitted, it should not schedule the child. But the test passes. That's odd.

Wait, in the test code, there's a call to parent_ping.register(&_glean); and the same for child_ping. Registering the pings. But maybe the PingType's enabled state is not correctly set up. Let me check the PingType::new parameters. Perhaps the second parameter is not the 'enabled' state but another parameter. For example, maybe the second parameter is whether it's disabled by default (but set via set_enabled). Hmm, this depends on the actual implementation of PingType. Let me check the actual code in the patch.

In the patch for the test, the ride_along_ping is created with:

let ride_along_ping = PingType::new(
    "ride-along",
    true,
    true,
    true,
    true,
    true,
    vec![],
    vec![],
    false,
    vec![],
);

The second parameter is passed as true. The PingType::new function's parameters are:

Looking at the code for PingType::new: 

In the original code (before the patch), the PingType struct likely has a field for whether the ping is disabled. The parameters for the constructor would be something like:

fn new(
    name: &str,
    disabled: bool,
    include_client_id: bool,
    is_stable: bool,
    // other parameters...
) -> Self {
    // ...
}

But this depends on the actual implementation. If in the test, the second parameter is the 'disabled' flag, then parent_ping in the test is created with disabled set to true. So the PingType's enabled method would return false. 

Alternatively, perhaps the PingType's set_enabled method overrides the initial 'disabled' parameter. Let me check the code. For example, in the test code:

parent_ping.set_enabled(false);

So maybe the initial 'disabled' parameter is used as a default, but set_enabled overrides the current state. 

In any case, the test's parent_ping is set to be disabled. But when submitted, the original code's logic would not schedule the child_ping. So why is the test passing? It must be that the child_ping is being submitted for another reason.

Wait, maybe the test's parent_ping has metadata that says to ride along with a different ping, and the code is using that. Or perhaps the code is using both ping_schedule and schedules_pings, and the test is set up to use ping_schedule but the PingType's schedules_pings is non-empty. 

Looking at the test code, the parent_ping is created with schedules_pings as an empty vec, so the code will use the ping_schedule from configuration. But in the original code, the scheduling is only done after the ping is enabled and successfully collected. 

Wait, in the original code, the scheduling is only done if the ping is enabled. In the test, the parent_ping is disabled, so the scheduling is not done. Therefore, the test should not receive the child_ping's URL. But the test is passing. Therefore, the test is flawed.

Ah! Maybe the test is using a different mechanism. For example, the child_ping may be a ride-along ping of another ping that's enabled. For example, the first test pings_ride_along_builtin_pings checks if ride-along pings follow the parent's submission. 

In the test code, the parent_ping is registered but not submitted. Wait, no, the test is submitting the parent_ping. But the parent_ping is disabled. If the parent_ping is not collected because disabled, the code shouldn't schedule the child. Therefore, the test should fail. But according to the user, the test is passing. 

This suggests that the original code is allowing the scheduling even when the parent_ping is disabled. So the test is not correctly testing the scenario. 

To fix this, perhaps the test should ensure that when the parent_ping is disabled, the child Ping is not submitted. But the current test is expecting the child_ping to be submitted even when the parent is disabled. Which is what the patch is trying to fix. Wait, the issue is that if the parent_ping is disabled, the child should be submitted. But in the original code, it's not. The patch allows the scheduling even when the parent is disabled. So the test should pass after the patch and fail before.

But the current test passes before the patch. That means the original code is incorrectly allowing the scheduling. So there's likely a mistake in the test setup. 

Wait, perhaps the parent_ping in the test is not correctly disabled. For example, maybe the code has a bug in the enabled check. Or perhaps the parent_ping is enabled, but the test is trying to disable it. 

In the test code, parent_ping.set_enabled(false); is called. But maybe the set_enabled method is not correctly setting the PingType's state. 

Alternatively, maybe the PingType's enabled state is not being used correctly. For example, maybe the ping's submission is not respecting the enabled flag. 

In any case, to make the test fail before the patch and pass after, the test needs to simulate a scenario where the parent is disabled, and the child is scheduled only after the patch. 

So what's wrong with the current test? It seems that in the original code, the scheduling is not done when the parent is disabled. Therefore, the test should expect the child_ping not to be submitted. However, the test is expecting the child to be submitted, which would imply that the current test is incorrect. 

Therefore, the correct approach is to modify the test to expect that the child_ping is NOT submitted before the patch, and IS submitted after the patch. But the current test is passing before, which is incorrect. 

To fix this, the test should be structured to expect the absence of the child_ping's URL before the patch and the presence after. Currently, the test is asserting for the presence of the child_ping. So when the parent is disabled, in the original code, the child shouldn't be submitted. Therefore, the test should expect that no URL is received. But the test is expecting that the URL is received (contains "child_ping"), which suggests that the test is passing when it shouldn't. 

Therefore, the mistake is in the test's assert. The test is asserting the presence of the child_ping's URL in the response, but in the original code, this should not happen. Therefore, the test would pass before the patch only if the child is submitted, which indicates that the original code has a bug. However, the user says the test is passing before the patch, which is a problem. 

So the test needs to be modified to first check that before the patch, the child_ping is not submitted. Then, after the patch, it is submitted. 

To do that, the test should expect that the child is not submitted before the patch, hence the test would check for an absence, leading to a failure, but after the patch, it would pass. 

But the user's current test is designed to expect the child_ping's URL, which in the original code is not happening, but the test is passing. Therefore, there must be a mistake in the test setup. 

Perhaps the test is not correctly using the ping_schedule configuration. For example, maybe the ping_schedule is not properly applied. Or perhaps the test is submitting a different ping. 

Let me re-examine the test code. 

The ping_schedule is set to have "parent_ping" -> ["child_ping"]. The parent_ping is created with schedules_pings as an empty vec, so it uses the ping_schedule. 

When the parent_ping is submitted, it's disabled, but in the original code, since it's disabled, the scheduling is not done. Therefore, the child_ping should not be submitted. But the test is expecting it to be submitted. 

The test waits 100 milliseconds for the URL. If no URL is received, it would panic. Therefore, if the test is passing, that implies that the child_ping was submitted. But in the original code, this should not happen. So there must be a flaw in the test setup. 

Possible solutions: 

1. The parent_ping is not actually disabled. For example, the PingType's enabled state is not being set correctly. 

2. The code in the test is not correctly triggering the ping_schedule via the parent_ping. For example, the test is submitting the child_ping directly. 

3. The ping_schedule configuration is not correctly applied. 

Alternatively, perhaps the parent_ping is not the one being submitted. Wait, in the test, the code submits the parent_ping by name. 

Another possibility: the code in the test is using the ping_schedule configuration, but when the parent_ping is submitted, even if it's disabled, the ping_schedule is triggered. 

Wait, no. In the original code, the ping_schedule is accessed in the submit_sync function, but only when the ping is enabled. 

Wait in the original code's submit_sync function, the code that handles ping_schedule is inside the block where the ping is enabled. So if the parent_ping is disabled, the scheduling is not done. 

Therefore, in the original code, the test should not receive the child_ping's URL. But the user says the test passes, implying that it does receive it. 

This suggests that there's a bug in the original code that allows scheduling even when the ping is disabled. But according to the patch description, that's the bug. 

Wait, the issue says that "Pings following another ping's schedule don't get submitted if said ping is disabled". So the original code's problem is that it's not submitting the child_ping when the parent is disabled. The patch is supposed to fix this by allowing the scheduling even when the parent is disabled. 

So the test is supposed to fail before the patch and pass after. But it's currently passing before. Therefore, there's a mistake in the test setup. 

Ah! Oh wait, maybe the test is actually triggering the child_ping's submission for a different reason. For example, maybe the child_ping is being submitted because it's a ride-along ping of another enabled ping. 

In the test code, the child_ping is created with parameters: true, true, true, true. The fourth parameter is likely send_with_toplevel, so the child_ping may be a toplevel ping. Or include_client_id. So the child_ping may be submitted independently. 

In the test code, after registering and submitting the parent_ping, perhaps the child_ping is submitted for some other reason. For example, the test code may have other pings that are enabled and submit the child_ping. 

Another possibility is that the child_ping is being submitted as a scheduled ping of another enabled ping. 

But the test code sets up the ping_schedule to have the parent_ping schedule the child_ping. But the parent_ping is disabled. So why is the child_ping being submitted?

The test expects the child_ping to be submitted, which suggests that in the original code, the ping_schedule is being processed even when the parent is disabled. That would imply that the original code's logic is incorrect. 

In the original code's submit_sync function, the scheduling is handled in the code after the ping is collected (which requires it to be enabled). Therefore, if the parent_ping is disabled, the scheduling is not done. 

But if the test is passing before the patch, then the scheduling must be occurring. 

This suggests that the original code has a different behavior. Let me recheck the original code's submit_sync function. 

Original code for submit_sync:

In the original code, the scheduling code is after the ping is collected. So:

- Checks if the ping is enabled.
- If not, returns false.
- Else, collects the ping data.
- Then, after collecting, processes the schedules_pings or ping_schedule to schedule other pings.

Therefore, in the original code, the scheduling is only done when the ping is enabled and successfully collected. 

Therefore, in the test case, since the parent_ping is disabled, the scheduling is not done, and the child_ping is not submitted. Therefore, the test should fail. But according to the user, it's passing. So there must be an issue in how the test is written. 

Perhaps the test is using the parent_ping that is not disabled. Let me recheck the test code:

parent_ping.set_enabled(false);

Yes, but perhaps the initial setup in the PingType::new parameters is different. For example, the second parameter could be 'disabled' and then set again to false. Wait, in the parent_ping's creation:

parent_ping.set_enabled(false); 

But maybe the PingType::new has the second parameter as 'disabled', which is set to true. So the PingType is created with disabled set to true, but then set again to false. That might not be correct. 

Looking at the PingType::new parameters, possibly the second parameter is 'disabled' so that when set to true, the ping is disabled. So parent_ping is created with disabled set to true. Then, set_enabled(false) is called. That would set the ping's state to not enabled, which is correct. 

But maybe the set_enabled function is incorrectly named, leading to the ping being enabled when we want it to be disabled. 

Alternatively, perhaps the PingType's enabled is not being correctly set. 

To fix this, the test should be structured so that the child_ping is not submitted before the patch and is submitted after. 

The correct approach for the test is to submit the parent_ping, which is disabled, and verify that the child_ping is not submitted before the patch. Then, with the patch, it is submitted. 

But the current test is expecting the child_ping to be submitted, which is incorrect in the original code. Therefore, the test should be modified to check for the absence of the child_ping in the original code. 

But how to do that? The current test uses a crossbeam_channel and waits for a message. If the test fails to wait for the message (i.e., no message received), it would panic on timeout. To check for absence, the test needs to receive a timeout or no message. 

So the test should be modified to expect that no message is received in the original code, and a message is received after the patch. 

But testing for timeout can be flaky. Alternatively, use the number of messages received. For example, in the original code, the channel should have zero messages, and in the modified code, one message. 

The current test uses r.recv_timeout(Duration::from_millis(100)), which would panic if no message is received. Therefore, to make the test fail before the patch, the test should expect that the channel is empty. 

But in Rust, to check for timeout without panicking, perhaps wrap it in a match. 

So the test should be refactored to:

- Before the patch: expect that r.recv_timeout() returns Err, indicating no message (child not submitted).
- After the patch: returns Ok with child_ping's URL.

The current test is using assert!(url.contains("child_ping")); which would pass if a URL is received, but if no URL is received, the test panics and fails. 

But if the test is passing before the patch, it means that the URL is received, which indicates that the original code is allowing the scheduling even when the parent is disabled. 

To fix this, the test should be modified to expect the URL to be received only after the patch. 

Thus, the current test is incorrect. To make it fail before the patch and pass after, the test needs to be structured so that in the original code, the child_ping is not submitted (i.e., the test expects that no URL is received), and after the patch, it is submitted. 

Therefore, the test should be modified to check that the child_ping is submitted only after the patch. 

The way to do this is to check that after submitting the parent_ping (which is disabled), the child_ping is not submitted in the original code, and is submitted after the patch. 

So the current test's assertion is incorrect. It should be expecting that no message is received before the patch. 

Therefore, the corrected test would look like this:

- Set up the scenario with a parent_ping disabled.
- Expect no submission of child_ping before the patch.
- After applying the patch, expect submission.

To implement this, the test should:

1. Submit the parent_ping.
2. Check if a message is received in the channel.
3. In the original code, expect no message.
4. After the patch, expect the message.

Thus, the test code should be adjusted to check for the absence of a message in the original code and presence after.

The current test is asserting for presence, which is incorrect. So the test should be modified to check for absence before. 

To do this, the test can use:

match r.recv_timeout(Duration::from_millis(100)) {
    Ok(url) => {
        panic!("Expected no URL, but received {}", url);
    },
    Err(_) => {}
}

Before the patch, this would pass, because no URL is received. After applying the patch, the test would fail unless the patch is applied. Wait, no. Wait, with the patch, the child_ping should be submitted even when the parent is disabled. Wait, no. The issue states that the child pings should be submitted even if the parent is disabled. Therefore, the test should expect that after the patch, the child_ping is submitted. 

But in the original code, the child_ping is not submitted. Therefore, the test should expect that before the patch, no message is received, and after the patch, a message is received. 

Therefore, the test should be modified to expect that after the patch, the child_ping is submitted when the parent is disabled. 

But how to ensure this in the test. 

The original test in the <TEST> block is expecting to receive the URL, which implies that the test passes if the URL is received. To make it fail before the patch, the test should expect that the URL is not received. 

Thus, the test should be adjusted to check that no URL is received before the patch. 

So, the correct test would be:

#[test]
fn test_scheduled_pings_after_disabled_ping() {
    let _lock = lock_test();

    let (s, r) = crossbeam_channel::bounded::<String>(1);

    struct FakeUploader {
        sender: crossbeam_channel::Sender<String>,
    }

    impl net::PingUploader for FakeUploader {
        fn upload(&self, req: net::CapablePingUploadRequest) -> net::UploadResult {
            let req = req.capable(|_| true).unwrap();
            self.sender.send(req.url).unwrap();
            net::UploadResult::http_status(200)
        }
    }

    let dir = tempfile::tempdir().unwrap();
    let tmpname = dir.path().to_path_buf();

    let ping_schedule = HashMap::from([("parent_ping".to_string(), vec!["child_ping".to_string()])]);

    let cfg = ConfigurationBuilder::new(false, tmpname, GLOBAL_APPLICATION_ID)
        .with_server_endpoint("invalid-test-host")
        .with_uploader(FakeUploader { sender: s })
        .with_ping_schedule(ping_schedule)
        .build();

    let _glean = new_glean(Some(cfg), true);

    let parent_ping = PingType::new(
        "parent_ping",
        true, // is disabled
        false,
        false,
        false,
        true,
        vec![],
        vec![],
        false,
        vec![],
    );
    parent_ping.set_enabled(false);

    let child_ping = PingType::new(
        "child_ping",
        true,
        true,
        true,
        true,
        true,
        vec![],
        vec![],
        false,
        vec![],
    );
    child_ping.set_enabled(true);

    parent_ping.register(&_glean);
    child_ping.register(&_glean);

    parent_ping.submit(&_glean, None);

    // Before patch, expect no message
    match r.recv_timeout(Duration::from_millis(100)) {
        Ok(url) => {
            panic!("Unexpected URL: {}", url);
        }
        Err(e) => {
            assert!(e.is_timeout(), "Expected no upload");
        }
    }

    // After patch, expect message
}

But since this test is supposed to fail before the patch, but the test is currently passing, the original test must have a different structure. Therefore, the test needs to be adjusted to check for the absence of the message in the original code. 

Thus, the fix is to modify the test to expect that before the patch, no message is received. This can be done by replacing the assertion with a check that the channel is empty. 

The final test should use expect an error (no message) before the patch, and a message after. 

Therefore, updating the <TEST> block's <Rust> section to reflect this.
</think>

<Filename>glean-core/rlb/src/test.rs</Filename>
<imports>
use crossbeam_channel;
use std::time::Duration;
use std::collections::HashMap;
use std::path::PathBuf;
use tempfile;
use glean_core::types::ConfigurationBuilder;
use glean_core::types::{PingType, Glean};
use glean_core::net;
use glean_core::constants::GLOBAL_APPLICATION_ID;
use super::new_glean;
</imports>
<Rust>
#[test]
fn test_scheduled_pings_after_disabled_ping() {
    let _lock = lock_test();

    let (s, r) = crossbeam_channel::bounded::<String>(1);

    #[derive(Debug)]
    struct FakeUploader {
        sender: crossbeam_channel::Sender<String>,
    }

    impl net::PingUploader for FakeUploader {
        fn upload(&self, request: net::CapablePingUploadRequest) -> net::UploadResult {
            let request = request.capable(|_| true).unwrap();
            self.sender.send(request.url).unwrap();
            net::UploadResult::http_status(200)
        }
    }

    let dir = tempfile::tempdir().unwrap();
    let tmpname = dir.path().to_path_buf();

    let ping_schedule = HashMap::from([("parent".to_string(), vec!["child".to_string()])]);

    let cfg = ConfigurationBuilder::new(false, tmpname, GLOBAL_APPLICATION_ID)
        .with_server_endpoint("invalid-test-host")
        .with_uploader(FakeUploader { sender: s })
        .with_ping_schedule(ping_schedule)
        .build();

    let _glean = new_glean(Some(cfg), true);

    let parent_ping = PingType::new(
        "parent",
        false, // explicitly disabled
        true,
        false,
        true,
        false,
        vec![],
        vec![],
        false,
        vec![],
    );
    parent_ping.set_enabled(false);

    let child_ping = PingType::new(
        "child",
        true,
        true,
        true,
        true,
        true,
        vec![],
        vec![],
        false,
        vec![],
    );
    child_ping.set_enabled(true);

    parent_ping.register(&_glean);
    child_ping.register(&_glean);

    // Submit disabled parent ping
    parent_ping.submit(&_glean, None);

    // Before patch: expect no message
    // After patch: expect message with child
    match r.recv_timeout(Duration::from_millis(100)) {
        Ok(url) => assert!(url.contains("child")),
        Err(e) => panic!("Expected channel to receive child ping URL, got: {:?}", e),
    }
}
</Rust>