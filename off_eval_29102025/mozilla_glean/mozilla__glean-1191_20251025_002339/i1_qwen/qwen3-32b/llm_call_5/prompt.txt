Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Uploader test suite intermittently fails on CI
I saw intermittents when working on: [#1158](https://github.com/mozilla/glean/pull/1158), which I thought [`eca9003f`](https://github.com/mozilla/glean/pull/1158/commits/eca9003f2bf85f5e7097b14335e896a07bdb7f25) had fixed, but turns out the intermittents are still showing up.

See:
* https://app.circleci.com/pipelines/github/mozilla/glean/5753/workflows/ebaa9452-b6b9-4ba2-aadf-b947332ec794/jobs/91830
* https://app.circleci.com/pipelines/github/mozilla/glean/5751/workflows/a7884b5e-c991-4aa2-b3bc-8a2a91445dea/jobs/91728 

Haven't been able to reproduce these locally yet.
</issue>

Patch:
<patch>
diff --git a/glean-core/src/lib.rs b/glean-core/src/lib.rs
--- a/glean-core/src/lib.rs
+++ b/glean-core/src/lib.rs
@@ -272,7 +272,7 @@ impl Glean {
         data_path: &str,
         application_id: &str,
         upload_enabled: bool,
-    ) -> Result<Self> {
+    ) -> Self {
         let cfg = Configuration {
             data_path: data_path.into(),
             application_id: application_id.into(),
@@ -282,7 +282,13 @@ impl Glean {
             delay_ping_lifetime_io: false,
         };
 
-        Self::new(cfg)
+        let mut glean = Self::new(cfg).unwrap();
+
+        // Disable all upload manager policies for testing
+        // and make the upload manager scan the pings directories synchronously.
+        glean.upload_manager = PingUploadManager::no_policy(data_path, true);
+
+        glean
     }
 
     /// Destroys the database.

diff --git a/glean-core/src/lib_unit_tests.rs b/glean-core/src/lib_unit_tests.rs
--- a/glean-core/src/lib_unit_tests.rs
+++ b/glean-core/src/lib_unit_tests.rs
@@ -19,7 +19,7 @@ pub fn new_glean(tempdir: Option<tempfile::TempDir>) -> (Glean, tempfile::TempDi
         None => tempfile::tempdir().unwrap(),
     };
     let tmpname = dir.path().display().to_string();
-    let glean = Glean::with_options(&tmpname, GLOBAL_APPLICATION_ID, true).unwrap();
+    let glean = Glean::with_options(&tmpname, GLOBAL_APPLICATION_ID, true);
     (glean, dir)
 }
 
@@ -39,7 +39,7 @@ fn path_is_constructed_from_data() {
 fn experiment_id_and_branch_get_truncated_if_too_long() {
     let t = tempfile::tempdir().unwrap();
     let name = t.path().display().to_string();
-    let glean = Glean::with_options(&name, "org.mozilla.glean.tests", true).unwrap();
+    let glean = Glean::with_options(&name, "org.mozilla.glean.tests", true);
 
     // Generate long strings for the used ids.
     let very_long_id = "test-experiment-id".repeat(10);
@@ -75,7 +75,7 @@ fn experiment_id_and_branch_get_truncated_if_too_long() {
 fn limits_on_experiments_extras_are_applied_correctly() {
     let t = tempfile::tempdir().unwrap();
     let name = t.path().display().to_string();
-    let glean = Glean::with_options(&name, "org.mozilla.glean.tests", true).unwrap();
+    let glean = Glean::with_options(&name, "org.mozilla.glean.tests", true);
 
     let experiment_id = "test-experiment_id".to_string();
     let branch_id = "test-branch-id".to_string();
@@ -130,7 +130,7 @@ fn limits_on_experiments_extras_are_applied_correctly() {
 fn experiments_status_is_correctly_toggled() {
     let t = tempfile::tempdir().unwrap();
     let name = t.path().display().to_string();
-    let glean = Glean::with_options(&name, "org.mozilla.glean.tests", true).unwrap();
+    let glean = Glean::with_options(&name, "org.mozilla.glean.tests", true);
 
     // Define the experiment's data.
     let experiment_id: String = "test-toggle-experiment".into();
@@ -173,7 +173,7 @@ fn client_id_and_first_run_date_must_be_regenerated() {
     let dir = tempfile::tempdir().unwrap();
     let tmpname = dir.path().display().to_string();
     {
-        let glean = Glean::with_options(&tmpname, GLOBAL_APPLICATION_ID, true).unwrap();
+        let glean = Glean::with_options(&tmpname, GLOBAL_APPLICATION_ID, true);
 
         glean.data_store.as_ref().unwrap().clear_all();
 
@@ -190,7 +190,7 @@ fn client_id_and_first_run_date_must_be_regenerated() {
     }
 
     {
-        let glean = Glean::with_options(&tmpname, GLOBAL_APPLICATION_ID, true).unwrap();
+        let glean = Glean::with_options(&tmpname, GLOBAL_APPLICATION_ID, true);
         assert!(glean
             .core_metrics
             .client_id
@@ -292,7 +292,7 @@ fn client_id_is_managed_correctly_when_toggling_uploading() {
 fn client_id_is_set_to_known_value_when_uploading_disabled_at_start() {
     let dir = tempfile::tempdir().unwrap();
     let tmpname = dir.path().display().to_string();
-    let glean = Glean::with_options(&tmpname, GLOBAL_APPLICATION_ID, false).unwrap();
+    let glean = Glean::with_options(&tmpname, GLOBAL_APPLICATION_ID, false);
 
     assert_eq!(
         *KNOWN_CLIENT_ID,
@@ -308,7 +308,7 @@ fn client_id_is_set_to_known_value_when_uploading_disabled_at_start() {
 fn client_id_is_set_to_random_value_when_uploading_enabled_at_start() {
     let dir = tempfile::tempdir().unwrap();
     let tmpname = dir.path().display().to_string();
-    let glean = Glean::with_options(&tmpname, GLOBAL_APPLICATION_ID, true).unwrap();
+    let glean = Glean::with_options(&tmpname, GLOBAL_APPLICATION_ID, true);
 
     let current_client_id = glean
         .core_metrics
@@ -322,7 +322,7 @@ fn client_id_is_set_to_random_value_when_uploading_enabled_at_start() {
 fn enabling_when_already_enabled_is_a_noop() {
     let dir = tempfile::tempdir().unwrap();
     let tmpname = dir.path().display().to_string();
-    let mut glean = Glean::with_options(&tmpname, GLOBAL_APPLICATION_ID, true).unwrap();
+    let mut glean = Glean::with_options(&tmpname, GLOBAL_APPLICATION_ID, true);
 
     assert!(!glean.set_upload_enabled(true));
 }
@@ -331,7 +331,7 @@ fn enabling_when_already_enabled_is_a_noop() {
 fn disabling_when_already_disabled_is_a_noop() {
     let dir = tempfile::tempdir().unwrap();
     let tmpname = dir.path().display().to_string();
-    let mut glean = Glean::with_options(&tmpname, GLOBAL_APPLICATION_ID, false).unwrap();
+    let mut glean = Glean::with_options(&tmpname, GLOBAL_APPLICATION_ID, false);
 
     assert!(!glean.set_upload_enabled(false));
 }
@@ -546,14 +546,14 @@ fn test_first_run() {
     let dir = tempfile::tempdir().unwrap();
     let tmpname = dir.path().display().to_string();
     {
-        let glean = Glean::with_options(&tmpname, GLOBAL_APPLICATION_ID, true).unwrap();
+        let glean = Glean::with_options(&tmpname, GLOBAL_APPLICATION_ID, true);
         // Check that this is indeed the first run.
         assert!(glean.is_first_run());
     }
 
     {
         // Other runs must be not marked as "first run".
-        let glean = Glean::with_options(&tmpname, GLOBAL_APPLICATION_ID, true).unwrap();
+        let glean = Glean::with_options(&tmpname, GLOBAL_APPLICATION_ID, true);
         assert!(!glean.is_first_run());
     }
 }
@@ -563,7 +563,7 @@ fn test_dirty_bit() {
     let dir = tempfile::tempdir().unwrap();
     let tmpname = dir.path().display().to_string();
     {
-        let glean = Glean::with_options(&tmpname, GLOBAL_APPLICATION_ID, true).unwrap();
+        let glean = Glean::with_options(&tmpname, GLOBAL_APPLICATION_ID, true);
         // The dirty flag must not be set the first time Glean runs.
         assert!(!glean.is_dirty_flag_set());
 
@@ -575,7 +575,7 @@ fn test_dirty_bit() {
     {
         // Check that next time Glean runs, it correctly picks up the "dirty flag".
         // It is expected to be 'true'.
-        let glean = Glean::with_options(&tmpname, GLOBAL_APPLICATION_ID, true).unwrap();
+        let glean = Glean::with_options(&tmpname, GLOBAL_APPLICATION_ID, true);
         assert!(glean.is_dirty_flag_set());
 
         // Set the dirty flag to false.
@@ -586,7 +586,7 @@ fn test_dirty_bit() {
     {
         // Check that next time Glean runs, it correctly picks up the "dirty flag".
         // It is expected to be 'false'.
-        let glean = Glean::with_options(&tmpname, GLOBAL_APPLICATION_ID, true).unwrap();
+        let glean = Glean::with_options(&tmpname, GLOBAL_APPLICATION_ID, true);
         assert!(!glean.is_dirty_flag_set());
     }
 }
@@ -801,7 +801,7 @@ fn test_empty_application_id() {
     let dir = tempfile::tempdir().unwrap();
     let tmpname = dir.path().display().to_string();
 
-    let glean = Glean::with_options(&tmpname, "", true).unwrap();
+    let glean = Glean::with_options(&tmpname, "", true);
     // Check that this is indeed the first run.
     assert!(glean.is_first_run());
 }
@@ -816,14 +816,14 @@ fn records_database_file_size() {
     let tmpname = dir.path().display().to_string();
 
     // Initialize Glean once to ensure we create the database.
-    let glean = Glean::with_options(&tmpname, GLOBAL_APPLICATION_ID, true).unwrap();
+    let glean = Glean::with_options(&tmpname, GLOBAL_APPLICATION_ID, true);
     let database_size = &glean.database_metrics.size;
     let data = database_size.test_get_value(&glean, "metrics");
     assert!(data.is_none());
     drop(glean);
 
     // Initialize Glean again to record file size.
-    let glean = Glean::with_options(&tmpname, GLOBAL_APPLICATION_ID, true).unwrap();
+    let glean = Glean::with_options(&tmpname, GLOBAL_APPLICATION_ID, true);
 
     let database_size = &glean.database_metrics.size;
     let data = database_size.test_get_value(&glean, "metrics");

diff --git a/glean-core/src/storage/mod.rs b/glean-core/src/storage/mod.rs
--- a/glean-core/src/storage/mod.rs
+++ b/glean-core/src/storage/mod.rs
@@ -207,7 +207,7 @@ mod test {
     fn test_experiments_json_serialization() {
         let t = tempfile::tempdir().unwrap();
         let name = t.path().display().to_string();
-        let glean = Glean::with_options(&name, "org.mozilla.glean", true).unwrap();
+        let glean = Glean::with_options(&name, "org.mozilla.glean", true);
 
         let extra: HashMap<String, String> = [("test-key".into(), "test-value".into())]
             .iter()
@@ -236,7 +236,7 @@ mod test {
     fn test_experiments_json_serialization_empty() {
         let t = tempfile::tempdir().unwrap();
         let name = t.path().display().to_string();
-        let glean = Glean::with_options(&name, "org.mozilla.glean", true).unwrap();
+        let glean = Glean::with_options(&name, "org.mozilla.glean", true);
 
         let metric = ExperimentMetric::new(&glean, "some-experiment".to_string());

diff --git a/glean-core/src/upload/mod.rs b/glean-core/src/upload/mod.rs
--- a/glean-core/src/upload/mod.rs
+++ b/glean-core/src/upload/mod.rs
@@ -19,27 +19,15 @@ use std::time::{Duration, Instant};
 use crate::error::ErrorKind;
 use crate::{internal_metrics::UploadMetrics, Glean};
 use directory::{PingDirectoryManager, PingPayloadsByDirectory};
+use policy::Policy;
 pub use request::{HeaderMap, PingRequest};
 pub use result::{ffi_upload_result, UploadResult};
 
 mod directory;
+mod policy;
 mod request;
 mod result;
 
-/// The maximum recoverable failures allowed per uploading window.
-///
-/// Limiting this is necessary to avoid infinite loops on requesting upload tasks.
-const MAX_RECOVERABLE_FAILURES_PER_UPLOADING_WINDOW: u32 = 3;
-
-/// The maximum PingUploadTask::Wait allowed in a row.
-const MAX_WAIT_ATTEMPTS: u32 = 300;
-
-// The maximum size in bytes a ping body may have to be eligible for upload.
-const PING_BODY_MAX_SIZE: usize = 1024 * 1024; // 1 MB
-
-// The maximum size in byte the pending pings directory may have on disk.
-const PENDING_PINGS_DIRECTORY_QUOTA: u64 = 10 * 1024 * 1024; // 10 MB
-
 #[derive(Debug)]
 struct RateLimiter {
     /// The instant the current interval has started.
@@ -168,6 +156,8 @@ pub struct PingUploadManager {
     language_binding_name: String,
     /// Metrics related to ping uploading.
     upload_metrics: UploadMetrics,
+    /// Policies for ping storage, uploading and requests.
+    policy: Policy,
 }
 
 impl PingUploadManager {
@@ -179,6 +169,7 @@ impl PingUploadManager {
     /// # Arguments
     ///
     /// * `data_path` - Path to the pending pings directory.
+    /// * `language_binding_name` - The name of the language binding calling this managers instance.
     /// * `sync_scan` - Whether or not ping directory scanning should be synchronous.
     ///
     /// # Panics
@@ -225,9 +216,26 @@ impl PingUploadManager {
             rate_limiter: None,
             language_binding_name: language_binding_name.into(),
             upload_metrics: UploadMetrics::new(),
+            policy: Policy::default(),
         }
     }
 
+    /// Creates a new upload manager with no limitations, for tests.
+    #[cfg(test)]
+    pub fn no_policy<P: Into<PathBuf>>(data_path: P, sync_scan: bool) -> Self {
+        let mut upload_manager = Self::new(data_path, "Test", sync_scan);
+
+        // Disable all policies for tests, if necessary individuals tests can re-enable them.
+        upload_manager.policy.set_max_recoverable_failures(None);
+        upload_manager.policy.set_max_wait_attempts(None);
+        upload_manager.policy.set_max_ping_body_size(None);
+        upload_manager
+            .policy
+            .set_max_pending_pings_directory_size(None);
+
+        upload_manager
+    }
+
     fn processed_pending_pings(&self) -> bool {
         self.processed_pending_pings.load(Ordering::SeqCst)
     }
@@ -252,10 +260,13 @@ impl PingUploadManager {
         body: &str,
         headers: Option<HeaderMap>,
     ) -> Option<PingRequest> {
-        let mut request = PingRequest::builder(&self.language_binding_name, PING_BODY_MAX_SIZE)
-            .document_id(document_id)
-            .path(path)
-            .body(body);
+        let mut request = PingRequest::builder(
+            &self.language_binding_name,
+            self.policy.max_ping_body_size(),
+        )
+        .document_id(document_id)
+        .path(path)
+        .body(body);
 
         if let Some(headers) = headers {
             request = request.headers(headers);
@@ -328,8 +339,7 @@ impl PingUploadManager {
     /// # Arguments
     ///
     /// * `glean` - The Glean object holding the database.
-    /// * `quota` - The quota, in bytes, for the size of the pending pings directory.
-    fn enqueue_cached_pings(&self, glean: &Glean, quota: u64) {
+    fn enqueue_cached_pings(&self, glean: &Glean) {
         let mut cached_pings = self
             .cached_pings
             .write()
@@ -346,10 +356,10 @@ impl PingUploadManager {
             cached_pings.pending_pings.reverse();
             cached_pings.pending_pings.retain(|(file_size, (document_id, _, _, _))| {
                 pending_pings_directory_size += file_size;
-                if pending_pings_directory_size > quota {
+                if pending_pings_directory_size > self.policy.max_pending_pings_directory_size() {
                     log::warn!(
                         "Pending pings directory has reached the size quota of {} bytes, outstanding pings will be deleted.",
-                        PENDING_PINGS_DIRECTORY_QUOTA
+                        self.policy.max_pending_pings_directory_size()
                     );
                     deleting = true;
                 }
@@ -441,7 +451,7 @@ impl PingUploadManager {
         // in case we reach MAX_WAIT_ATTEMPTS we want to actually return PingUploadTask::Done.
         let wait_or_done = || {
             self.wait_attempt_count.fetch_add(1, Ordering::SeqCst);
-            if self.wait_attempt_count() > MAX_WAIT_ATTEMPTS {
+            if self.wait_attempt_count() > self.policy.max_wait_attempts() {
                 PingUploadTask::Done
             } else {
                 PingUploadTask::Wait
@@ -456,9 +466,9 @@ impl PingUploadManager {
         }
 
         // This is a no-op in case there are no cached pings.
-        self.enqueue_cached_pings(glean, PENDING_PINGS_DIRECTORY_QUOTA);
+        self.enqueue_cached_pings(glean);
 
-        if self.recoverable_failure_count() >= MAX_RECOVERABLE_FAILURES_PER_UPLOADING_WINDOW {
+        if self.recoverable_failure_count() >= self.policy.max_recoverable_failures() {
             log::warn!(
                 "Reached maximum recoverable failures for the current uploading window. You are done."
             );
@@ -696,10 +706,6 @@ mod test {
     fn doesnt_error_when_there_are_no_pending_pings() {
         let (glean, _) = new_glean(None);
 
-        while glean.get_upload_task() == PingUploadTask::Wait {
-            thread::sleep(Duration::from_millis(10));
-        }
-
         // Try and get the next request.
         // Verify request was not returned
         assert_eq!(glean.get_upload_task(), PingUploadTask::Done);
@@ -711,7 +717,7 @@ mod test {
 
         // Create a new upload manager so that we have access to its functions directly,
         // make it synchronous so we don't have to manually wait for the scanning to finish.
-        let upload_manager = PingUploadManager::new(dir.path(), "Testing", /* sync */ true);
+        let upload_manager = PingUploadManager::no_policy(dir.path(), /* sync_scan */ true);
 
         // Enqueue a ping
         upload_manager.enqueue_ping(&glean, &Uuid::new_v4().to_string(), PATH, "", None);
@@ -730,7 +736,7 @@ mod test {
 
         // Create a new upload manager so that we have access to its functions directly,
         // make it synchronous so we don't have to manually wait for the scanning to finish.
-        let upload_manager = PingUploadManager::new(dir.path(), "Testing", /* sync */ true);
+        let upload_manager = PingUploadManager::no_policy(dir.path(), /* sync_scan */ true);
 
         // Enqueue a ping multiple times
         let n = 10;
@@ -760,7 +766,7 @@ mod test {
         // Create a new upload manager so that we have access to its functions directly,
         // make it synchronous so we don't have to manually wait for the scanning to finish.
         let mut upload_manager =
-            PingUploadManager::new(dir.path(), "Testing", /* sync */ true);
+            PingUploadManager::no_policy(dir.path(), /* sync_scan */ true);
 
         // Add a rate limiter to the upload mangager with max of 10 pings every 3 seconds.
         let secs_per_interval = 3;
@@ -804,7 +810,7 @@ mod test {
 
         // Create a new upload manager so that we have access to its functions directly,
         // make it synchronous so we don't have to manually wait for the scanning to finish.
-        let upload_manager = PingUploadManager::new(dir.path(), "Testing", /* sync */ true);
+        let upload_manager = PingUploadManager::no_policy(dir.path(), /* sync_scan */ true);
 
         // Enqueue a ping multiple times
         for _ in 0..10 {
@@ -825,11 +831,6 @@ mod test {
     fn clearing_the_queue_doesnt_clear_deletion_request_pings() {
         let (mut glean, _) = new_glean(None);
 
-        // Wait for processing of pending pings directory to finish.
-        while glean.get_upload_task() == PingUploadTask::Wait {
-            thread::sleep(Duration::from_millis(10));
-        }
-
         // Register a ping for testing
         let ping_type = PingType::new("test", true, /* send_if_empty */ true, vec![]);
         glean.register_ping_type(&ping_type);
@@ -874,7 +875,7 @@ mod test {
         }
 
         // Create a new upload manager pointing to the same data_path as the glean instance.
-        let upload_manager = PingUploadManager::new(dir.path(), "Rust", true);
+        let upload_manager = PingUploadManager::no_policy(dir.path(), /* sync_scan */ true);
 
         // Verify the requests were properly enqueued
         for _ in 0..n {
@@ -895,11 +896,6 @@ mod test {
     fn processes_correctly_success_upload_response() {
         let (mut glean, dir) = new_glean(None);
 
-        // Wait for processing of pending pings directory to finish.
-        while glean.get_upload_task() == PingUploadTask::Wait {
-            thread::sleep(Duration::from_millis(10));
-        }
-
         // Register a ping for testing
         let ping_type = PingType::new("test", true, /* send_if_empty */ true, vec![]);
         glean.register_ping_type(&ping_type);
@@ -930,11 +926,6 @@ mod test {
     fn processes_correctly_client_error_upload_response() {
         let (mut glean, dir) = new_glean(None);
 
-        // Wait for processing of pending pings directory to finish.
-        while glean.get_upload_task() == PingUploadTask::Wait {
-            thread::sleep(Duration::from_millis(10));
-        }
-
         // Register a ping for testing
         let ping_type = PingType::new("test", true, /* send_if_empty */ true, vec![]);
         glean.register_ping_type(&ping_type);
@@ -965,11 +956,6 @@ mod test {
     fn processes_correctly_server_error_upload_response() {
         let (mut glean, _) = new_glean(None);
 
-        // Wait for processing of pending pings directory to finish.
-        while glean.get_upload_task() == PingUploadTask::Wait {
-            thread::sleep(Duration::from_millis(10));
-        }
-
         // Register a ping for testing
         let ping_type = PingType::new("test", true, /* send_if_empty */ true, vec![]);
         glean.register_ping_type(&ping_type);
@@ -1002,11 +988,6 @@ mod test {
     fn processes_correctly_unrecoverable_upload_response() {
         let (mut glean, dir) = new_glean(None);
 
-        // Wait for processing of pending pings directory to finish.
-        while glean.get_upload_task() == PingUploadTask::Wait {
-            thread::sleep(Duration::from_millis(10));
-        }
-
         // Register a ping for testing
         let ping_type = PingType::new("test", true, /* send_if_empty */ true, vec![]);
         glean.register_ping_type(&ping_type);
@@ -1039,9 +1020,7 @@ mod test {
 
         // Create a new upload manager so that we have access to its functions directly,
         // make it synchronous so we don't have to manually wait for the scanning to finish.
-        let upload_manager = PingUploadManager::new(dir.path(), "Testing", /* sync */ true);
-
-        // Wait for processing of pending pings directory to finish.
+        let upload_manager = PingUploadManager::no_policy(dir.path(), /* sync_scan */ true);
         while upload_manager.get_upload_task(&glean, false) == PingUploadTask::Wait {
             thread::sleep(Duration::from_millis(10));
         }
@@ -1086,12 +1065,17 @@ mod test {
     }
 
     #[test]
-    fn uploader_sync_init() {
-        let (glean, _) = new_glean(None);
+    fn async_ping_directories_scanning_works() {
+        let (glean, dir) = new_glean(None);
 
-        // Create a new upload_manager, with a synchronous ping dir scan.
-        let dir = tempfile::tempdir().unwrap();
-        let upload_manager = PingUploadManager::new(dir.path(), "Testing", true);
+        // Create a new upload_manager, with a asynchronous ping dir scan,
+        // all other tests do this synchronously.
+        let upload_manager = PingUploadManager::no_policy(dir.path(), /* sync_scan */ false);
+
+        // Wait for processing of pending pings directory to finish.
+        while upload_manager.get_upload_task(&glean, false) == PingUploadTask::Wait {
+            thread::sleep(Duration::from_millis(10));
+        }
 
         // Since the scan was synchronous and the directory was empty,
         // we expect the upload task to always be `Done`.
@@ -1105,11 +1089,6 @@ mod test {
     fn adds_debug_view_header_to_requests_when_tag_is_set() {
         let (mut glean, _) = new_glean(None);
 
-        // Wait for processing of pending pings directory to finish.
-        while glean.get_upload_task() == PingUploadTask::Wait {
-            thread::sleep(Duration::from_millis(10));
-        }
-
         glean.set_debug_view_tag("valid-tag");
 
         // Register a ping for testing
@@ -1134,7 +1113,7 @@ mod test {
 
         // Create a new upload manager so that we have access to its functions directly,
         // make it synchronous so we don't have to manually wait for the scanning to finish.
-        let upload_manager = PingUploadManager::new(dir.path(), "Testing", /* sync */ true);
+        let upload_manager = PingUploadManager::no_policy(dir.path(), /* sync_scan */ true);
 
         let doc_id = Uuid::new_v4().to_string();
         let path = format!("/submit/app_id/test-ping/1/{}", doc_id);
@@ -1158,12 +1137,7 @@ mod test {
 
     #[test]
     fn maximum_of_recoverable_errors_is_enforced_for_uploading_window() {
-        let (mut glean, _) = new_glean(None);
-
-        // Wait for processing of pending pings directory to finish.
-        while glean.get_upload_task() == PingUploadTask::Wait {
-            thread::sleep(Duration::from_millis(10));
-        }
+        let (mut glean, dir) = new_glean(None);
 
         // Register a ping for testing
         let ping_type = PingType::new("test", true, /* send_if_empty */ true, vec![]);
@@ -1175,23 +1149,39 @@ mod test {
             glean.submit_ping(&ping_type, None).unwrap();
         }
 
+        // Create a new upload manager so that we have access to its functions directly,
+        // make it synchronous so we don't have to manually wait for the scanning to finish.
+        let mut upload_manager =
+            PingUploadManager::no_policy(dir.path(), /* sync_scan */ true);
+
+        // Set a policy for max recoverable failures, this is usually disabled for tests.
+        let max_recoverable_failures = 3;
+        upload_manager
+            .policy
+            .set_max_recoverable_failures(Some(max_recoverable_failures));
+
         // Return the max recoverable error failures in a row
-        for _ in 0..MAX_RECOVERABLE_FAILURES_PER_UPLOADING_WINDOW {
-            match glean.get_upload_task() {
-                PingUploadTask::Upload(req) => {
-                    glean.process_ping_upload_response(&req.document_id, RecoverableFailure)
-                }
+        for _ in 0..max_recoverable_failures {
+            match upload_manager.get_upload_task(&glean, false) {
+                PingUploadTask::Upload(req) => upload_manager.process_ping_upload_response(
+                    &glean,
+                    &req.document_id,
+                    RecoverableFailure,
+                ),
                 _ => panic!("Expected upload manager to return the next request!"),
             }
         }
 
         // Verify that after returning the max amount of recoverable failures,
         // we are done even though we haven't gotten all the enqueued requests.
-        assert_eq!(glean.get_upload_task(), PingUploadTask::Done);
+        assert_eq!(
+            upload_manager.get_upload_task(&glean, false),
+            PingUploadTask::Done
+        );
 
         // Verify all requests are returned when we try again.
         for _ in 0..n {
-            match glean.get_upload_task() {
+            match upload_manager.get_upload_task(&glean, false) {
                 PingUploadTask::Upload(_) => {}
                 _ => panic!("Expected upload manager to return the next request!"),
             }
@@ -1220,15 +1210,18 @@ mod test {
         let (newest_ping_id, _, _, _) = &newest_ping;
 
         // Create a new upload manager pointing to the same data_path as the glean instance.
-        let upload_manager = PingUploadManager::new(dir.path(), "Rust", true);
+        let mut upload_manager =
+            PingUploadManager::no_policy(dir.path(), /* sync_scan */ true);
 
-        // Enqueue cached pings and set the quota to just a little over the size on an empty ping file.
+        // Set the quota to just a little over the size on an empty ping file.
         // This way we can check that one ping is kept and all others are deleted.
         //
         // From manual testing I figured out an empty ping file is 324bytes,
         // I am setting this a little over just so that minor changes to the ping structure
         // don't immediatelly break this.
-        upload_manager.enqueue_cached_pings(&glean, 500);
+        upload_manager
+            .policy
+            .set_max_pending_pings_directory_size(Some(500));
 
         // Get a task once
         // One ping should have been enqueued.
@@ -1263,7 +1256,13 @@ mod test {
         // Create a new upload manager so that we have access to its functions directly,
         // make it synchronous so we don't have to manually wait for the scanning to finish.
         let mut upload_manager =
-            PingUploadManager::new(dir.path(), "Testing", /* sync */ true);
+            PingUploadManager::no_policy(dir.path(), /* sync_scan */ true);
+
+        // Define a max_wait_attemps policy, this is disabled for tests by default.
+        let max_wait_attempts = 3;
+        upload_manager
+            .policy
+            .set_max_wait_attempts(Some(max_wait_attempts));
 
         // Add a rate limiter to the upload mangager with max of 1 ping 5secs.
         //
@@ -1287,7 +1286,7 @@ mod test {
         // Try to get the next ping,
         // we should be throttled and thus get a PingUploadTask::Wait.
         // Check that we are indeed allowed to get this response as many times as expected.
-        for _ in 0..MAX_WAIT_ATTEMPTS {
+        for _ in 0..max_wait_attempts {
             assert_eq!(
                 upload_manager.get_upload_task(&glean, false),
                 PingUploadTask::Wait

diff --git a/glean-core/src/upload/policy.rs b/glean-core/src/upload/policy.rs
--- a/glean-core/src/upload/policy.rs
+++ b/glean-core/src/upload/policy.rs
@@ -0,0 +1,89 @@
+// This Source Code Form is subject to the terms of the Mozilla Public
+// License, v. 2.0. If a copy of the MPL was not distributed with this
+// file, You can obtain one at https://mozilla.org/MPL/2.0/.
+
+//! Policies for ping storage, uploading and requests.
+
+const MAX_RECOVERABLE_FAILURES: u32 = 3;
+const MAX_WAIT_ATTEMPTS: u32 = 3;
+const MAX_PING_BODY_SIZE: usize = 1024 * 1024; // 1 MB
+const MAX_PENDING_PINGS_DIRECTORY_SIZE: u64 = 10 * 1024 * 1024; // 10MB
+
+/// A struct holding the values for all the policies related to ping storage, uploading and requests.
+#[derive(Debug)]
+pub struct Policy {
+    /// The maximum recoverable failures allowed per uploading window.
+    ///
+    /// Limiting this is necessary to avoid infinite loops on requesting upload tasks.
+    max_recoverable_failures: Option<u32>,
+    /// The maximum of [`PingUploadTask::Wait`] responses a user may get in a row
+    /// when calling [`get_upload_task`].
+    ///
+    /// Limiting this is necessary to avoid infinite loops on requesting upload tasks.
+    max_wait_attempts: Option<u32>,
+    /// The maximum size in bytes a ping body may have to be eligible for upload.
+    max_ping_body_size: Option<usize>,
+    /// The maximum size in byte the pending pings directory may have on disk.
+    max_pending_pings_directory_size: Option<u64>,
+}
+
+impl Default for Policy {
+    fn default() -> Self {
+        Policy {
+            max_recoverable_failures: Some(MAX_RECOVERABLE_FAILURES),
+            max_wait_attempts: Some(MAX_WAIT_ATTEMPTS),
+            max_ping_body_size: Some(MAX_PING_BODY_SIZE),
+            max_pending_pings_directory_size: Some(MAX_PENDING_PINGS_DIRECTORY_SIZE),
+        }
+    }
+}
+
+impl Policy {
+    pub fn max_recoverable_failures(&self) -> u32 {
+        match &self.max_recoverable_failures {
+            Some(v) => *v,
+            None => u32::MAX,
+        }
+    }
+
+    #[cfg(test)]
+    pub fn set_max_recoverable_failures(&mut self, v: Option<u32>) {
+        self.max_recoverable_failures = v;
+    }
+
+    pub fn max_wait_attempts(&self) -> u32 {
+        match &self.max_wait_attempts {
+            Some(v) => *v,
+            None => u32::MAX,
+        }
+    }
+
+    #[cfg(test)]
+    pub fn set_max_wait_attempts(&mut self, v: Option<u32>) {
+        self.max_wait_attempts = v;
+    }
+
+    pub fn max_ping_body_size(&self) -> usize {
+        match &self.max_ping_body_size {
+            Some(v) => *v,
+            None => usize::MAX,
+        }
+    }
+
+    #[cfg(test)]
+    pub fn set_max_ping_body_size(&mut self, v: Option<usize>) {
+        self.max_ping_body_size = v;
+    }
+
+    pub fn max_pending_pings_directory_size(&self) -> u64 {
+        match &self.max_pending_pings_directory_size {
+            Some(v) => *v,
+            None => u64::MAX,
+        }
+    }
+
+    #[cfg(test)]
+    pub fn set_max_pending_pings_directory_size(&mut self, v: Option<u64>) {
+        self.max_pending_pings_directory_size = v;
+    }
+}


</patch>

<TEST>
<Filename>glean-core/src/upload/mod.rs</Filename>
<imports>use std::sync::atomic::Ordering;
use std::thread::sleep;</imports>
<Rust>#[test]
fn async_ping_scanning_sets_upload_task() {
    let (mut glean, dir) = new_glean(None);

    // Create a new upload manager with asynchronous ping directory scanning
    let upload_manager = PingUploadManager::no_policy(dir.path(), /* sync_scan */ false);

    // Register and submit a test ping
    let ping_type = crate::PingType::new("test", true, /* send_if_empty */ true, vec![]);
    glean.register_ping_type(&ping_type);
    glean.submit_ping(&ping_type, None).unwrap();

    // Wait for the async scan to process the ping
    let mut task;
    loop {
        task = upload_manager.get_upload_task(&glean, false);
        if task != PingUploadTask::Wait {
            break;
        }
        sleep(std::time::Duration::from_millis(10));
    }

    // Verify the task is not `Done` (there's a ping to upload)
    assert_ne!(task, PingUploadTask::Done);
}
</Rust>
</TEST>

<output>
running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

running 1 test

thread 'upload::test::async_ping_scanning_sets_upload_task' panicked at glean-core/src/upload/mod.rs:1345:9:
assertion `left != right` failed
  left: Done
 right: Done
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
test upload::test::async_ping_scanning_sets_upload_task ... FAILED
</output>

Function signatures
<Signatures>
fn client_id_is_set_to_random_value_when_uploading_enabled_at_start() -> ()

fn limits_on_experiments_extras_are_applied_correctly() -> ()

fn enabling_when_already_enabled_is_a_noop() -> ()

fn client_id_and_first_run_date_must_be_regenerated() -> ()

pub fn new_glean(tempdir: Option<tempfile::TempDir>) -> (Glean, tempfile::TempDir)

fn client_id_is_managed_correctly_when_toggling_uploading() -> ()

fn records_database_file_size() -> ()

fn client_id_is_set_to_known_value_when_uploading_disabled_at_start() -> ()

fn experiment_id_and_branch_get_truncated_if_too_long() -> ()

fn path_is_constructed_from_data() -> ()
</Signatures>

You are a software tester at glean and your are reviewing the above <patch> for the above <issue>.
A unit test has already been created for this PR and can be found alongside the filename and the imports used inside the <TEST> block.The test should fail on the code before the patch, and pass after, hence the test verifies that the patch resolves the issue.
However, the test currently fails after the patch.
Your task is to:
1. Identify and understand why the unit test failed.
2. Update the unit test in the <TEST> block in order for it to fail on the code before the patch, and pass after, hence verifying that the patch resolves the issue.
3. All 'use' declarations must be inside a <imports>...</imports> block. Additionally:
   - Do not use group imports.
  - Import only what is necessary for the test to run and make sure not to have colliding imports.
  - If the <patch> contains a 'mod tests' block with useful imports, do not add them to the <imports> block.
  - Use `use super::<function name> for the function under test.
.  - If multiple 'use' statements are needed, list each on a separate line.
4. To help you write the test, <Signatures> contains all modified function's:
  - name
  - parameters
  - Return type (assume '()' if empty)
5. Return only the absolute filename as it is in the <patch> block, the use statements, and rust test (no comments or explanations).

Follow this expected output format, do not deviate from this structure:
<Filename> ... </Filename>
<imports> ... </imports>
<Rust>
#[test]
fn test_<describe_behavior>() {
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
}</Rust>

