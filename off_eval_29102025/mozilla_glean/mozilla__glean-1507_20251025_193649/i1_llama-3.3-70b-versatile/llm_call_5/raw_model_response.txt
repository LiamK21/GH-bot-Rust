<Filename>glean-core/rlb/src/test.rs</Filename>
<imports>
use std::sync::{Arc, Mutex};
use super::PingType;
use crossbeam_channel::bounded;
use tempfile::tempdir;
use crate::net::PingUploader;
use crate::Configuration;
use crate::new_glean;
use crate::block_on_dispatcher;
use crate::Lifetime;
use crate::CommonMetricData;
use crate::metrics::CounterMetric;
use std::path::PathBuf;
use crate::upload::UploadResult;
</imports>
<Rust>
#[test]
fn test_custom_ping_submission_callback() {
  let _lock = Arc::new(Mutex::new(()));
  let (s, r) = bounded(1);
  let dir = tempdir().unwrap();
  let tmpname = dir.path().to_path_buf();
  let cfg = Configuration {
    data_path: tmpname.to_str().unwrap().to_string(),
    application_id: "test".into(),
    upload_enabled: true,
    max_events: None,
    delay_ping_lifetime_io: false,
    language_binding_name: "test".into(),
    channel: Some("testing".into()),
    server_endpoint: Some("invalid-test-host".into()),
    uploader: Some(Box::new(FakeUploader { sender: s })),
  };
  let _t = new_glean(Some(cfg), true);
  let sample_ping = PingType::new("custom1", true, true, vec![]);
  let metric = CounterMetric::new(CommonMetricData {
    name: "counter_metric".into(),
    category: "test".into(),
    send_in_pings: vec!["custom1".into()],
    lifetime: Lifetime::Application,
    disabled: false,
    dynamic_label: None,
  });
  block_on_dispatcher();
  metric.add(1);
  let called = Arc::new(Mutex::new(false));
  let called_clone = Arc::clone(&called);
  sample_ping.test_before_next_submit(move |_| {
    *called_clone.lock().unwrap() = true;
  });
  sample_ping.submit(None);
  assert!(*called.lock().unwrap());
}
struct FakeUploader {
  sender: crossbeam_channel::Sender<String>,
}
impl PingUploader for FakeUploader {
  fn upload(
    &self,
    url: String,
    _body: Vec<u8>,
    _headers: Vec<(String, String)>,
  ) -> UploadResult {
    self.sender.send(url).unwrap();
    UploadResult::HttpStatus(200)
  }
}
</Rust>