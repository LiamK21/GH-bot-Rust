Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Rust tests failing on CI, but not locally
We're currently seeing some test failures on CI with unrelated PRs and pushes.

One example: https://app.circleci.com/pipelines/github/mozilla/glean/4993/workflows/d7d9b793-fadf-4b68-bca8-f0995db99860/jobs/75141/steps

```
---- upload::test::test_processes_correctly_client_error_upload_response stdout ----

thread 'upload::test::test_processes_correctly_client_error_upload_response' panicked at 'assertion failed: `(left == right)`

  left: `Upload(PingRequest { document_id: "0ca0ffd3-16e7-4a84-a224-5bccd95d1878", path: "/submit/org-mozilla-glean-test-app/test/1/0ca0ffd3-16e7-4a84-a224-5bccd95d1878", body: [31, 139, 8, 0, 0, 0, 0, 0, 0, 255, 133, 78, 75, 14, 194, 32, 20, 188, 203, 219, 90, 154, 87, 74, 32, 114, 6, 151, 238, 9, 45, 15, 67, 108, 169, 2, 77, 52, 77, 239, 46, 110, 154, 184, 114, 53, 153, 201, 252, 54, 24, 167, 64, 177, 152, 16, 253, 2, 122, 59, 168, 3, 13, 138, 132, 83, 210, 91, 230, 7, 47, 153, 160, 158, 179, 51, 239, 58, 38, 133, 245, 163, 87, 74, 138, 222, 67, 3, 62, 164, 92, 76, 90, 163, 113, 182, 80, 205, 113, 228, 200, 80, 50, 46, 79, 136, 26, 177, 122, 150, 92, 245, 75, 136, 235, 171, 146, 66, 19, 205, 84, 210, 219, 100, 119, 55, 195, 26, 166, 239, 90, 223, 181, 188, 237, 96, 111, 224, 17, 226, 237, 56, 68, 209, 153, 18, 230, 223, 222, 43, 42, 205, 249, 209, 158, 233, 9, 26, 43, 22, 155, 202, 31, 247, 190, 127, 0, 47, 234, 58, 89, 244, 0, 0, 0], headers: {"Content-Encoding": "gzip", "Content-Length": "175", "X-Client-Version": "31.2.1", "X-Client-Type": "Glean", "Content-Type": "application/json; charset=utf-8", "Date": "Fri, 26 Jun 2020 07:22:01 GMT"} })`,

 right: `Done`', glean-core/src/upload/mod.rs:744:9

stack backtrace:

   0: backtrace::backtrace::libunwind::trace

             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.46/src/backtrace/libunwind.rs:86

   1: backtrace::backtrace::trace_unsynchronized

             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.46/src/backtrace/mod.rs:66

   2: std::sys_common::backtrace::_print_fmt

             at src/libstd/sys_common/backtrace.rs:78

   3: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt

             at src/libstd/sys_common/backtrace.rs:59

   4: core::fmt::write

             at src/libcore/fmt/mod.rs:1069

   5: std::io::Write::write_fmt

             at /rustc/c7087fe00d2ba919df1d813c040a5d47e43b0fe7/src/libstd/io/mod.rs:1504

   6: std::io::impls::<impl std::io::Write for alloc::boxed::Box<W>>::write_fmt

             at src/libstd/io/impls.rs:156

   7: std::sys_common::backtrace::_print

             at src/libstd/sys_common/backtrace.rs:62

   8: std::sys_common::backtrace::print

             at src/libstd/sys_common/backtrace.rs:49

   9: std::panicking::default_hook::{{closure}}

             at src/libstd/panicking.rs:198

  10: std::panicking::default_hook

             at src/libstd/panicking.rs:215

  11: std::panicking::rust_panic_with_hook

             at src/libstd/panicking.rs:511

  12: rust_begin_unwind

             at src/libstd/panicking.rs:419

  13: std::panicking::begin_panic_fmt

             at src/libstd/panicking.rs:373

  14: glean_core::upload::test::test_processes_correctly_client_error_upload_response

             at glean-core/src/upload/mod.rs:744

  15: glean_core::upload::test::test_processes_correctly_client_error_upload_response::{{closure}}

             at glean-core/src/upload/mod.rs:718

  16: core::ops::function::FnOnce::call_once

             at /rustc/c7087fe00d2ba919df1d813c040a5d47e43b0fe7/src/libcore/ops/function.rs:232

  17: <alloc::boxed::Box<F> as core::ops::function::FnOnce<A>>::call_once

             at /rustc/c7087fe00d2ba919df1d813c040a5d47e43b0fe7/src/liballoc/boxed.rs:1008

  18: <std::panic::AssertUnwindSafe<F> as core::ops::function::FnOnce<()>>::call_once

             at /rustc/c7087fe00d2ba919df1d813c040a5d47e43b0fe7/src/libstd/panic.rs:318

  19: std::panicking::try::do_call

             at /rustc/c7087fe00d2ba919df1d813c040a5d47e43b0fe7/src/libstd/panicking.rs:331

  20: std::panicking::try

             at /rustc/c7087fe00d2ba919df1d813c040a5d47e43b0fe7/src/libstd/panicking.rs:274

  21: std::panic::catch_unwind

             at /rustc/c7087fe00d2ba919df1d813c040a5d47e43b0fe7/src/libstd/panic.rs:394

  22: test::run_test_in_process

             at src/libtest/lib.rs:541

  23: test::run_test::run_test_inner::{{closure}}

             at src/libtest/lib.rs:450

note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.





failures:

    upload::test::test_processes_correctly_client_error_upload_response
```

Yesterday we saw another one.
It's not 100% clear why that happens, but from the above it looks like the order of pings returned might be different from what we expect or there are additional pending pings we didn't consider (or didn't clear up?)
</issue>

Patch:
<patch>
diff --git a/glean-core/ffi/src/lib.rs b/glean-core/ffi/src/lib.rs
--- a/glean-core/ffi/src/lib.rs
+++ b/glean-core/ffi/src/lib.rs
@@ -457,7 +457,7 @@ pub unsafe extern "C" fn glean_process_ping_upload_response(
                 let document_id_str = CStr::from_ptr(document_id)
                     .to_str()
                     .map_err(|_| glean_core::Error::utf8_error())?;
-                ping_uploader.process_ping_upload_response(document_id_str, status.into());
+                ping_uploader.process_ping_upload_response(document_id_str, status.into(), None);
             };
             Ok(())
         });

diff --git a/glean-core/src/lib.rs b/glean-core/src/lib.rs
--- a/glean-core/src/lib.rs
+++ b/glean-core/src/lib.rs
@@ -499,7 +499,7 @@ impl Glean {
         }
 
         self.upload_manager
-            .process_ping_upload_response(uuid, status);
+            .process_ping_upload_response(uuid, status, self.debug_view_tag());
     }
 
     /// Take a snapshot for the given store and optionally clear it.

diff --git a/glean-core/src/upload/directory.rs b/glean-core/src/upload/directory.rs
--- a/glean-core/src/upload/directory.rs
+++ b/glean-core/src/upload/directory.rs
@@ -12,9 +12,12 @@ use std::path::{Path, PathBuf};
 use serde_json::Value as JsonValue;
 use uuid::Uuid;
 
-use super::PingRequest;
 use crate::{DELETION_REQUEST_PINGS_DIRECTORY, PENDING_PINGS_DIRECTORY};
 
+/// A representation of the data extracted from a ping file,
+/// this will contain the document_id, path and JSON encoded body of a ping, respectively.
+type PingPayload = (String, String, JsonValue);
+
 /// Get the file name from a path as a &str.
 ///
 /// # Panics
@@ -82,14 +85,14 @@ impl PingDirectoryManager {
         };
     }
 
-    /// Reads a ping file and returns a `PingRequest` from it.
+    /// Reads a ping file and returns the data from it.
     ///
     /// If the file is not properly formatted, it will be deleted and `None` will be returned.
     ///
     /// ## Arguments
     ///
     /// * `document_id` - The UUID of the ping file to be processed
-    pub fn process_file(&self, document_id: &str) -> Option<PingRequest> {
+    pub fn process_file(&self, document_id: &str) -> Option<PingPayload> {
         let path = match self.get_file_path(document_id) {
             Some(path) => path,
             None => {
@@ -113,7 +116,7 @@ impl PingDirectoryManager {
         let mut lines = BufReader::new(file).lines();
         if let (Some(Ok(path)), Some(Ok(body))) = (lines.next(), lines.next()) {
             if let Ok(parsed_body) = serde_json::from_str::<JsonValue>(&body) {
-                return Some(PingRequest::new(document_id, &path, parsed_body, None));
+                return Some((document_id.to_string(), path, parsed_body));
             } else {
                 log::warn!(
                     "Error processing ping file: {}. Can't parse ping contents as JSON.",
@@ -130,7 +133,7 @@ impl PingDirectoryManager {
         None
     }
 
-    /// Process the pings directory and return a vector of `PingRequest`s
+    /// Process the pings directory and return a vector with the ping data
     /// corresponding to each valid ping file in the directory.
     /// This vector will be ordered by file `modified_date`.
     ///
@@ -141,8 +144,9 @@ impl PingDirectoryManager {
     ///
     /// # Return value
     ///
-    /// `Vec<PingRequest>` - see [`PingRequest`](struct.PingRequest.html) for more information.
-    pub fn process_dir(&self) -> Vec<PingRequest> {
+    /// `Vec<(String, String, JsonValue)>` -
+    ///     a vector of tuples containing the document_id, path and body of each request.
+    pub fn process_dir(&self) -> Vec<PingPayload> {
         log::info!("Processing persisted pings.");
 
         // Walk the pings directory and process each file in it,
@@ -162,11 +166,11 @@ impl PingDirectoryManager {
                         return None;
                     }
                     // In case we can't process the file we just ignore it.
-                    if let Some(request) = self.process_file(file_name) {
+                    if let Some(data) = self.process_file(file_name) {
                         // Get the modified date of the file, which will later be used
                         // for sorting the resulting vector.
                         let modified_date = fs::metadata(&path).and_then(|data| data.modified());
-                        return Some((modified_date, request));
+                        return Some((modified_date, data));
                     }
                 };
                 None
@@ -184,11 +188,8 @@ impl PingDirectoryManager {
             }
         });
 
-        // Return the vector leaving only the `PingRequest`s in it
-        pending_pings
-            .into_iter()
-            .map(|(_, request)| request)
-            .collect()
+        // Return the vector leaving only the `PingPayload`s in it
+        pending_pings.into_iter().map(|(_, data)| data).collect()
     }
 
     /// Get all the ping entries in all ping directories.
@@ -228,7 +229,7 @@ mod test {
     use crate::tests::new_glean;
 
     #[test]
-    fn test_doesnt_panic_if_no_pending_pings_directory() {
+    fn doesnt_panic_if_no_pending_pings_directory() {
         let dir = tempfile::tempdir().unwrap();
         let directory_manager = PingDirectoryManager::new(dir.path());
 
@@ -237,7 +238,7 @@ mod test {
     }
 
     #[test]
-    fn test_creates_requests_correctly_from_valid_ping_file() {
+    fn gets_correct_data_from_valid_ping_file() {
         let (mut glean, dir) = new_glean(None);
 
         // Register a ping for testing
@@ -250,18 +251,18 @@ mod test {
         let directory_manager = PingDirectoryManager::new(dir.path());
 
         // Try and process the pings folder
-        let requests = directory_manager.process_dir();
+        let data = directory_manager.process_dir();
 
         // Verify there is just the one request
-        assert_eq!(requests.len(), 1);
+        assert_eq!(data.len(), 1);
 
         // Verify request was returned for the "test" ping
-        let request_ping_type = requests[0].path.split('/').nth(3).unwrap();
+        let request_ping_type = data[0].1.split('/').nth(3).unwrap();
         assert_eq!(request_ping_type, "test");
     }
 
     #[test]
-    fn test_non_uuid_files_are_deleted_and_ignored() {
+    fn non_uuid_files_are_deleted_and_ignored() {
         let (mut glean, dir) = new_glean(None);
 
         // Register a ping for testing
@@ -280,13 +281,13 @@ mod test {
         File::create(&not_uuid_path).unwrap();
 
         // Try and process the pings folder
-        let requests = directory_manager.process_dir();
+        let data = directory_manager.process_dir();
 
         // Verify there is just the one request
-        assert_eq!(requests.len(), 1);
+        assert_eq!(data.len(), 1);
 
         // Verify request was returned for the "test" ping
-        let request_ping_type = requests[0].path.split('/').nth(3).unwrap();
+        let request_ping_type = data[0].1.split('/').nth(3).unwrap();
         assert_eq!(request_ping_type, "test");
 
         // Verify that file was indeed deleted
@@ -294,7 +295,7 @@ mod test {
     }
 
     #[test]
-    fn test_wrongly_formatted_files_are_deleted_and_ignored() {
+    fn wrongly_formatted_files_are_deleted_and_ignored() {
         let (mut glean, dir) = new_glean(None);
 
         // Register a ping for testing
@@ -313,13 +314,13 @@ mod test {
         File::create(&wrong_contents_file_path).unwrap();
 
         // Try and process the pings folder
-        let requests = directory_manager.process_dir();
+        let data = directory_manager.process_dir();
 
         // Verify there is just the one request
-        assert_eq!(requests.len(), 1);
+        assert_eq!(data.len(), 1);
 
         // Verify request was returned for the "test" ping
-        let request_ping_type = requests[0].path.split('/').nth(3).unwrap();
+        let request_ping_type = data[0].1.split('/').nth(3).unwrap();
         assert_eq!(request_ping_type, "test");
 
         // Verify that file was indeed deleted
@@ -327,7 +328,7 @@ mod test {
     }
 
     #[test]
-    fn test_non_json_ping_body_files_are_deleted_and_ignored() {
+    fn non_json_ping_body_files_are_deleted_and_ignored() {
         let (mut glean, dir) = new_glean(None);
 
         // Register a ping for testing
@@ -352,13 +353,13 @@ mod test {
             .unwrap();
 
         // Try and process the pings folder
-        let requests = directory_manager.process_dir();
+        let data = directory_manager.process_dir();
 
         // Verify there is just the one request
-        assert_eq!(requests.len(), 1);
+        assert_eq!(data.len(), 1);
 
         // Verify request was returned for the "test" ping
-        let request_ping_type = requests[0].path.split('/').nth(3).unwrap();
+        let request_ping_type = data[0].1.split('/').nth(3).unwrap();
         assert_eq!(request_ping_type, "test");
 
         // Verify that file was indeed deleted
@@ -366,7 +367,7 @@ mod test {
     }
 
     #[test]
-    fn test_takes_deletion_request_pings_into_account_while_processing() {
+    fn takes_deletion_request_pings_into_account_while_processing() {
         let (glean, dir) = new_glean(None);
 
         // Submit a deletion request ping to populate deletion request folder.
@@ -379,10 +380,12 @@ mod test {
         let directory_manager = PingDirectoryManager::new(dir.path());
 
         // Try and process the pings folder
-        let requests = directory_manager.process_dir();
+        let data = directory_manager.process_dir();
 
-        assert_eq!(requests.len(), 1);
+        assert_eq!(data.len(), 1);
 
-        assert!(requests[0].is_deletion_request());
+        // Verify request was returned for the "deletion-request" ping
+        let request_ping_type = data[0].1.split('/').nth(3).unwrap();
+        assert_eq!(request_ping_type, "deletion-request");
     }
 }

diff --git a/glean-core/src/upload/mod.rs b/glean-core/src/upload/mod.rs
--- a/glean-core/src/upload/mod.rs
+++ b/glean-core/src/upload/mod.rs
@@ -196,7 +196,13 @@ impl PingUploadManager {
                 let mut local_queue = local_queue
                     .write()
                     .expect("Can't write to pending pings queue.");
-                local_queue.extend(local_manager.process_dir());
+                for (document_id, path, body) in local_manager.process_dir() {
+                    if Self::is_enqueued(&local_queue, &document_id) {
+                        continue;
+                    }
+                    let request = PingRequest::new(&document_id, &path, body, None);
+                    local_queue.push_back(request);
+                }
                 local_flag.store(true, Ordering::SeqCst);
             })
             .expect("Unable to spawn thread to process pings directories.");
@@ -219,6 +225,13 @@ impl PingUploadManager {
         self.processed_pending_pings.load(Ordering::SeqCst)
     }
 
+    /// Checks if a ping with a certain `document_id` is already enqueued.
+    fn is_enqueued(queue: &VecDeque<PingRequest>, document_id: &str) -> bool {
+        queue
+            .iter()
+            .any(|request| request.document_id == document_id)
+    }
+
     /// Adds rate limiting capability to this upload manager. The rate limiter
     /// will limit the amount of calls to `get_upload_task` per interval.
     ///
@@ -238,6 +251,8 @@ impl PingUploadManager {
     }
 
     /// Creates a `PingRequest` and adds it to the queue.
+    ///
+    /// Duplicate requests won't be added.
     pub fn enqueue_ping(
         &self,
         document_id: &str,
@@ -245,13 +260,23 @@ impl PingUploadManager {
         body: JsonValue,
         debug_view_tag: Option<&String>,
     ) {
-        log::trace!("Enqueuing ping {} at {}", document_id, path);
-
         let mut queue = self
             .queue
             .write()
             .expect("Can't write to pending pings queue.");
-        let request = PingRequest::new(document_id, path, body, debug_view_tag);
+
+        // Checks if a ping with a certain `document_id` is already enqueued.
+        if Self::is_enqueued(&queue, document_id) {
+            log::trace!(
+                "Attempted to enqueue a duplicate ping {} at {}.",
+                document_id,
+                path
+            );
+            return;
+        }
+
+        log::trace!("Enqueuing ping {} at {}", document_id, path);
+        let request = PingRequest::new(&document_id, &path, body, debug_view_tag);
         queue.push_back(request);
     }
 
@@ -366,7 +391,13 @@ impl PingUploadManager {
     ///
     /// `document_id` - The UUID of the ping in question.
     /// `status` - The HTTP status of the response.
-    pub fn process_ping_upload_response(&self, document_id: &str, status: UploadResult) {
+    /// `debug_view_tag` - The value of the `X-Debug-Id` header, if this is `None` the header is not added.
+    pub fn process_ping_upload_response(
+        &self,
+        document_id: &str,
+        status: UploadResult,
+        debug_view_tag: Option<&String>,
+    ) {
         use UploadResult::*;
         match status {
             HttpStatus(status @ 200..=299) => {
@@ -389,12 +420,10 @@ impl PingUploadManager {
                     document_id,
                     status
                 );
-                if let Some(request) = self.directory_manager.process_file(document_id) {
-                    let mut queue = self
-                        .queue
-                        .write()
-                        .expect("Can't write to pending pings queue.");
-                    queue.push_back(request);
+                if let Some((document_id, path, body)) =
+                    self.directory_manager.process_file(document_id)
+                {
+                    self.enqueue_ping(&document_id, &path, body, debug_view_tag);
                 }
             }
         };
@@ -473,17 +502,17 @@ mod test {
     use std::time::Duration;
 
     use serde_json::json;
+    use uuid::Uuid;
 
     use super::UploadResult::*;
     use super::*;
     use crate::metrics::PingType;
     use crate::{tests::new_glean, PENDING_PINGS_DIRECTORY};
 
-    const DOCUMENT_ID: &str = "40e31919-684f-43b0-a5aa-e15c2d56a674"; // Just a random UUID.
     const PATH: &str = "/submit/app_id/ping_name/schema_version/doc_id";
 
     #[test]
-    fn test_doesnt_error_when_there_are_no_pending_pings() {
+    fn doesnt_error_when_there_are_no_pending_pings() {
         // Create a new upload_manager
         let dir = tempfile::tempdir().unwrap();
         let upload_manager = PingUploadManager::new(dir.path(), false);
@@ -499,7 +528,7 @@ mod test {
     }
 
     #[test]
-    fn test_returns_ping_request_when_there_is_one() {
+    fn returns_ping_request_when_there_is_one() {
         // Create a new upload_manager
         let dir = tempfile::tempdir().unwrap();
         let upload_manager = PingUploadManager::new(dir.path(), false);
@@ -510,7 +539,7 @@ mod test {
         }
 
         // Enqueue a ping
-        upload_manager.enqueue_ping(DOCUMENT_ID, PATH, json!({}), None);
+        upload_manager.enqueue_ping(&Uuid::new_v4().to_string(), PATH, json!({}), None);
 
         // Try and get the next request.
         // Verify request was returned
@@ -521,7 +550,7 @@ mod test {
     }
 
     #[test]
-    fn test_returns_as_many_ping_requests_as_there_are() {
+    fn returns_as_many_ping_requests_as_there_are() {
         // Create a new upload_manager
         let dir = tempfile::tempdir().unwrap();
         let upload_manager = PingUploadManager::new(dir.path(), false);
@@ -534,7 +563,7 @@ mod test {
         // Enqueue a ping multiple times
         let n = 10;
         for _ in 0..n {
-            upload_manager.enqueue_ping(DOCUMENT_ID, PATH, json!({}), None);
+            upload_manager.enqueue_ping(&Uuid::new_v4().to_string(), PATH, json!({}), None);
         }
 
         // Verify a request is returned for each submitted ping
@@ -550,7 +579,7 @@ mod test {
     }
 
     #[test]
-    fn test_limits_the_number_of_pings_when_there_is_rate_limiting() {
+    fn limits_the_number_of_pings_when_there_is_rate_limiting() {
         // Create a new upload_manager
         let dir = tempfile::tempdir().unwrap();
         let mut upload_manager = PingUploadManager::new(dir.path(), false);
@@ -567,7 +596,7 @@ mod test {
 
         // Enqueue a ping multiple times
         for _ in 0..max_pings_per_interval {
-            upload_manager.enqueue_ping(DOCUMENT_ID, PATH, json!({}), None);
+            upload_manager.enqueue_ping(&Uuid::new_v4().to_string(), PATH, json!({}), None);
         }
 
         // Verify a request is returned for each submitted ping
@@ -580,7 +609,7 @@ mod test {
 
         // Enqueue just one more ping.
         // We should still be within the default rate limit time.
-        upload_manager.enqueue_ping(DOCUMENT_ID, PATH, json!({}), None);
+        upload_manager.enqueue_ping(&Uuid::new_v4().to_string(), PATH, json!({}), None);
 
         // Verify that we are indeed told to wait because we are at capacity
         assert_eq!(PingUploadTask::Wait, upload_manager.get_upload_task(false));
@@ -594,7 +623,7 @@ mod test {
     }
 
     #[test]
-    fn test_clearing_the_queue_works_correctly() {
+    fn clearing_the_queue_works_correctly() {
         // Create a new upload_manager
         let dir = tempfile::tempdir().unwrap();
         let upload_manager = PingUploadManager::new(dir.path(), false);
@@ -606,7 +635,7 @@ mod test {
 
         // Enqueue a ping multiple times
         for _ in 0..10 {
-            upload_manager.enqueue_ping(DOCUMENT_ID, PATH, json!({}), None);
+            upload_manager.enqueue_ping(&Uuid::new_v4().to_string(), PATH, json!({}), None);
         }
 
         // Clear the queue
@@ -617,9 +646,14 @@ mod test {
     }
 
     #[test]
-    fn test_clearing_the_queue_doesnt_clear_deletion_request_pings() {
+    fn clearing_the_queue_doesnt_clear_deletion_request_pings() {
         let (mut glean, _) = new_glean(None);
 
+        // Wait for processing of pending pings directory to finish.
+        while glean.get_upload_task(false) == PingUploadTask::Wait {
+            thread::sleep(Duration::from_millis(10));
+        }
+
         // Register a ping for testing
         let ping_type = PingType::new("test", true, /* send_if_empty */ true, vec![]);
         glean.register_ping_type(&ping_type);
@@ -650,9 +684,14 @@ mod test {
     }
 
     #[test]
-    fn test_fills_up_queue_successfully_from_disk() {
+    fn fills_up_queue_successfully_from_disk() {
         let (mut glean, _) = new_glean(None);
 
+        // Wait for processing of pending pings directory to finish.
+        while glean.get_upload_task(false) == PingUploadTask::Wait {
+            thread::sleep(Duration::from_millis(10));
+        }
+
         // Register a ping for testing
         let ping_type = PingType::new("test", true, /* send_if_empty */ true, vec![]);
         glean.register_ping_type(&ping_type);
@@ -685,9 +724,14 @@ mod test {
     }
 
     #[test]
-    fn test_processes_correctly_success_upload_response() {
+    fn processes_correctly_success_upload_response() {
         let (mut glean, dir) = new_glean(None);
 
+        // Wait for processing of pending pings directory to finish.
+        while glean.get_upload_task(false) == PingUploadTask::Wait {
+            thread::sleep(Duration::from_millis(10));
+        }
+
         // Register a ping for testing
         let ping_type = PingType::new("test", true, /* send_if_empty */ true, vec![]);
         glean.register_ping_type(&ping_type);
@@ -715,9 +759,14 @@ mod test {
     }
 
     #[test]
-    fn test_processes_correctly_client_error_upload_response() {
+    fn processes_correctly_client_error_upload_response() {
         let (mut glean, dir) = new_glean(None);
 
+        // Wait for processing of pending pings directory to finish.
+        while glean.get_upload_task(false) == PingUploadTask::Wait {
+            thread::sleep(Duration::from_millis(10));
+        }
+
         // Register a ping for testing
         let ping_type = PingType::new("test", true, /* send_if_empty */ true, vec![]);
         glean.register_ping_type(&ping_type);
@@ -745,9 +794,14 @@ mod test {
     }
 
     #[test]
-    fn test_processes_correctly_server_error_upload_response() {
+    fn processes_correctly_server_error_upload_response() {
         let (mut glean, _) = new_glean(None);
 
+        // Wait for processing of pending pings directory to finish.
+        while glean.get_upload_task(false) == PingUploadTask::Wait {
+            thread::sleep(Duration::from_millis(10));
+        }
+
         // Register a ping for testing
         let ping_type = PingType::new("test", true, /* send_if_empty */ true, vec![]);
         glean.register_ping_type(&ping_type);
@@ -777,9 +831,14 @@ mod test {
     }
 
     #[test]
-    fn test_processes_correctly_unrecoverable_upload_response() {
+    fn processes_correctly_unrecoverable_upload_response() {
         let (mut glean, dir) = new_glean(None);
 
+        // Wait for processing of pending pings directory to finish.
+        while glean.get_upload_task(false) == PingUploadTask::Wait {
+            thread::sleep(Duration::from_millis(10));
+        }
+
         // Register a ping for testing
         let ping_type = PingType::new("test", true, /* send_if_empty */ true, vec![]);
         glean.register_ping_type(&ping_type);
@@ -817,14 +876,14 @@ mod test {
             thread::sleep(Duration::from_millis(10));
         }
 
-        let doc1 = "684fa150-8dff-11ea-8faf-cb1ff3b11119";
+        let doc1 = Uuid::new_v4().to_string();
         let path1 = format!("/submit/app_id/test-ping/1/{}", doc1);
 
-        let doc2 = "74f14e9a-8dff-11ea-b45a-6f936923f639";
+        let doc2 = Uuid::new_v4().to_string();
         let path2 = format!("/submit/app_id/test-ping/1/{}", doc2);
 
         // Enqueue a ping
-        upload_manager.enqueue_ping(doc1, &path1, json!({}), None);
+        upload_manager.enqueue_ping(&doc1, &path1, json!({}), None);
 
         // Try and get the first request.
         let req = match upload_manager.get_upload_task(false) {
@@ -834,10 +893,10 @@ mod test {
         assert_eq!(doc1, req.document_id);
 
         // Schedule the next one while the first one is "in progress"
-        upload_manager.enqueue_ping(doc2, &path2, json!({}), None);
+        upload_manager.enqueue_ping(&doc2, &path2, json!({}), None);
 
         // Mark as processed
-        upload_manager.process_ping_upload_response(&req.document_id, HttpStatus(200));
+        upload_manager.process_ping_upload_response(&req.document_id, HttpStatus(200), None);
 
         // Get the second request.
         let req = match upload_manager.get_upload_task(false) {
@@ -847,17 +906,14 @@ mod test {
         assert_eq!(doc2, req.document_id);
 
         // Mark as processed
-        upload_manager.process_ping_upload_response(&req.document_id, HttpStatus(200));
+        upload_manager.process_ping_upload_response(&req.document_id, HttpStatus(200), None);
 
         // ... and then we're done.
-        match upload_manager.get_upload_task(false) {
-            PingUploadTask::Done => {}
-            _ => panic!("Expected upload manager to return the next request!"),
-        }
+        assert_eq!(upload_manager.get_upload_task(false), PingUploadTask::Done);
     }
 
     #[test]
-    fn test_uploader_sync_init() {
+    fn uploader_sync_init() {
         // Create a new upload_manager, with a synchronous ping dir scan.
         let dir = tempfile::tempdir().unwrap();
         let upload_manager = PingUploadManager::new(dir.path(), true);
@@ -868,8 +924,14 @@ mod test {
     }
 
     #[test]
-    fn test_adds_debug_view_header_to_requests_when_tag_is_set() {
+    fn adds_debug_view_header_to_requests_when_tag_is_set() {
         let (mut glean, _) = new_glean(None);
+
+        // Wait for processing of pending pings directory to finish.
+        while glean.get_upload_task(false) == PingUploadTask::Wait {
+            thread::sleep(Duration::from_millis(10));
+        }
+
         glean.set_debug_view_tag("valid-tag");
 
         // Register a ping for testing
@@ -887,4 +949,32 @@ mod test {
             _ => panic!("Expected upload manager to return the next request!"),
         }
     }
+
+    #[test]
+    fn duplicates_are_not_enqueued() {
+        // Create a new upload_manager
+        let dir = tempfile::tempdir().unwrap();
+        let upload_manager = PingUploadManager::new(dir.path(), false);
+
+        // Wait for processing of pending pings directory to finish.
+        while upload_manager.get_upload_task(false) == PingUploadTask::Wait {
+            thread::sleep(Duration::from_millis(10));
+        }
+
+        let doc_id = Uuid::new_v4().to_string();
+        let path = format!("/submit/app_id/test-ping/1/{}", doc_id);
+
+        // Try to enqueue a ping with the same doc_id twice
+        upload_manager.enqueue_ping(&doc_id, &path, json!({}), None);
+        upload_manager.enqueue_ping(&doc_id, &path, json!({}), None);
+
+        // Get a task once
+        match upload_manager.get_upload_task(false) {
+            PingUploadTask::Upload(_) => {}
+            _ => panic!("Expected upload manager to return the next request!"),
+        }
+
+        // There should be no more queued tasks
+        assert_eq!(upload_manager.get_upload_task(false), PingUploadTask::Done);
+    }
 }


</patch>

<TEST>
<Filename>glean-core/src/upload/mod.rs</Filename>
<imports>use std::fs;
use std::fs::File;
use std::io::Write;</imports>
<Rust>#[test]
fn test_requeues_after_client_error_with_disk_ping() {
    let dir = tempfile::tempdir().unwrap();
    let upload_manager = PingUploadManager::new(dir.path(), false);

    let doc_id = Uuid::new_v4().to_string();
    let ping_dir = dir.path().join(PENDING_PINGS_DIRECTORY);
    fs::create_dir_all(&ping_dir).unwrap();

    let ping_path = ping_dir.join(format!("{}.incomplete", doc_id));
    let mut file = File::create(&ping_path).unwrap();
    writeln!(file, "/submit/APP_ID/PING_NAME/1/{}", doc_id).unwrap();
    writeln!(file, "{{}}").unwrap();
    file.sync_all().unwrap();

    // Wait for initial processing to finish
    while upload_manager.get_upload_task(false) == PingUploadTask::Wait {
        thread::sleep(Duration::from_millis(10));
    }

    let queue = upload_manager.queue.read().unwrap();
    assert!(queue.is_empty(), "Queue shouldn't contain any requests after startup");

    upload_manager.process_ping_upload_response(&doc_id, UploadResult::HttpStatus(400), None);

    // Wait for directory processing to complete
    while upload_manager.get_upload_task(false) == PingUploadTask::Wait {
        thread::sleep(Duration::from_millis(10));
    }

    let request = match upload_manager.get_upload_task(false) {
        PingUploadTask::Upload(req) => req,
        _ => panic!("Expected requeued ping"),
    };

    assert_eq!(request.document_id, doc_id);
}
</Rust>
</TEST>

<output>
error[timeout]: Test execution exceeded the time limit of 300 seconds.
    Updating crates.io index
 Downloading crates ...
  Downloaded adler32 v1.0.4
  Downloaded c2-chacha v0.2.3
  Downloaded arrayref v0.3.6
  Downloaded crc32fast v1.2.0
  Downloaded miniz_oxide v0.3.6
  Downloaded atty v0.2.14
  Downloaded bitflags v1.2.1
  Downloaded proc-macro2 v1.0.9
  Downloaded json-pointer v0.3.2
  Downloaded bincode v1.2.1
  Downloaded bstr v0.2.11
  Downloaded autocfg v1.0.0
  Downloaded humantime v1.3.0
  Downloaded byteorder v1.3.4
  Downloaded either v1.5.3
  Downloaded cfg-if v0.1.10
  Downloaded rand_core v0.5.1
  Downloaded pkg-config v0.3.17
  Downloaded num_cpus v1.12.0
  Downloaded cc v1.0.50
  Downloaded num-integer v0.1.42
  Downloaded rkv v0.10.3
  Downloaded textwrap v0.11.0
  Downloaded semver v0.9.0
  Downloaded walkdir v2.3.1
  Downloaded tinytemplate v1.0.3
  Downloaded unicode-normalization v0.1.12
  Downloaded serde_derive v1.0.104
  Downloaded version_check v0.9.1
  Downloaded unicode-xid v0.2.0
  Downloaded ppv-lite86 v0.2.6
  Downloaded idna v0.2.0
  Downloaded tempfile v3.1.0
  Downloaded failure v0.1.6
  Downloaded regex-syntax v0.6.16
  Downloaded crossbeam-utils v0.7.2
  Downloaded ryu v1.0.2
  Downloaded nom v5.1.1
  Downloaded once_cell v1.3.1
  Downloaded csv-core v0.1.10
  Downloaded unicode-width v0.1.7
  Downloaded libc v0.2.71
  Downloaded smallvec v1.2.0
  Downloaded rayon v1.3.0
  Downloaded url v2.1.1
  Downloaded rayon-core v1.7.0
  Downloaded regex-automata v0.1.8
  Downloaded quick-error v1.2.3
  Downloaded log v0.4.8
  Downloaded lmdb-rkv-sys v0.9.6
  Downloaded crossbeam-deque v0.7.3
  Downloaded termcolor v1.1.0
  Downloaded semver-parser v0.7.0
  Downloaded rand_chacha v0.2.1
  Downloaded csv v1.1.3
  Downloaded lazy_static v1.4.0
  Downloaded crossbeam-epoch v0.8.2
  Downloaded chrono v0.4.10
  Downloaded rand v0.7.3
  Downloaded criterion v0.3.1
  Downloaded clap v2.33.0
  Downloaded unicode-bidi v0.3.4
  Downloaded serde_json v1.0.48
  Downloaded lmdb-rkv v0.12.3
  Downloaded ffi-support v0.4.0
  Downloaded synstructure v0.12.3
  Downloaded scopeguard v1.1.0
  Downloaded rustc_version v0.2.3
  Downloaded regex v1.3.4
  Downloaded percent-encoding v2.1.0
  Downloaded flate2 v1.0.14
  Downloaded env_logger v0.7.1
  Downloaded cast v0.2.3
  Downloaded uuid v0.8.1
  Downloaded time v0.1.42
  Downloaded syn v1.0.16
  Downloaded serde v1.0.104
  Downloaded ordered-float v1.0.2
  Downloaded num-traits v0.2.11
  Downloaded jsonschema-valid v0.3.0
  Downloaded memchr v2.3.3
  Downloaded maybe-uninit v2.0.0
  Downloaded ctor v0.1.13
  Downloaded crossbeam-queue v0.2.1
  Downloaded remove_dir_all v0.5.2
  Downloaded quote v1.0.2
  Downloaded itoa v0.4.5
  Downloaded iso8601 v0.4.0
  Downloaded iri-string v0.3.0
  Downloaded getrandom v0.1.14
  Downloaded failure_derive v0.1.6
  Downloaded itertools v0.8.2
  Downloaded criterion-plot v0.4.1
  Downloaded memoffset v0.5.3
  Downloaded matches v0.1.8
  Downloaded oorandom v11.1.0
  Downloaded plotters v0.2.12
   Compiling autocfg v1.0.0
   Compiling proc-macro2 v1.0.9
   Compiling libc v0.2.71
   Compiling unicode-xid v0.2.0
   Compiling cfg-if v0.1.10
   Compiling syn v1.0.16
   Compiling serde v1.0.104
   Compiling lazy_static v1.4.0
   Compiling num-traits v0.2.11
   Compiling byteorder v1.3.4
   Compiling quote v1.0.2
   Compiling ryu v1.0.2
   Compiling getrandom v0.1.14
   Compiling bitflags v1.2.1
   Compiling ppv-lite86 v0.2.6
   Compiling itoa v0.4.5
   Compiling c2-chacha v0.2.3
   Compiling rand_core v0.5.1
   Compiling smallvec v1.2.0
   Compiling cc v1.0.50
   Compiling matches v0.1.8
   Compiling pkg-config v0.3.17
   Compiling unicode-bidi v0.3.4
   Compiling unicode-normalization v0.1.12
   Compiling rand_chacha v0.2.1
   Compiling lmdb-rkv-sys v0.9.6
   Compiling num-integer v0.1.42
   Compiling memchr v2.3.3
   Compiling failure_derive v0.1.6
   Compiling log v0.4.8
   Compiling idna v0.2.0
   Compiling rand v0.7.3
   Compiling crc32fast v1.2.0
   Compiling percent-encoding v2.1.0
   Compiling url v2.1.1
   Compiling synstructure v0.12.3
   Compiling time v0.1.42
   Compiling adler32 v1.0.4
   Compiling lmdb-rkv v0.12.3
   Compiling miniz_oxide v0.3.6
   Compiling uuid v0.8.1
   Compiling ordered-float v1.0.2
   Compiling arrayref v0.3.6
   Compiling flate2 v1.0.14
   Compiling serde_derive v1.0.104
   Compiling ffi-support v0.4.0
   Compiling once_cell v1.3.1
   Compiling atty v0.2.14
   Compiling version_check v0.9.1
   Compiling quick-error v1.2.3
   Compiling humantime v1.3.0
   Compiling nom v5.1.1
   Compiling termcolor v1.1.0
   Compiling failure v0.1.6
   Compiling env_logger v0.7.1
   Compiling remove_dir_all v0.5.2
   Compiling tempfile v3.1.0
   Compiling ctor v0.1.13
   Compiling semver-parser v0.7.0
   Compiling semver v0.9.0
   Compiling rustc_version v0.2.3
   Compiling either v1.5.3
   Compiling crossbeam-utils v0.7.2
   Compiling itertools v0.8.2
   Compiling iso8601 v0.4.0
   Compiling memoffset v0.5.3
   Compiling regex-syntax v0.6.16
   Compiling maybe-uninit v2.0.0
   Compiling crossbeam-epoch v0.8.2
   Compiling scopeguard v1.1.0
   Compiling cast v0.2.3
   Compiling rayon-core v1.7.0
   Compiling regex v1.3.4
   Compiling crossbeam-deque v0.7.3
   Compiling crossbeam-queue v0.2.1
   Compiling regex-automata v0.1.8
   Compiling num_cpus v1.12.0
   Compiling unicode-width v0.1.7
   Compiling textwrap v0.11.0
   Compiling csv-core v0.1.10
   Compiling same-file v1.0.6
   Compiling walkdir v2.3.1
   Compiling rayon v1.3.0
   Compiling criterion-plot v0.4.1
   Compiling clap v2.33.0
   Compiling plotters v0.2.12
   Compiling oorandom v11.1.0
   Compiling serde_json v1.0.48
   Compiling bincode v1.2.1
   Compiling chrono v0.4.10
   Compiling rkv v0.10.3
   Compiling glean-core v31.2.2 (/app/testbed/glean-core)
warning: unexpected `cfg` condition value: `cargo-clippy`
  --> glean-core/src/event_database/mod.rs:23:24
   |
23 | #[derive(Debug, Clone, Deserialize, Serialize, PartialEq, Eq)]
   |                        ^^^^^^^^^^^
   |
   = note: no expected values for `feature`
   = note: using a cfg inside a derive macro will use the cfgs from the destination crate and not the ones from the defining crate
   = help: try referring to `Deserialize` crate for guidance on how handle this unexpected cfg
   = help: the derive macro `Deserialize` may come from an old version of the `serde_derive` crate, try updating your dependency with `cargo update -p serde_derive`
   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration
   = note: `#[warn(unexpected_cfgs)]` on by default
   = note: this warning originates in the derive macro `Deserialize` (in Nightly builds, run with -Z macro-backtrace for more info)
</output>

Function signatures
<Signatures>
fn glean_process_ping_upload_response(
task: *mut FfiPingUploadTask,
status: u32) -> ()
</Signatures>

You are a software tester at glean and your are reviewing the above <patch> for the above <issue>.
A unit test has already been created for this PR and can be found alongside the filename and the imports used inside the <TEST> block.
It currently fails on codebase after the patch, which the errors in the <output> block.
Your task is to:
1. Identify and understand the errors introduced by the unit test.
2. Update the unit test in the <TEST> block in order for it to fail on the code before the patch, and pass after, hence verifying that the patch resolves the issue.
3. All 'use' declarations must be inside a <imports>...</imports> block. Additionally:
   - Do not use group imports.
  - Import only what is necessary for the test to run and make sure not to have colliding imports.
  - If the <patch> contains a 'mod tests' block with useful imports, do not add them to the <imports> block.
  - Use `use super::<function name> for the function under test.
.  - If multiple 'use' statements are needed, list each on a separate line.
4. To help you write the test, <Signatures> contains all modified function's:
  - name
  - parameters
  - Return type (assume '()' if empty)
5. Return only the absolute filename as it is in the <patch> block, the use statements, and rust test (no comments or explanations).

Follow this expected output format, do not deviate from this structure:
<Filename> ... </Filename>
<imports> ... </imports>
<Rust>
#[test]
fn test_<describe_behavior>() {
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
}</Rust>

