#[test]
fn test_label_cache_prevents_multiple_insertions() {
    // Setup global metric for the test
    static GLOBAL_LABELED: OnceCell<LabeledMetric<CounterMetricType>> = OnceCell::new();
    static GLOBAL_HANDLE: u64 = 1;

    // Initialize a mock labeled metric (minimal setup for test)
    let labeled_metric = LabeledMetric::new(CounterMetricType {
        send_in_pings: Vec::new(),
        name: "test".to_string(),
        category: Some("test".to_string()),
        disabled: false,
        ..Default::default()
    });
    GLOBAL_LABELED.set(labeled_metric).unwrap();

    // Create a valid C-compatible string label
    let label = "test_label";
    let c_label = unsafe { std::ffi::CString::from_vec_with_nul_unchecked(label.as_bytes().to_vec()) };
    let ffi_label = FfiStr {
        ptr: c_label.as_ptr(),
        len: label.len(),
    };

    // First call inserts the submetric
    unsafe {
        let first_call = glean_labeled_counter_metric_get(GLOBAL_HANDLE, ffi_label);
        let second_call = glean_labeled_counter_metric_get(GLOBAL_HANDLE, ffi_label);
        // With caching enabled, both calls return the same handle
        assert_eq!(first_call, second_call);
    }
}