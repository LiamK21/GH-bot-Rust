#[test]
fn test_scheduler_avoids_lock_order_inversion() {
    let mutex1 = Arc::new(Mutex::new(()));
    let mutex2 = Arc::new(Mutex::new(()));

    let (cancel_sender, cancel_receiver) = std::sync::mpsc::channel();

    // Mock submitter that holds mutex2 while accessing shared state
    let submitter = Arc::new(move |_: &dyn std::any::Any, _reason: Option<&str>, _now: SystemTime| {
        let _guard = mutex2.lock().unwrap();
        // Simulate some processing
        std::thread::sleep(Duration::from_millis(10));
    });

    let now = SystemTime::now();
    let when = When::Reschedule;

    let scheduler_handle = thread::spawn(move || {
        let canceller = Arc::new((Mutex::new(false), Condvar::new()));
        let (cancelled, condvar) = &*canceller;

        start_scheduler(submitter, now, when, canceller);
    });

    // Simulate another thread that would deadlock without the patch
    let mutex1_clone = Arc::clone(&mutex1);
    let mutex2_clone = Arc::clone(&mutex2);
    let test_thread = thread::spawn(move || {
        // Acquire the locks in reverse order
        let _guard2 = mutex2_clone.lock().unwrap();
        std::thread::sleep(Duration::from_millis(50)); // Ensure lock ordering race
        let _guard1 = mutex1_clone.lock().unwrap();
    });

    // Let threads execute
    std::thread::sleep(Duration::from_millis(200));

    // Clean up
    cancel_sender.send(()).unwrap();
    scheduler_handle.join().unwrap();
    test_thread.join().unwrap();
}

enum When {
    Reschedule,
}