#[test]
fn test_scheduler_avoids_lock_order_inversion() {
    let mutex1 = Arc::new(Mutex::new(()));
    let mutex2 = Arc::new(Mutex::new(()));
    let (_cancel_sender, cancel_receiver) = mpsc::channel();

    let submitter = Arc::new(move |_: &dyn std::any::Any, _: Option<&str>, _: SystemTime| {
        let _guard = mutex2.lock().unwrap();
        std::thread::sleep(Duration::from_millis(10));
    });

    let now = SystemTime::now();
    let when = When::Reschedule;
    let canceller = Arc::new((Mutex::new(false), Condvar::new()));
    let (cancelled, condvar) = &*canceller;

    let scheduler_handle = thread::spawn(move || {
        start_scheduler(submitter, now, when, canceller);
    });

    let test_thread_result = thread::spawn(move || {
        let _guard2 = mutex2.lock().unwrap();
        std::thread::sleep(Duration::from_millis(50));
        let _guard1 = mutex1.lock().unwrap();
    });

    std::thread::sleep(Duration::from_millis(200));
    scheduler_handle.join().unwrap();
    test_thread_result.join().unwrap();
}

enum When {
    Reschedule,
}