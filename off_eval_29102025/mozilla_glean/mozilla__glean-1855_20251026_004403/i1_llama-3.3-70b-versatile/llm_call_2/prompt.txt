Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
[UniFFI] Define additional hooks needed for Rust<->language interaction
With more stuff happening on the Rust side, especially during initialization, we need some internal hooks to call back and forth between Rust and the language implementation (and docs on what the order is).
</issue>

Patch:
<patch>
diff --git a/glean-core/uniffi/src/core/mod.rs b/glean-core/uniffi/src/core/mod.rs
--- a/glean-core/uniffi/src/core/mod.rs
+++ b/glean-core/uniffi/src/core/mod.rs
@@ -158,6 +158,24 @@ impl Glean {
         false
     }
 
+    /// **This is not meant to be used directly.**
+    ///
+    /// Clears all the metrics that have [`Lifetime::Application`].
+    pub fn clear_application_lifetime_metrics(&self) {
+        //log::trace!("Clearing Lifetime::Application metrics");
+        //if let Some(data) = self.data_store.as_ref() {
+        //    data.clear_lifetime(Lifetime::Application);
+        //}
+
+        // Set internally handled app lifetime metrics again.
+        self.set_application_lifetime_core_metrics();
+    }
+
+    /// Sets internally-handled application lifetime metrics.
+    fn set_application_lifetime_core_metrics(&self) {
+        //self.core_metrics.os.set(self, system::OS);
+    }
+
     /// **This is not meant to be used directly.**
     ///
     /// Sets the value of a "dirty flag" in the permanent storage.
@@ -302,7 +320,7 @@ impl Glean {
         //    log::info!("baseline ping not submitted on active");
         //}
 
-        //self.set_dirty_flag(true);
+        self.set_dirty_flag(true);
     }
 
     /// Performs the collection/cleanup operations required by becoming inactive.
@@ -318,6 +336,20 @@ impl Glean {
         //    log::info!("events ping not submitted on inactive");
         //}
 
-        //self.set_dirty_flag(false);
+        self.set_dirty_flag(false);
+    }
+
+    /// Signals that the environment is ready to submit pings.
+    ///
+    /// Should be called when Glean is initialized to the point where it can correctly assemble pings.
+    /// Usually called from the language binding after all of the core metrics have been set
+    /// and the ping types have been registered.
+    ///
+    /// # Returns
+    ///
+    /// Whether at least one ping was generated.
+    pub fn on_ready_to_submit_pings(&self) -> bool {
+        //self.event_data_store.flush_pending_events_on_startup(self)
+        true
     }
 }

diff --git a/glean-core/uniffi/src/lib.rs b/glean-core/uniffi/src/lib.rs
--- a/glean-core/uniffi/src/lib.rs
+++ b/glean-core/uniffi/src/lib.rs
@@ -75,43 +75,275 @@ fn block_on_dispatcher() {
     dispatcher::block_on_queue()
 }
 
-pub fn glean_initialize(cfg: InternalConfiguration) -> bool {
-    initialize_inner(cfg).is_ok()
-}
+/// Metrics included in every ping as `client_info`.
+#[derive(Debug)]
+pub struct ClientInfoMetrics {
+    /// The build identifier generated by the CI system (e.g. "1234/A").
+    pub app_build: String,
+    /// The user visible version string (e.g. "1.0.3").
+    pub app_display_version: String,
 
-pub fn initialize_inner(cfg: InternalConfiguration) -> Result<()> {
-    let glean = Glean::new(cfg)?;
-    core::setup_glean(glean)?;
+    pub architecture: String,
+    pub os_version: String,
 
-    core::with_glean_mut(|glean| {
-        // The debug view tag might have been set before initialize,
-        // get the cached value and set it.
-        if let Some(tag) = PRE_INIT_DEBUG_VIEW_TAG.get() {
-            let lock = tag.try_lock();
-            if let Ok(ref debug_tag) = lock {
-                glean.set_debug_view_tag(debug_tag);
-            }
+    pub channel: Option<String>,
+    pub android_sdk_version: Option<String>,
+    pub device_manufacturer: Option<String>,
+    pub device_model: Option<String>,
+    pub locale: Option<String>,
+}
+
+impl ClientInfoMetrics {
+    /// Creates the client info with dummy values for all.
+    pub fn unknown() -> Self {
+        ClientInfoMetrics {
+            app_build: "Unknown".to_string(),
+            app_display_version: "Unknown".to_string(),
+            architecture: "Unknown".to_string(),
+            os_version: "Unknown".to_string(),
+            channel: None,
+            android_sdk_version: None,
+            device_manufacturer: None,
+            device_model: None,
+            locale: None,
         }
+    }
+}
 
-        // The log pings debug option might have been set before initialize,
-        // get the cached value and set it.
-        let log_pigs = PRE_INIT_LOG_PINGS.load(Ordering::SeqCst);
-        if log_pigs {
-            glean.set_log_pings(log_pigs);
+/// State to keep track for the Rust Language bindings.
+///
+/// This is useful for setting Glean SDK-owned metrics when
+/// the state of the upload is toggled.
+struct State {
+    /// Client info metrics set by the application.
+    client_info: ClientInfoMetrics,
+
+    callbacks: Box<dyn OnGleanEvents>,
+}
+
+/// A global singleton storing additional state for Glean.
+///
+/// Requires a Mutex, because in tests we can actual reset this.
+static STATE: OnceCell<Mutex<State>> = OnceCell::new();
+
+/// Get a reference to the global state object.
+///
+/// Panics if no global state object was set.
+fn global_state() -> &'static Mutex<State> {
+    STATE.get().unwrap()
+}
+
+/// Set or replace the global bindings State object.
+fn setup_state(state: State) {
+    // The `OnceCell` type wrapping our state is thread-safe and can only be set once.
+    // Therefore even if our check for it being empty succeeds, setting it could fail if a
+    // concurrent thread is quicker in setting it.
+    // However this will not cause a bigger problem, as the second `set` operation will just fail.
+    // We can log it and move on.
+    //
+    // For all wrappers this is not a problem, as the State object is intialized exactly once on
+    // calling `initialize` on the global singleton and further operations check that it has been
+    // initialized.
+    if STATE.get().is_none() {
+        if STATE.set(Mutex::new(state)).is_err() {
+            log::error!(
+                "Global Glean state object is initialized already. This probably happened concurrently."
+            );
         }
+    } else {
+        // We allow overriding the global State object to support test mode.
+        // In test mode the State object is fully destroyed and recreated.
+        // This all happens behind a mutex and is therefore also thread-safe.
+        let mut lock = STATE.get().unwrap().lock().unwrap();
+        *lock = state;
+    }
+}
 
-        // The source tags might have been set before initialize,
-        // get the cached value and set them.
-        if let Some(tags) = PRE_INIT_SOURCE_TAGS.get() {
-            let lock = tags.try_lock();
-            if let Ok(ref source_tags) = lock {
-                glean.set_source_tags(source_tags.to_vec());
+pub trait OnGleanEvents: Send {
+    fn on_initialize_finished(&self);
+
+    fn trigger_upload(&self);
+
+    fn start_metric_ping_scheduler(&self);
+}
+
+pub fn glean_initialize(cfg: InternalConfiguration, client_info: ClientInfoMetrics, callbacks: Box<dyn OnGleanEvents>) -> bool {
+    initialize_inner(cfg, client_info, callbacks).is_ok()
+}
+
+pub fn initialize_inner(cfg: InternalConfiguration, client_info: ClientInfoMetrics, callbacks: Box<dyn OnGleanEvents>) -> Result<()> {
+    if was_initialize_called() {
+        log::error!("Glean should not be initialized multiple times");
+        todo!();
+    }
+
+    let _init_handle = std::thread::Builder::new()
+        .name("glean.init".into())
+        .spawn(move || {
+            let upload_enabled = cfg.upload_enabled;
+
+            let glean = match Glean::new(cfg) {
+                Ok(glean) => glean,
+                Err(err) => {
+                    log::error!("Failed to initialize Glean: {}", err);
+                    return;
+                }
+            };
+            if core::setup_glean(glean).is_err() {
+                return;
             }
-        }
-    });
+
+            log::info!("Glean initialized");
+
+            setup_state(State {
+                client_info,
+                callbacks,
+            });
+
+            core::with_glean_mut(|glean| {
+                let state = global_state().lock().unwrap();
+
+                // The debug view tag might have been set before initialize,
+                // get the cached value and set it.
+                if let Some(tag) = PRE_INIT_DEBUG_VIEW_TAG.get() {
+                    let lock = tag.try_lock();
+                    if let Ok(ref debug_tag) = lock {
+                        glean.set_debug_view_tag(debug_tag);
+                    }
+                }
+
+                // The log pings debug option might have been set before initialize,
+                // get the cached value and set it.
+                let log_pigs = PRE_INIT_LOG_PINGS.load(Ordering::SeqCst);
+                if log_pigs {
+                    glean.set_log_pings(log_pigs);
+                }
+
+                // The source tags might have been set before initialize,
+                // get the cached value and set them.
+                if let Some(tags) = PRE_INIT_SOURCE_TAGS.get() {
+                    let lock = tags.try_lock();
+                    if let Ok(ref source_tags) = lock {
+                        glean.set_source_tags(source_tags.to_vec());
+                    }
+                }
+
+                // Get the current value of the dirty flag so we know whether to
+                // send a dirty startup baseline ping below.  Immediately set it to
+                // `false` so that dirty startup pings won't be sent if Glean
+                // initialization does not complete successfully.
+                // TODO Bug 1672956 will decide where to set this flag again.
+                let dirty_flag = glean.is_dirty_flag_set();
+                glean.set_dirty_flag(false);
+
+                // Register builtin pings.
+                // Unfortunately we need to manually list them here to guarantee
+                // they are registered synchronously before we need them.
+                // We don't need to handle the deletion-request ping. It's never touched
+                // from the language implementation.
+                //
+                // Note: this will actually double-register them.
+                // On instantiation they will launch a task to register themselves.
+                // That task could fail to run if the dispatcher queue is full.
+                // We still register them here synchronously.
+                //glean.register_ping_type(&glean_metrics::pings::baseline.ping_type);
+                //glean.register_ping_type(&glean_metrics::pings::metrics.ping_type);
+                //glean.register_ping_type(&glean_metrics::pings::events.ping_type);
+
+                // Perform registration of pings that were attempted to be
+                // registered before init.
+                //if let Some(tags) = PRE_INIT_PING_REGISTRATION.get() {
+                //    let lock = tags.try_lock();
+                //    if let Ok(pings) = lock {
+                //        for ping in &*pings {
+                //            glean.register_ping_type(&ping.ping_type);
+                //        }
+                //    }
+                //}
+
+                // If this is the first time ever the Glean SDK runs, make sure to set
+                // some initial core metrics in case we need to generate early pings.
+                // The next times we start, we would have them around already.
+                let is_first_run = glean.is_first_run();
+                if is_first_run {
+                    initialize_core_metrics(glean, &state.client_info);
+                }
+
+                // Deal with any pending events so we can start recording new ones
+                let pings_submitted = glean.on_ready_to_submit_pings();
+
+                // We need to kick off upload in these cases:
+                // 1. Pings were submitted through Glean and it is ready to upload those pings;
+                // 2. Upload is disabled, to upload a possible deletion-request ping.
+                if pings_submitted || !upload_enabled {
+                    state.callbacks.trigger_upload();
+                }
+
+                // Set up information and scheduling for Glean owned pings. Ideally, the "metrics"
+                // ping startup check should be performed before any other ping, since it relies
+                // on being dispatched to the API context before any other metric.
+                state.callbacks.start_metric_ping_scheduler();
+
+                // Check if the "dirty flag" is set. That means the product was probably
+                // force-closed. If that's the case, submit a 'baseline' ping with the
+                // reason "dirty_startup". We only do that from the second run.
+                if !is_first_run && dirty_flag {
+                    // The `submit_ping_by_name_sync` function cannot be used, otherwise
+                    // startup will cause a dead-lock, since that function requests a
+                    // write lock on the `glean` object.
+                    // Note that unwrapping below is safe: the function will return an
+                    // `Ok` value for a known ping.
+                    if glean.submit_ping_by_name("baseline", Some("dirty_startup")) {
+                        state.callbacks.trigger_upload();
+                    }
+                }
+
+                // From the second time we run, after all startup pings are generated,
+                // make sure to clear `lifetime: application` metrics and set them again.
+                // Any new value will be sent in newly generated pings after startup.
+                if !is_first_run {
+                    glean.clear_application_lifetime_metrics();
+                    initialize_core_metrics(glean, &state.client_info);
+                }
+            });
+
+            // Signal Dispatcher that init is complete
+            match dispatcher::flush_init() {
+                Ok(task_count) if task_count > 0 => {
+                    core::with_glean(|glean| {
+                        //glean_metrics::error::preinit_tasks_overflow
+                            //.add_sync(glean, task_count as i32);
+                    });
+                }
+                Ok(_) => {}
+                Err(err) => log::error!("Unable to flush the preinit queue: {}", err),
+            }
+
+            let state = global_state().lock().unwrap();
+            state.callbacks.on_initialize_finished();
+        })
+        .expect("Failed to spawn Glean's init thread");
+
+    // Mark the initialization as called: this needs to happen outside of the
+    // dispatched block!
+    INITIALIZE_CALLED.store(true, Ordering::SeqCst);
     Ok(())
 }
 
+fn initialize_core_metrics(
+    glean: &Glean,
+    client_info: &ClientInfoMetrics,
+) {
+    //core_metrics::internal_metrics::app_build.set_sync(glean, &client_info.app_build[..]);
+    //core_metrics::internal_metrics::app_display_version
+    //    .set_sync(glean, &client_info.app_display_version[..]);
+    //if let Some(app_channel) = client_info.channel {
+    //    core_metrics::internal_metrics::app_channel.set_sync(glean, app_channel);
+    //}
+    //core_metrics::internal_metrics::os_version.set_sync(glean, system::get_os_version());
+    //core_metrics::internal_metrics::architecture.set_sync(glean, system::ARCH.to_string());
+}
+
 pub fn glean_finish_initialize() -> bool {
     // Signal Dispatcher that init is complete
     log::info!("Flushing dispatcher after initialization finished.");
@@ -171,21 +403,21 @@ pub trait OnUploadEnabledChanges {
     fn on_disabled(&self);
 }
 
-pub fn glean_set_upload_enabled(enabled: bool, changes_callback: Box<dyn OnUploadEnabledChanges>) {
+pub fn glean_set_upload_enabled(enabled: bool) {
     core::with_glean_mut(|glean| {
         let original_enabled = glean.is_upload_enabled();
         if !enabled {
-            changes_callback.will_be_disabled();
+            //changes_callback.will_be_disabled();
         }
 
         glean.set_upload_enabled(enabled);
 
         if !original_enabled && enabled {
-            changes_callback.on_enabled();
+            //changes_callback.on_enabled();
         }
 
         if original_enabled && !enabled {
-            changes_callback.on_disabled();
+            //changes_callback.on_disabled();
         }
     })
 }
@@ -296,14 +528,15 @@ pub trait OnTriggerUpload: Send {
 /// and then sets the dirty bit.
 /// This should be called whenever the consuming product becomes active (e.g.
 /// getting to foreground).
-pub fn glean_handle_client_active(callback: Box<dyn OnTriggerUpload>) {
+pub fn glean_handle_client_active() {
     crate::launch_with_glean_mut(move |glean| {
         glean.handle_client_active();
 
         // The above call may generate pings, so we need to trigger
         // the uploader. It's fine to trigger it if no ping was generated:
         // it will bail out.
-        callback.trigger_upload();
+        let state = global_state().lock().unwrap();
+        state.callbacks.trigger_upload();
     });
 
     // The previous block of code may send a ping containing the `duration` metric,
@@ -319,7 +552,7 @@ pub fn glean_handle_client_active(callback: Box<dyn OnTriggerUpload>) {
 /// `inactive` and then clears the dirty bit.
 /// This should be called whenever the consuming product becomes inactive (e.g.
 /// getting to background).
-pub fn glean_handle_client_inactive(callback: Box<dyn OnTriggerUpload>) {
+pub fn glean_handle_client_inactive() {
     // This needs to be called before the `handle_client_inactive` api: it stops
     // measuring the duration of the previous activity time, before any ping is sent
     // by the next call.
@@ -331,7 +564,8 @@ pub fn glean_handle_client_inactive(callback: Box<dyn OnTriggerUpload>) {
         // The above call may generate pings, so we need to trigger
         // the uploader. It's fine to trigger it if no ping was generated:
         // it will bail out.
-        callback.trigger_upload();
+        let state = global_state().lock().unwrap();
+        state.callbacks.trigger_upload();
     })
 }


</patch>

<TEST>
<Filename>glean-core/uniffi/src/core/mod.rs</Filename>
<imports>use super::glean_initialize;
use super::glean_handle_client_active;
use super::glean_handle_client_inactive;
use std::sync::Once;
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Mutex;
use std::thread;</imports>
<Rust>#[test]
fn test_glean_initialize_and_client_active_inactive() {
  let client_info = super::ClientInfoMetrics {
    app_build: "test".to_string(),
    app_display_version: "1.0".to_string(),
    architecture: "x86_64".to_string(),
    os_version: "test".to_string(),
    channel: None,
    android_sdk_version: None,
    device_manufacturer: None,
    device_model: None,
    locale: None,
  };
  let callbacks = Box::new(struct TestCallbacks);
  impl super::OnGleanEvents for TestCallbacks {
    fn on_initialize_finished(&self) {}
    fn trigger_upload(&self) {}
    fn start_metric_ping_scheduler(&self) {}
  }
  let _ = glean_initialize(super::InternalConfiguration { upload_enabled: true }, client_info, callbacks);
  glean_handle_client_active();
  glean_handle_client_inactive();
  assert!(true);
}
</Rust>
</TEST>

<output>
error: failed to run custom build command for `glean-uniffi v0.1.0 (/app/testbed/glean-core/uniffi)`
</output>

Function signatures
<Signatures>
pub fn glean_handle_client_inactive() -> ()

pub fn glean_handle_client_active() -> ()

fn block_on_dispatcher() -> ()
</Signatures>

You are a software tester at glean and your are reviewing the above <patch> for the above <issue>.
A unit test has already been created for this PR and can be found alongside the filename and the imports used inside the <TEST> block.
It currently contains linting issues, which are inside the <output> block.
Your task is to:
1. Identify and understand the linting issue introduced by the unit test.
2. Update the unit test in the <TEST> block to resolve these issues.
3. The test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
4. All 'use' declarations must be inside a <imports>...</imports> block. Additionally:
   - Do not use group imports.
  - Import only what is necessary for the test to run and make sure not to have colliding imports.
  - If the <patch> contains a 'mod tests' block with useful imports, do not add them to the <imports> block.
  - Use `use super::<function name> for the function under test.
.  - If multiple 'use' statements are needed, list each on a separate line.
5. To help you write the test, <Signatures> contains all modified function's:
  - name
  - parameters
  - Return type (assume '()' if empty)
6. Return only the absolute filename as it is in the <patch> block, the use statements, and rust test (no comments or explanations).

Follow this expected output format, do not deviate from this structure:
<Filename> ... </Filename>
<imports> ... </imports>
<Rust>
#[test]
fn test_<describe_behavior>() {
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
}</Rust>

